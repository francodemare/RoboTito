   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 4
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"tasks.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.prvIdleTask,"ax",%progbits
  18              		.align	1
  19              		.code	16
  20              		.thumb_func
  22              	prvIdleTask:
  23              	.LFB22:
  24              		.file 1 "../Generated_Code/tasks.c"
   1:../Generated_Code/tasks.c **** /*
   2:../Generated_Code/tasks.c ****     FreeRTOS V7.2.0 - Copyright (C) 2012 Real Time Engineers Ltd.
   3:../Generated_Code/tasks.c **** 	
   4:../Generated_Code/tasks.c **** 
   5:../Generated_Code/tasks.c ****     ***************************************************************************
   6:../Generated_Code/tasks.c ****      *                                                                       *
   7:../Generated_Code/tasks.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../Generated_Code/tasks.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../Generated_Code/tasks.c ****      *    available.                                                         *
  10:../Generated_Code/tasks.c ****      *                                                                       *
  11:../Generated_Code/tasks.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../Generated_Code/tasks.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../Generated_Code/tasks.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../Generated_Code/tasks.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../Generated_Code/tasks.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../Generated_Code/tasks.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../Generated_Code/tasks.c ****      *                                                                       *
  18:../Generated_Code/tasks.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../Generated_Code/tasks.c ****      *                                                                       *
  20:../Generated_Code/tasks.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../Generated_Code/tasks.c ****      *                                                                       *
  22:../Generated_Code/tasks.c ****     ***************************************************************************
  23:../Generated_Code/tasks.c **** 
  24:../Generated_Code/tasks.c **** 
  25:../Generated_Code/tasks.c ****     This file is part of the FreeRTOS distribution.
  26:../Generated_Code/tasks.c **** 
  27:../Generated_Code/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../Generated_Code/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../Generated_Code/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../Generated_Code/tasks.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../Generated_Code/tasks.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../Generated_Code/tasks.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../Generated_Code/tasks.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../Generated_Code/tasks.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../Generated_Code/tasks.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../Generated_Code/tasks.c ****     more details. You should have received a copy of the GNU General Public
  37:../Generated_Code/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../Generated_Code/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../Generated_Code/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../Generated_Code/tasks.c ****     FreeRTOS WEB site.
  41:../Generated_Code/tasks.c **** 
  42:../Generated_Code/tasks.c ****     1 tab == 4 spaces!
  43:../Generated_Code/tasks.c ****     
  44:../Generated_Code/tasks.c ****     ***************************************************************************
  45:../Generated_Code/tasks.c ****      *                                                                       *
  46:../Generated_Code/tasks.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  47:../Generated_Code/tasks.c ****      *    not run, what could be wrong?                                      *
  48:../Generated_Code/tasks.c ****      *                                                                       *
  49:../Generated_Code/tasks.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  50:../Generated_Code/tasks.c ****      *                                                                       *
  51:../Generated_Code/tasks.c ****     ***************************************************************************
  52:../Generated_Code/tasks.c **** 
  53:../Generated_Code/tasks.c ****     
  54:../Generated_Code/tasks.c ****     http://www.FreeRTOS.org - Documentation, training, latest information, 
  55:../Generated_Code/tasks.c ****     license and contact details.
  56:../Generated_Code/tasks.c ****     
  57:../Generated_Code/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  58:../Generated_Code/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool.
  59:../Generated_Code/tasks.c **** 
  60:../Generated_Code/tasks.c ****     Real Time Engineers ltd license FreeRTOS to High Integrity Systems, who sell 
  61:../Generated_Code/tasks.c ****     the code with commercial support, indemnification, and middleware, under 
  62:../Generated_Code/tasks.c ****     the OpenRTOS brand: http://www.OpenRTOS.com.  High Integrity Systems also
  63:../Generated_Code/tasks.c ****     provide a safety engineered and independently SIL3 certified version under 
  64:../Generated_Code/tasks.c ****     the SafeRTOS brand: http://www.SafeRTOS.com.
  65:../Generated_Code/tasks.c **** */
  66:../Generated_Code/tasks.c **** 
  67:../Generated_Code/tasks.c **** 
  68:../Generated_Code/tasks.c **** #include <stdio.h>
  69:../Generated_Code/tasks.c **** #include <stdlib.h>
  70:../Generated_Code/tasks.c **** #include <string.h>
  71:../Generated_Code/tasks.c **** 
  72:../Generated_Code/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  73:../Generated_Code/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  74:../Generated_Code/tasks.c **** task.h is included from an application file. */
  75:../Generated_Code/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  76:../Generated_Code/tasks.c **** 
  77:../Generated_Code/tasks.c **** #include "Events.h"
  78:../Generated_Code/tasks.c **** #include "FRTOS1.h" /* interface to the runtime counter */
  79:../Generated_Code/tasks.c **** 
  80:../Generated_Code/tasks.c **** #include "FreeRTOS.h"
  81:../Generated_Code/tasks.c **** #include "task.h"
  82:../Generated_Code/tasks.c **** #include "timers.h"
  83:../Generated_Code/tasks.c **** #include "StackMacros.h"
  84:../Generated_Code/tasks.c **** 
  85:../Generated_Code/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  86:../Generated_Code/tasks.c **** 
  87:../Generated_Code/tasks.c **** /*
  88:../Generated_Code/tasks.c ****  * Macro to define the amount of stack available to the idle task.
  89:../Generated_Code/tasks.c ****  */
  90:../Generated_Code/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  91:../Generated_Code/tasks.c **** 
  92:../Generated_Code/tasks.c **** /*
  93:../Generated_Code/tasks.c ****  * Task control block.  A task control block (TCB) is allocated to each task,
  94:../Generated_Code/tasks.c ****  * and stores the context of the task.
  95:../Generated_Code/tasks.c ****  */
  96:../Generated_Code/tasks.c **** typedef struct tskTaskControlBlock
  97:../Generated_Code/tasks.c **** {
  98:../Generated_Code/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
  99:../Generated_Code/tasks.c **** 
 100:../Generated_Code/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 101:../Generated_Code/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
 102:../Generated_Code/tasks.c **** 	#endif	
 103:../Generated_Code/tasks.c **** 	
 104:../Generated_Code/tasks.c **** 	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
 105:../Generated_Code/tasks.c **** 	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
 106:../Generated_Code/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. 
 107:../Generated_Code/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
 108:../Generated_Code/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
 109:../Generated_Code/tasks.c **** 
 110:../Generated_Code/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
 111:../Generated_Code/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the s
 112:../Generated_Code/tasks.c **** 	#endif
 113:../Generated_Code/tasks.c **** 
 114:../Generated_Code/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 115:../Generated_Code/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting;
 116:../Generated_Code/tasks.c **** 	#endif
 117:../Generated_Code/tasks.c **** 
 118:../Generated_Code/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 119:../Generated_Code/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< This stores a number that increments each time a TCB is c
 120:../Generated_Code/tasks.c **** 		unsigned portBASE_TYPE  uxTaskNumber;	/*< This stores a number specifically for use by third part
 121:../Generated_Code/tasks.c **** 	#endif
 122:../Generated_Code/tasks.c **** 
 123:../Generated_Code/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 124:../Generated_Code/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 125:../Generated_Code/tasks.c **** 	#endif
 126:../Generated_Code/tasks.c **** 
 127:../Generated_Code/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 128:../Generated_Code/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 129:../Generated_Code/tasks.c **** 	#endif
 130:../Generated_Code/tasks.c **** 
 131:../Generated_Code/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 132:../Generated_Code/tasks.c **** 		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilisin
 133:../Generated_Code/tasks.c **** 	#endif
 134:../Generated_Code/tasks.c **** 
 135:../Generated_Code/tasks.c **** } tskTCB;
 136:../Generated_Code/tasks.c **** 
 137:../Generated_Code/tasks.c **** 
 138:../Generated_Code/tasks.c **** /*
 139:../Generated_Code/tasks.c ****  * Some kernel aware debuggers require data to be viewed to be global, rather
 140:../Generated_Code/tasks.c ****  * than file scope.
 141:../Generated_Code/tasks.c ****  */
 142:../Generated_Code/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 143:../Generated_Code/tasks.c **** 	#define static
 144:../Generated_Code/tasks.c **** #endif
 145:../Generated_Code/tasks.c **** 
 146:../Generated_Code/tasks.c **** /*lint -e956 */
 147:../Generated_Code/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 148:../Generated_Code/tasks.c **** 
 149:../Generated_Code/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 150:../Generated_Code/tasks.c **** 
 151:../Generated_Code/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 152:../Generated_Code/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 153:../Generated_Code/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 154:../Generated_Code/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 155:../Generated_Code/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 156:../Generated_Code/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 157:../Generated_Code/tasks.c **** 
 158:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 159:../Generated_Code/tasks.c **** 
 160:../Generated_Code/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 161:../Generated_Code/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 162:../Generated_Code/tasks.c **** 
 163:../Generated_Code/tasks.c **** #endif
 164:../Generated_Code/tasks.c **** 
 165:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 166:../Generated_Code/tasks.c **** 
 167:../Generated_Code/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 168:../Generated_Code/tasks.c **** 
 169:../Generated_Code/tasks.c **** #endif
 170:../Generated_Code/tasks.c **** 
 171:../Generated_Code/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 172:../Generated_Code/tasks.c **** 	
 173:../Generated_Code/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;
 174:../Generated_Code/tasks.c **** 	
 175:../Generated_Code/tasks.c **** #endif
 176:../Generated_Code/tasks.c **** 
 177:../Generated_Code/tasks.c **** /* File private variables. --------------------------------*/
 178:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 179:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 180:../Generated_Code/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 181:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 182:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 183:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 184:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 185:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 186:../Generated_Code/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 187:../Generated_Code/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0U;
 188:../Generated_Code/tasks.c **** PRIVILEGED_DATA static portTickType xNextTaskUnblockTime						= ( portTickType ) portMAX_DELAY;
 189:../Generated_Code/tasks.c **** 
 190:../Generated_Code/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 191:../Generated_Code/tasks.c **** 	/*PRIVILEGED_DATA static char pcStatsString[ 50 ] ;*/
 192:../Generated_Code/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 193:../Generated_Code/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList(unsigned char *pcWriteBuffer, size_t bufSize, xL
 194:../Generated_Code/tasks.c **** 
 195:../Generated_Code/tasks.c **** #endif
 196:../Generated_Code/tasks.c **** 
 197:../Generated_Code/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 198:../Generated_Code/tasks.c **** 
 199:../Generated_Code/tasks.c **** /*
 200:../Generated_Code/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 201:../Generated_Code/tasks.c ****  * is used purely for checking the high water mark for tasks.
 202:../Generated_Code/tasks.c ****  */
 203:../Generated_Code/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 204:../Generated_Code/tasks.c **** 
 205:../Generated_Code/tasks.c **** /*
 206:../Generated_Code/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 207:../Generated_Code/tasks.c ****  */
 208:../Generated_Code/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 209:../Generated_Code/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 210:../Generated_Code/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 211:../Generated_Code/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 212:../Generated_Code/tasks.c **** 
 213:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 214:../Generated_Code/tasks.c **** 
 215:../Generated_Code/tasks.c **** /*
 216:../Generated_Code/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 217:../Generated_Code/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 218:../Generated_Code/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 219:../Generated_Code/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 220:../Generated_Code/tasks.c ****  * executing task has been rescheduled.
 221:../Generated_Code/tasks.c ****  */
 222:../Generated_Code/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																					\
 223:../Generated_Code/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB )																				\
 224:../Generated_Code/tasks.c **** 	if( ( pxTCB )->uxPriority > uxTopReadyPriority )																	\
 225:../Generated_Code/tasks.c **** 	{																													\
 226:../Generated_Code/tasks.c **** 		uxTopReadyPriority = ( pxTCB )->uxPriority;																		\
 227:../Generated_Code/tasks.c **** 	}																													\
 228:../Generated_Code/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGeneri
 229:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 230:../Generated_Code/tasks.c **** 
 231:../Generated_Code/tasks.c **** /*
 232:../Generated_Code/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 233:../Generated_Code/tasks.c ****  * any require waking.
 234:../Generated_Code/tasks.c ****  *
 235:../Generated_Code/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 236:../Generated_Code/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 237:../Generated_Code/tasks.c ****  * any further down the list.
 238:../Generated_Code/tasks.c ****  */
 239:../Generated_Code/tasks.c **** #define prvCheckDelayedTasks()															\
 240:../Generated_Code/tasks.c **** {																						\
 241:../Generated_Code/tasks.c **** portTickType xItemValue;																\
 242:../Generated_Code/tasks.c **** 																						\
 243:../Generated_Code/tasks.c **** 	/* Is the tick count greater than or equal to the wake time of the first			\
 244:../Generated_Code/tasks.c **** 	task referenced from the delayed tasks list? */										\
 245:../Generated_Code/tasks.c **** 	if( xTickCount >= xNextTaskUnblockTime )											\
 246:../Generated_Code/tasks.c **** 	{																					\
 247:../Generated_Code/tasks.c **** 		for( ;; )																		\
 248:../Generated_Code/tasks.c **** 		{																				\
 249:../Generated_Code/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
 250:../Generated_Code/tasks.c **** 			{																			\
 251:../Generated_Code/tasks.c **** 				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
 252:../Generated_Code/tasks.c **** 				maximum possible value so it is extremely unlikely that the				\
 253:../Generated_Code/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
 254:../Generated_Code/tasks.c **** 				time through. */														\
 255:../Generated_Code/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;									\
 256:../Generated_Code/tasks.c **** 				break;																	\
 257:../Generated_Code/tasks.c **** 			}																			\
 258:../Generated_Code/tasks.c **** 			else																		\
 259:../Generated_Code/tasks.c **** 			{																			\
 260:../Generated_Code/tasks.c **** 				/* The delayed list is not empty, get the value of the item at			\
 261:../Generated_Code/tasks.c **** 				the head of the delayed list.  This is the time at which the			\
 262:../Generated_Code/tasks.c **** 				task at the head of the delayed list should be removed from				\
 263:../Generated_Code/tasks.c **** 				the Blocked state. */													\
 264:../Generated_Code/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
 265:../Generated_Code/tasks.c **** 				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
 266:../Generated_Code/tasks.c **** 																						\
 267:../Generated_Code/tasks.c **** 				if( xTickCount < xItemValue )											\
 268:../Generated_Code/tasks.c **** 				{																		\
 269:../Generated_Code/tasks.c **** 					/* It is not time to unblock this item yet, but the item			\
 270:../Generated_Code/tasks.c **** 					value is the time at which the task at the head of the				\
 271:../Generated_Code/tasks.c **** 					blocked list should be removed from the Blocked state -				\
 272:../Generated_Code/tasks.c **** 					so record the item value in xNextTaskUnblockTime. */				\
 273:../Generated_Code/tasks.c **** 					xNextTaskUnblockTime = xItemValue;									\
 274:../Generated_Code/tasks.c **** 					break;																\
 275:../Generated_Code/tasks.c **** 				}																		\
 276:../Generated_Code/tasks.c **** 																						\
 277:../Generated_Code/tasks.c **** 				/* It is time to remove the item from the Blocked state. */				\
 278:../Generated_Code/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );							\
 279:../Generated_Code/tasks.c **** 																						\
 280:../Generated_Code/tasks.c **** 				/* Is the task waiting on an event also? */								\
 281:../Generated_Code/tasks.c **** 				if( pxTCB->xEventListItem.pvContainer != NULL )							\
 282:../Generated_Code/tasks.c **** 				{																		\
 283:../Generated_Code/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );							\
 284:../Generated_Code/tasks.c **** 				}																		\
 285:../Generated_Code/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );										\
 286:../Generated_Code/tasks.c **** 			}																			\
 287:../Generated_Code/tasks.c **** 		}																				\
 288:../Generated_Code/tasks.c **** 	}																					\
 289:../Generated_Code/tasks.c **** }
 290:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 291:../Generated_Code/tasks.c **** 
 292:../Generated_Code/tasks.c **** /*
 293:../Generated_Code/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 294:../Generated_Code/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 295:../Generated_Code/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 296:../Generated_Code/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 297:../Generated_Code/tasks.c ****  */
 298:../Generated_Code/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 299:../Generated_Code/tasks.c **** 
 300:../Generated_Code/tasks.c **** /* Callback function prototypes. --------------------------*/
 301:../Generated_Code/tasks.c **** #if 0 /* << EST not used in this file */
 302:../Generated_Code/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName );
 303:../Generated_Code/tasks.c **** extern void vApplicationTickHook( void );
 304:../Generated_Code/tasks.c **** #endif
 305:../Generated_Code/tasks.c **** 		
 306:../Generated_Code/tasks.c **** /* File private functions. --------------------------------*/
 307:../Generated_Code/tasks.c **** 
 308:../Generated_Code/tasks.c **** /*
 309:../Generated_Code/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 310:../Generated_Code/tasks.c ****  * into the TCB structure.
 311:../Generated_Code/tasks.c ****  */
 312:../Generated_Code/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 313:../Generated_Code/tasks.c **** 
 314:../Generated_Code/tasks.c **** /*
 315:../Generated_Code/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 316:../Generated_Code/tasks.c ****  * automatically upon the creation of the first task.
 317:../Generated_Code/tasks.c ****  */
 318:../Generated_Code/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 319:../Generated_Code/tasks.c **** 
 320:../Generated_Code/tasks.c **** /*
 321:../Generated_Code/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 322:../Generated_Code/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 323:../Generated_Code/tasks.c ****  * creation of the first user task.
 324:../Generated_Code/tasks.c ****  *
 325:../Generated_Code/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 326:../Generated_Code/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 327:../Generated_Code/tasks.c ****  *
 328:../Generated_Code/tasks.c ****  * void prvIdleTask( void *pvParameters );
 329:../Generated_Code/tasks.c ****  *
 330:../Generated_Code/tasks.c ****  */
 331:../Generated_Code/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 332:../Generated_Code/tasks.c **** 
 333:../Generated_Code/tasks.c **** /*
 334:../Generated_Code/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 335:../Generated_Code/tasks.c ****  * including the stack pointed to by the TCB.
 336:../Generated_Code/tasks.c ****  *
 337:../Generated_Code/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 338:../Generated_Code/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 339:../Generated_Code/tasks.c ****  */
 340:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 341:../Generated_Code/tasks.c **** 
 342:../Generated_Code/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 343:../Generated_Code/tasks.c **** 
 344:../Generated_Code/tasks.c **** #endif
 345:../Generated_Code/tasks.c **** 
 346:../Generated_Code/tasks.c **** /*
 347:../Generated_Code/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 348:../Generated_Code/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 349:../Generated_Code/tasks.c ****  * and its TCB deleted.
 350:../Generated_Code/tasks.c ****  */
 351:../Generated_Code/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 352:../Generated_Code/tasks.c **** 
 353:../Generated_Code/tasks.c **** /*
 354:../Generated_Code/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 355:../Generated_Code/tasks.c ****  * either the current or the overflow delayed task list.
 356:../Generated_Code/tasks.c ****  */
 357:../Generated_Code/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 358:../Generated_Code/tasks.c **** 
 359:../Generated_Code/tasks.c **** /*
 360:../Generated_Code/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 361:../Generated_Code/tasks.c ****  * allocation was successful.
 362:../Generated_Code/tasks.c ****  */
 363:../Generated_Code/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 364:../Generated_Code/tasks.c **** 
 365:../Generated_Code/tasks.c **** /*
 366:../Generated_Code/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 367:../Generated_Code/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 368:../Generated_Code/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 369:../Generated_Code/tasks.c ****  * within just that list.
 370:../Generated_Code/tasks.c ****  *
 371:../Generated_Code/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 372:../Generated_Code/tasks.c ****  * NORMAL APPLICATION CODE.
 373:../Generated_Code/tasks.c ****  */
 374:../Generated_Code/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 375:../Generated_Code/tasks.c **** 
 376:../Generated_Code/tasks.c **** 	static void prvListTaskWithinSingleList(unsigned char *pcWriteBuffer, size_t bufSize, xList *pxLis
 377:../Generated_Code/tasks.c **** 
 378:../Generated_Code/tasks.c **** #endif
 379:../Generated_Code/tasks.c **** 
 380:../Generated_Code/tasks.c **** /*
 381:../Generated_Code/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 382:../Generated_Code/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 383:../Generated_Code/tasks.c ****  * determining how much of the stack remains at the original preset value.
 384:../Generated_Code/tasks.c ****  */
 385:../Generated_Code/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 386:../Generated_Code/tasks.c **** 
 387:../Generated_Code/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 388:../Generated_Code/tasks.c **** 
 389:../Generated_Code/tasks.c **** #endif
 390:../Generated_Code/tasks.c **** 
 391:../Generated_Code/tasks.c **** 
 392:../Generated_Code/tasks.c **** /*lint +e956 */
 393:../Generated_Code/tasks.c **** 
 394:../Generated_Code/tasks.c **** 
 395:../Generated_Code/tasks.c **** 
 396:../Generated_Code/tasks.c **** /*-----------------------------------------------------------
 397:../Generated_Code/tasks.c ****  * TASK CREATION API documented in task.h
 398:../Generated_Code/tasks.c ****  *----------------------------------------------------------*/
 399:../Generated_Code/tasks.c **** 
 400:../Generated_Code/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 401:../Generated_Code/tasks.c **** {
 402:../Generated_Code/tasks.c **** signed portBASE_TYPE xReturn;
 403:../Generated_Code/tasks.c **** tskTCB * pxNewTCB;
 404:../Generated_Code/tasks.c **** 
 405:../Generated_Code/tasks.c **** 	configASSERT( pxTaskCode );
 406:../Generated_Code/tasks.c **** 	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 407:../Generated_Code/tasks.c **** 
 408:../Generated_Code/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 409:../Generated_Code/tasks.c **** 	checking that the allocation was successful. */
 410:../Generated_Code/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 411:../Generated_Code/tasks.c **** 
 412:../Generated_Code/tasks.c **** 	if( pxNewTCB != NULL )
 413:../Generated_Code/tasks.c **** 	{
 414:../Generated_Code/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 415:../Generated_Code/tasks.c **** 
 416:../Generated_Code/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 417:../Generated_Code/tasks.c **** 			/* Should the task be created in privileged mode? */
 418:../Generated_Code/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 419:../Generated_Code/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 420:../Generated_Code/tasks.c **** 			{
 421:../Generated_Code/tasks.c **** 				xRunPrivileged = pdTRUE;
 422:../Generated_Code/tasks.c **** 			}
 423:../Generated_Code/tasks.c **** 			else
 424:../Generated_Code/tasks.c **** 			{
 425:../Generated_Code/tasks.c **** 				xRunPrivileged = pdFALSE;
 426:../Generated_Code/tasks.c **** 			}
 427:../Generated_Code/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 428:../Generated_Code/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 429:../Generated_Code/tasks.c **** 
 430:../Generated_Code/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 431:../Generated_Code/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 432:../Generated_Code/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 433:../Generated_Code/tasks.c **** 		required by the port. */
 434:../Generated_Code/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 435:../Generated_Code/tasks.c **** 		{
 436:../Generated_Code/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 437:../Generated_Code/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 438:../Generated_Code/tasks.c **** 
 439:../Generated_Code/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 440:../Generated_Code/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 441:../Generated_Code/tasks.c **** 		}
 442:../Generated_Code/tasks.c **** 		#else
 443:../Generated_Code/tasks.c **** 		{
 444:../Generated_Code/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 445:../Generated_Code/tasks.c **** 			
 446:../Generated_Code/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 447:../Generated_Code/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 448:../Generated_Code/tasks.c **** 
 449:../Generated_Code/tasks.c **** 			/* If we want to use stack checking on architectures that use
 450:../Generated_Code/tasks.c **** 			a positive stack growth direction then we also need to store the
 451:../Generated_Code/tasks.c **** 			other extreme of the stack space. */
 452:../Generated_Code/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 453:../Generated_Code/tasks.c **** 		}
 454:../Generated_Code/tasks.c **** 		#endif
 455:../Generated_Code/tasks.c **** 
 456:../Generated_Code/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 457:../Generated_Code/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 458:../Generated_Code/tasks.c **** 
 459:../Generated_Code/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 460:../Generated_Code/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 461:../Generated_Code/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 462:../Generated_Code/tasks.c **** 		the	top of stack variable is updated. */
 463:../Generated_Code/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 464:../Generated_Code/tasks.c **** 		{
 465:../Generated_Code/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 466:../Generated_Code/tasks.c **** 		}
 467:../Generated_Code/tasks.c **** 		#else
 468:../Generated_Code/tasks.c **** 		{
 469:../Generated_Code/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 470:../Generated_Code/tasks.c **** 		}
 471:../Generated_Code/tasks.c **** 		#endif
 472:../Generated_Code/tasks.c **** 
 473:../Generated_Code/tasks.c **** 		/* Check the alignment of the initialised stack. */
 474:../Generated_Code/tasks.c **** 		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long
 475:../Generated_Code/tasks.c **** 
 476:../Generated_Code/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 477:../Generated_Code/tasks.c **** 		{
 478:../Generated_Code/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 479:../Generated_Code/tasks.c **** 			task can use this as a handle to delete the task later if
 480:../Generated_Code/tasks.c **** 			required.*/
 481:../Generated_Code/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 482:../Generated_Code/tasks.c **** 		}
 483:../Generated_Code/tasks.c **** 		
 484:../Generated_Code/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 485:../Generated_Code/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 486:../Generated_Code/tasks.c **** 		taskENTER_CRITICAL();
 487:../Generated_Code/tasks.c **** 		{
 488:../Generated_Code/tasks.c **** 			uxCurrentNumberOfTasks++;
 489:../Generated_Code/tasks.c **** 			if( pxCurrentTCB == NULL )
 490:../Generated_Code/tasks.c **** 			{
 491:../Generated_Code/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 492:../Generated_Code/tasks.c **** 				the suspended state - make this the current task. */
 493:../Generated_Code/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 494:../Generated_Code/tasks.c **** 
 495:../Generated_Code/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 496:../Generated_Code/tasks.c **** 				{
 497:../Generated_Code/tasks.c **** 					/* This is the first task to be created so do the preliminary
 498:../Generated_Code/tasks.c **** 					initialisation required.  We will not recover if this call
 499:../Generated_Code/tasks.c **** 					fails, but we will report the failure. */
 500:../Generated_Code/tasks.c **** 					prvInitialiseTaskLists();
 501:../Generated_Code/tasks.c **** 				}
 502:../Generated_Code/tasks.c **** 			}
 503:../Generated_Code/tasks.c **** 			else
 504:../Generated_Code/tasks.c **** 			{
 505:../Generated_Code/tasks.c **** 				/* If the scheduler is not already running, make this task the
 506:../Generated_Code/tasks.c **** 				current task if it is the highest priority task to be created
 507:../Generated_Code/tasks.c **** 				so far. */
 508:../Generated_Code/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 509:../Generated_Code/tasks.c **** 				{
 510:../Generated_Code/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 511:../Generated_Code/tasks.c **** 					{
 512:../Generated_Code/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 513:../Generated_Code/tasks.c **** 					}
 514:../Generated_Code/tasks.c **** 				}
 515:../Generated_Code/tasks.c **** 			}
 516:../Generated_Code/tasks.c **** 
 517:../Generated_Code/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 518:../Generated_Code/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 519:../Generated_Code/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 520:../Generated_Code/tasks.c **** 			{
 521:../Generated_Code/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 522:../Generated_Code/tasks.c **** 			}
 523:../Generated_Code/tasks.c **** 
 524:../Generated_Code/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 525:../Generated_Code/tasks.c **** 			{
 526:../Generated_Code/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 527:../Generated_Code/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 528:../Generated_Code/tasks.c **** 			}
 529:../Generated_Code/tasks.c **** 			#endif
 530:../Generated_Code/tasks.c **** 			uxTaskNumber++;
 531:../Generated_Code/tasks.c **** 
 532:../Generated_Code/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 533:../Generated_Code/tasks.c **** 
 534:../Generated_Code/tasks.c **** 			xReturn = pdPASS;
 535:../Generated_Code/tasks.c **** 			portSETUP_TCB( pxNewTCB );
 536:../Generated_Code/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 537:../Generated_Code/tasks.c **** 		}
 538:../Generated_Code/tasks.c **** 		taskEXIT_CRITICAL();
 539:../Generated_Code/tasks.c **** 	}
 540:../Generated_Code/tasks.c **** 	else
 541:../Generated_Code/tasks.c **** 	{
 542:../Generated_Code/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 543:../Generated_Code/tasks.c **** 		traceTASK_CREATE_FAILED();
 544:../Generated_Code/tasks.c **** 	}
 545:../Generated_Code/tasks.c **** 
 546:../Generated_Code/tasks.c **** 	if( xReturn == pdPASS )
 547:../Generated_Code/tasks.c **** 	{
 548:../Generated_Code/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 549:../Generated_Code/tasks.c **** 		{
 550:../Generated_Code/tasks.c **** 			/* If the created task is of a higher priority than the current task
 551:../Generated_Code/tasks.c **** 			then it should run now. */
 552:../Generated_Code/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 553:../Generated_Code/tasks.c **** 			{
 554:../Generated_Code/tasks.c **** 				portYIELD_WITHIN_API();
 555:../Generated_Code/tasks.c **** 			}
 556:../Generated_Code/tasks.c **** 		}
 557:../Generated_Code/tasks.c **** 	}
 558:../Generated_Code/tasks.c **** 
 559:../Generated_Code/tasks.c **** 	return xReturn;
 560:../Generated_Code/tasks.c **** }
 561:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 562:../Generated_Code/tasks.c **** 
 563:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 564:../Generated_Code/tasks.c **** 
 565:../Generated_Code/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 566:../Generated_Code/tasks.c **** 	{
 567:../Generated_Code/tasks.c **** 	tskTCB *pxTCB;
 568:../Generated_Code/tasks.c **** 
 569:../Generated_Code/tasks.c **** 		taskENTER_CRITICAL();
 570:../Generated_Code/tasks.c **** 		{
 571:../Generated_Code/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 572:../Generated_Code/tasks.c **** 			deleted. */
 573:../Generated_Code/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 574:../Generated_Code/tasks.c **** 			{
 575:../Generated_Code/tasks.c **** 				pxTaskToDelete = NULL;
 576:../Generated_Code/tasks.c **** 			}
 577:../Generated_Code/tasks.c **** 
 578:../Generated_Code/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 579:../Generated_Code/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 580:../Generated_Code/tasks.c **** 
 581:../Generated_Code/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 582:../Generated_Code/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 583:../Generated_Code/tasks.c **** 			the termination list and free up any memory allocated by the
 584:../Generated_Code/tasks.c **** 			scheduler for the TCB and stack. */
 585:../Generated_Code/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 586:../Generated_Code/tasks.c **** 
 587:../Generated_Code/tasks.c **** 			/* Is the task waiting on an event also? */
 588:../Generated_Code/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 589:../Generated_Code/tasks.c **** 			{
 590:../Generated_Code/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 591:../Generated_Code/tasks.c **** 			}
 592:../Generated_Code/tasks.c **** 
 593:../Generated_Code/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 594:../Generated_Code/tasks.c **** 
 595:../Generated_Code/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 596:../Generated_Code/tasks.c **** 			there is a task that has been deleted and that it should therefore
 597:../Generated_Code/tasks.c **** 			check the xTasksWaitingTermination list. */
 598:../Generated_Code/tasks.c **** 			++uxTasksDeleted;
 599:../Generated_Code/tasks.c **** 
 600:../Generated_Code/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 601:../Generated_Code/tasks.c **** 			can detect that the task lists need re-generating. */
 602:../Generated_Code/tasks.c **** 			uxTaskNumber++;
 603:../Generated_Code/tasks.c **** 
 604:../Generated_Code/tasks.c **** 			traceTASK_DELETE( pxTCB );
 605:../Generated_Code/tasks.c **** 		}
 606:../Generated_Code/tasks.c **** 		taskEXIT_CRITICAL();
 607:../Generated_Code/tasks.c **** 
 608:../Generated_Code/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 609:../Generated_Code/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 610:../Generated_Code/tasks.c **** 		{
 611:../Generated_Code/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 612:../Generated_Code/tasks.c **** 			{
 613:../Generated_Code/tasks.c **** 				portYIELD_WITHIN_API();
 614:../Generated_Code/tasks.c **** 			}
 615:../Generated_Code/tasks.c **** 		}
 616:../Generated_Code/tasks.c **** 	}
 617:../Generated_Code/tasks.c **** 
 618:../Generated_Code/tasks.c **** #endif
 619:../Generated_Code/tasks.c **** 
 620:../Generated_Code/tasks.c **** 
 621:../Generated_Code/tasks.c **** 
 622:../Generated_Code/tasks.c **** 
 623:../Generated_Code/tasks.c **** 
 624:../Generated_Code/tasks.c **** 
 625:../Generated_Code/tasks.c **** /*-----------------------------------------------------------
 626:../Generated_Code/tasks.c ****  * TASK CONTROL API documented in task.h
 627:../Generated_Code/tasks.c ****  *----------------------------------------------------------*/
 628:../Generated_Code/tasks.c **** 
 629:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 630:../Generated_Code/tasks.c **** 
 631:../Generated_Code/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 632:../Generated_Code/tasks.c **** 	{
 633:../Generated_Code/tasks.c **** 	portTickType xTimeToWake;
 634:../Generated_Code/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 635:../Generated_Code/tasks.c **** 
 636:../Generated_Code/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 637:../Generated_Code/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 638:../Generated_Code/tasks.c **** 
 639:../Generated_Code/tasks.c **** 		vTaskSuspendAll();
 640:../Generated_Code/tasks.c **** 		{
 641:../Generated_Code/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 642:../Generated_Code/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 643:../Generated_Code/tasks.c **** 
 644:../Generated_Code/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 645:../Generated_Code/tasks.c **** 			{
 646:../Generated_Code/tasks.c **** 				/* The tick count has overflowed since this function was
 647:../Generated_Code/tasks.c **** 				lasted called.  In this case the only time we should ever
 648:../Generated_Code/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 649:../Generated_Code/tasks.c **** 				and the wake time is greater than the tick time.  When this
 650:../Generated_Code/tasks.c **** 				is the case it is as if neither time had overflowed. */
 651:../Generated_Code/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 652:../Generated_Code/tasks.c **** 				{
 653:../Generated_Code/tasks.c **** 					xShouldDelay = pdTRUE;
 654:../Generated_Code/tasks.c **** 				}
 655:../Generated_Code/tasks.c **** 			}
 656:../Generated_Code/tasks.c **** 			else
 657:../Generated_Code/tasks.c **** 			{
 658:../Generated_Code/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 659:../Generated_Code/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 660:../Generated_Code/tasks.c **** 				tick time is less than the wake time. */
 661:../Generated_Code/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 662:../Generated_Code/tasks.c **** 				{
 663:../Generated_Code/tasks.c **** 					xShouldDelay = pdTRUE;
 664:../Generated_Code/tasks.c **** 				}
 665:../Generated_Code/tasks.c **** 			}
 666:../Generated_Code/tasks.c **** 
 667:../Generated_Code/tasks.c **** 			/* Update the wake time ready for the next call. */
 668:../Generated_Code/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 669:../Generated_Code/tasks.c **** 
 670:../Generated_Code/tasks.c **** 			if( xShouldDelay != pdFALSE )
 671:../Generated_Code/tasks.c **** 			{
 672:../Generated_Code/tasks.c **** 				traceTASK_DELAY_UNTIL();
 673:../Generated_Code/tasks.c **** 
 674:../Generated_Code/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 675:../Generated_Code/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 676:../Generated_Code/tasks.c **** 				both lists. */
 677:../Generated_Code/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 678:../Generated_Code/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 679:../Generated_Code/tasks.c **** 			}
 680:../Generated_Code/tasks.c **** 		}
 681:../Generated_Code/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 682:../Generated_Code/tasks.c **** 
 683:../Generated_Code/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 684:../Generated_Code/tasks.c **** 		have put ourselves to sleep. */
 685:../Generated_Code/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 686:../Generated_Code/tasks.c **** 		{
 687:../Generated_Code/tasks.c **** 			portYIELD_WITHIN_API();
 688:../Generated_Code/tasks.c **** 		}
 689:../Generated_Code/tasks.c **** 	}
 690:../Generated_Code/tasks.c **** 
 691:../Generated_Code/tasks.c **** #endif
 692:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 693:../Generated_Code/tasks.c **** 
 694:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 695:../Generated_Code/tasks.c **** 
 696:../Generated_Code/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 697:../Generated_Code/tasks.c **** 	{
 698:../Generated_Code/tasks.c **** 	portTickType xTimeToWake;
 699:../Generated_Code/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 700:../Generated_Code/tasks.c **** 
 701:../Generated_Code/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 702:../Generated_Code/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 703:../Generated_Code/tasks.c **** 		{
 704:../Generated_Code/tasks.c **** 			vTaskSuspendAll();
 705:../Generated_Code/tasks.c **** 			{
 706:../Generated_Code/tasks.c **** 				traceTASK_DELAY();
 707:../Generated_Code/tasks.c **** 
 708:../Generated_Code/tasks.c **** 				/* A task that is removed from the event list while the
 709:../Generated_Code/tasks.c **** 				scheduler is suspended will not get placed in the ready
 710:../Generated_Code/tasks.c **** 				list or removed from the blocked list until the scheduler
 711:../Generated_Code/tasks.c **** 				is resumed.
 712:../Generated_Code/tasks.c **** 
 713:../Generated_Code/tasks.c **** 				This task cannot be in an event list as it is the currently
 714:../Generated_Code/tasks.c **** 				executing task. */
 715:../Generated_Code/tasks.c **** 
 716:../Generated_Code/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 717:../Generated_Code/tasks.c **** 				not a problem. */
 718:../Generated_Code/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 719:../Generated_Code/tasks.c **** 
 720:../Generated_Code/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 721:../Generated_Code/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 722:../Generated_Code/tasks.c **** 				both lists. */
 723:../Generated_Code/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 724:../Generated_Code/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 725:../Generated_Code/tasks.c **** 			}
 726:../Generated_Code/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 727:../Generated_Code/tasks.c **** 		}
 728:../Generated_Code/tasks.c **** 
 729:../Generated_Code/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 730:../Generated_Code/tasks.c **** 		have put ourselves to sleep. */
 731:../Generated_Code/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 732:../Generated_Code/tasks.c **** 		{
 733:../Generated_Code/tasks.c **** 			portYIELD_WITHIN_API();
 734:../Generated_Code/tasks.c **** 		}
 735:../Generated_Code/tasks.c **** 	}
 736:../Generated_Code/tasks.c **** 
 737:../Generated_Code/tasks.c **** #endif
 738:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 739:../Generated_Code/tasks.c **** 
 740:../Generated_Code/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 741:../Generated_Code/tasks.c **** 
 742:../Generated_Code/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 743:../Generated_Code/tasks.c **** 	{
 744:../Generated_Code/tasks.c **** 	tskTCB *pxTCB;
 745:../Generated_Code/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 746:../Generated_Code/tasks.c **** 
 747:../Generated_Code/tasks.c **** 		taskENTER_CRITICAL();
 748:../Generated_Code/tasks.c **** 		{
 749:../Generated_Code/tasks.c **** 			/* If null is passed in here then we are changing the
 750:../Generated_Code/tasks.c **** 			priority of the calling function. */
 751:../Generated_Code/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 752:../Generated_Code/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 753:../Generated_Code/tasks.c **** 		}
 754:../Generated_Code/tasks.c **** 		taskEXIT_CRITICAL();
 755:../Generated_Code/tasks.c **** 
 756:../Generated_Code/tasks.c **** 		return uxReturn;
 757:../Generated_Code/tasks.c **** 	}
 758:../Generated_Code/tasks.c **** 
 759:../Generated_Code/tasks.c **** #endif
 760:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 761:../Generated_Code/tasks.c **** 
 762:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 763:../Generated_Code/tasks.c **** 
 764:../Generated_Code/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 765:../Generated_Code/tasks.c **** 	{
 766:../Generated_Code/tasks.c **** 	tskTCB *pxTCB;
 767:../Generated_Code/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority;
 768:../Generated_Code/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 769:../Generated_Code/tasks.c **** 
 770:../Generated_Code/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 771:../Generated_Code/tasks.c **** 
 772:../Generated_Code/tasks.c **** 		/* Ensure the new priority is valid. */
 773:../Generated_Code/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 774:../Generated_Code/tasks.c **** 		{
 775:../Generated_Code/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 776:../Generated_Code/tasks.c **** 		}
 777:../Generated_Code/tasks.c **** 
 778:../Generated_Code/tasks.c **** 		taskENTER_CRITICAL();
 779:../Generated_Code/tasks.c **** 		{
 780:../Generated_Code/tasks.c **** 			if( pxTask == pxCurrentTCB )
 781:../Generated_Code/tasks.c **** 			{
 782:../Generated_Code/tasks.c **** 				pxTask = NULL;
 783:../Generated_Code/tasks.c **** 			}
 784:../Generated_Code/tasks.c **** 
 785:../Generated_Code/tasks.c **** 			/* If null is passed in here then we are changing the
 786:../Generated_Code/tasks.c **** 			priority of the calling function. */
 787:../Generated_Code/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 788:../Generated_Code/tasks.c **** 
 789:../Generated_Code/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
 790:../Generated_Code/tasks.c **** 
 791:../Generated_Code/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 792:../Generated_Code/tasks.c **** 			{
 793:../Generated_Code/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 794:../Generated_Code/tasks.c **** 			}
 795:../Generated_Code/tasks.c **** 			#else
 796:../Generated_Code/tasks.c **** 			{
 797:../Generated_Code/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 798:../Generated_Code/tasks.c **** 			}
 799:../Generated_Code/tasks.c **** 			#endif
 800:../Generated_Code/tasks.c **** 
 801:../Generated_Code/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 802:../Generated_Code/tasks.c **** 			{
 803:../Generated_Code/tasks.c **** 				/* The priority change may have readied a task of higher
 804:../Generated_Code/tasks.c **** 				priority than the calling task. */
 805:../Generated_Code/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 806:../Generated_Code/tasks.c **** 				{
 807:../Generated_Code/tasks.c **** 					if( pxTask != NULL )
 808:../Generated_Code/tasks.c **** 					{
 809:../Generated_Code/tasks.c **** 						/* The priority of another task is being raised.  If we
 810:../Generated_Code/tasks.c **** 						were raising the priority of the currently running task
 811:../Generated_Code/tasks.c **** 						there would be no need to switch as it must have already
 812:../Generated_Code/tasks.c **** 						been the highest priority task. */
 813:../Generated_Code/tasks.c **** 						xYieldRequired = pdTRUE;
 814:../Generated_Code/tasks.c **** 					}
 815:../Generated_Code/tasks.c **** 				}
 816:../Generated_Code/tasks.c **** 				else if( pxTask == NULL )
 817:../Generated_Code/tasks.c **** 				{
 818:../Generated_Code/tasks.c **** 					/* Setting our own priority down means there may now be another
 819:../Generated_Code/tasks.c **** 					task of higher priority that is ready to execute. */
 820:../Generated_Code/tasks.c **** 					xYieldRequired = pdTRUE;
 821:../Generated_Code/tasks.c **** 				}
 822:../Generated_Code/tasks.c **** 
 823:../Generated_Code/tasks.c **** 
 824:../Generated_Code/tasks.c **** 
 825:../Generated_Code/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 826:../Generated_Code/tasks.c **** 				{
 827:../Generated_Code/tasks.c **** 					/* Only change the priority being used if the task is not
 828:../Generated_Code/tasks.c **** 					currently using an inherited priority. */
 829:../Generated_Code/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 830:../Generated_Code/tasks.c **** 					{
 831:../Generated_Code/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 832:../Generated_Code/tasks.c **** 					}
 833:../Generated_Code/tasks.c **** 
 834:../Generated_Code/tasks.c **** 					/* The base priority gets set whatever. */
 835:../Generated_Code/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 836:../Generated_Code/tasks.c **** 				}
 837:../Generated_Code/tasks.c **** 				#else
 838:../Generated_Code/tasks.c **** 				{
 839:../Generated_Code/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 840:../Generated_Code/tasks.c **** 				}
 841:../Generated_Code/tasks.c **** 				#endif
 842:../Generated_Code/tasks.c **** 
 843:../Generated_Code/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 844:../Generated_Code/tasks.c **** 
 845:../Generated_Code/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 846:../Generated_Code/tasks.c **** 				nothing more than change it's priority variable. However, if
 847:../Generated_Code/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 848:../Generated_Code/tasks.c **** 				in the queue appropriate to its new priority. */
 849:../Generated_Code/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 850:../Generated_Code/tasks.c **** 				{
 851:../Generated_Code/tasks.c **** 					/* The task is currently in its ready list - remove before adding
 852:../Generated_Code/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
 853:../Generated_Code/tasks.c **** 					can do this even if the scheduler is suspended. */
 854:../Generated_Code/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 855:../Generated_Code/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 856:../Generated_Code/tasks.c **** 				}
 857:../Generated_Code/tasks.c **** 
 858:../Generated_Code/tasks.c **** 				if( xYieldRequired == pdTRUE )
 859:../Generated_Code/tasks.c **** 				{
 860:../Generated_Code/tasks.c **** 					portYIELD_WITHIN_API();
 861:../Generated_Code/tasks.c **** 				}
 862:../Generated_Code/tasks.c **** 			}
 863:../Generated_Code/tasks.c **** 		}
 864:../Generated_Code/tasks.c **** 		taskEXIT_CRITICAL();
 865:../Generated_Code/tasks.c **** 	}
 866:../Generated_Code/tasks.c **** 
 867:../Generated_Code/tasks.c **** #endif
 868:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 869:../Generated_Code/tasks.c **** 
 870:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 871:../Generated_Code/tasks.c **** 
 872:../Generated_Code/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
 873:../Generated_Code/tasks.c **** 	{
 874:../Generated_Code/tasks.c **** 	tskTCB *pxTCB;
 875:../Generated_Code/tasks.c **** 
 876:../Generated_Code/tasks.c **** 		taskENTER_CRITICAL();
 877:../Generated_Code/tasks.c **** 		{
 878:../Generated_Code/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 879:../Generated_Code/tasks.c **** 			suspended. */
 880:../Generated_Code/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 881:../Generated_Code/tasks.c **** 			{
 882:../Generated_Code/tasks.c **** 				pxTaskToSuspend = NULL;
 883:../Generated_Code/tasks.c **** 			}
 884:../Generated_Code/tasks.c **** 
 885:../Generated_Code/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
 886:../Generated_Code/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 887:../Generated_Code/tasks.c **** 
 888:../Generated_Code/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
 889:../Generated_Code/tasks.c **** 
 890:../Generated_Code/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
 891:../Generated_Code/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 892:../Generated_Code/tasks.c **** 
 893:../Generated_Code/tasks.c **** 			/* Is the task waiting on an event also? */
 894:../Generated_Code/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 895:../Generated_Code/tasks.c **** 			{
 896:../Generated_Code/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 897:../Generated_Code/tasks.c **** 			}
 898:../Generated_Code/tasks.c **** 
 899:../Generated_Code/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 900:../Generated_Code/tasks.c **** 		}
 901:../Generated_Code/tasks.c **** 		taskEXIT_CRITICAL();
 902:../Generated_Code/tasks.c **** 
 903:../Generated_Code/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 904:../Generated_Code/tasks.c **** 		{
 905:../Generated_Code/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 906:../Generated_Code/tasks.c **** 			{
 907:../Generated_Code/tasks.c **** 				/* We have just suspended the current task. */
 908:../Generated_Code/tasks.c **** 				portYIELD_WITHIN_API();
 909:../Generated_Code/tasks.c **** 			}
 910:../Generated_Code/tasks.c **** 			else
 911:../Generated_Code/tasks.c **** 			{
 912:../Generated_Code/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
 913:../Generated_Code/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
 914:../Generated_Code/tasks.c **** 				must be adjusted to point to a different task. */
 915:../Generated_Code/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 916:../Generated_Code/tasks.c **** 				{
 917:../Generated_Code/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
 918:../Generated_Code/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
 919:../Generated_Code/tasks.c **** 					be set to point to it no matter what its relative priority
 920:../Generated_Code/tasks.c **** 					is. */
 921:../Generated_Code/tasks.c **** 					pxCurrentTCB = NULL;
 922:../Generated_Code/tasks.c **** 				}
 923:../Generated_Code/tasks.c **** 				else
 924:../Generated_Code/tasks.c **** 				{
 925:../Generated_Code/tasks.c **** 					vTaskSwitchContext();
 926:../Generated_Code/tasks.c **** 				}
 927:../Generated_Code/tasks.c **** 			}
 928:../Generated_Code/tasks.c **** 		}
 929:../Generated_Code/tasks.c **** 	}
 930:../Generated_Code/tasks.c **** 
 931:../Generated_Code/tasks.c **** #endif
 932:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 933:../Generated_Code/tasks.c **** 
 934:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 935:../Generated_Code/tasks.c **** 
 936:../Generated_Code/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
 937:../Generated_Code/tasks.c **** 	{
 938:../Generated_Code/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 939:../Generated_Code/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 940:../Generated_Code/tasks.c **** 
 941:../Generated_Code/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
 942:../Generated_Code/tasks.c **** 		configASSERT( xTask );
 943:../Generated_Code/tasks.c **** 
 944:../Generated_Code/tasks.c **** 		/* Is the task we are attempting to resume actually in the
 945:../Generated_Code/tasks.c **** 		suspended list? */
 946:../Generated_Code/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 947:../Generated_Code/tasks.c **** 		{
 948:../Generated_Code/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
 949:../Generated_Code/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 950:../Generated_Code/tasks.c **** 			{
 951:../Generated_Code/tasks.c **** 				/* Is it in the suspended list because it is in the
 952:../Generated_Code/tasks.c **** 				Suspended state?  It is possible to be in the suspended
 953:../Generated_Code/tasks.c **** 				list because it is blocked on a task with no timeout
 954:../Generated_Code/tasks.c **** 				specified. */
 955:../Generated_Code/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 956:../Generated_Code/tasks.c **** 				{
 957:../Generated_Code/tasks.c **** 					xReturn = pdTRUE;
 958:../Generated_Code/tasks.c **** 				}
 959:../Generated_Code/tasks.c **** 			}
 960:../Generated_Code/tasks.c **** 		}
 961:../Generated_Code/tasks.c **** 
 962:../Generated_Code/tasks.c **** 		return xReturn;
 963:../Generated_Code/tasks.c **** 	}
 964:../Generated_Code/tasks.c **** 
 965:../Generated_Code/tasks.c **** #endif
 966:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
 967:../Generated_Code/tasks.c **** 
 968:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 969:../Generated_Code/tasks.c **** 
 970:../Generated_Code/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
 971:../Generated_Code/tasks.c **** 	{
 972:../Generated_Code/tasks.c **** 	tskTCB *pxTCB;
 973:../Generated_Code/tasks.c **** 
 974:../Generated_Code/tasks.c **** 		/* It does not make sense to resume the calling task. */
 975:../Generated_Code/tasks.c **** 		configASSERT( pxTaskToResume );
 976:../Generated_Code/tasks.c **** 
 977:../Generated_Code/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
 978:../Generated_Code/tasks.c **** 		it in the ready list. */
 979:../Generated_Code/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 980:../Generated_Code/tasks.c **** 
 981:../Generated_Code/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
 982:../Generated_Code/tasks.c **** 		currently executing task. */
 983:../Generated_Code/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 984:../Generated_Code/tasks.c **** 		{
 985:../Generated_Code/tasks.c **** 			taskENTER_CRITICAL();
 986:../Generated_Code/tasks.c **** 			{
 987:../Generated_Code/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 988:../Generated_Code/tasks.c **** 				{
 989:../Generated_Code/tasks.c **** 					traceTASK_RESUME( pxTCB );
 990:../Generated_Code/tasks.c **** 
 991:../Generated_Code/tasks.c **** 					/* As we are in a critical section we can access the ready
 992:../Generated_Code/tasks.c **** 					lists even if the scheduler is suspended. */
 993:../Generated_Code/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 994:../Generated_Code/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 995:../Generated_Code/tasks.c **** 
 996:../Generated_Code/tasks.c **** 					/* We may have just resumed a higher priority task. */
 997:../Generated_Code/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 998:../Generated_Code/tasks.c **** 					{
 999:../Generated_Code/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
1000:../Generated_Code/tasks.c **** 						will leave the lists in the correct state for the next yield. */
1001:../Generated_Code/tasks.c **** 						portYIELD_WITHIN_API();
1002:../Generated_Code/tasks.c **** 					}
1003:../Generated_Code/tasks.c **** 				}
1004:../Generated_Code/tasks.c **** 			}
1005:../Generated_Code/tasks.c **** 			taskEXIT_CRITICAL();
1006:../Generated_Code/tasks.c **** 		}
1007:../Generated_Code/tasks.c **** 	}
1008:../Generated_Code/tasks.c **** 
1009:../Generated_Code/tasks.c **** #endif
1010:../Generated_Code/tasks.c **** 
1011:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1012:../Generated_Code/tasks.c **** 
1013:../Generated_Code/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1014:../Generated_Code/tasks.c **** 
1015:../Generated_Code/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
1016:../Generated_Code/tasks.c **** 	{
1017:../Generated_Code/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
1018:../Generated_Code/tasks.c **** 	tskTCB *pxTCB;
1019:../Generated_Code/tasks.c **** 	unsigned portBASE_TYPE uxSavedInterruptStatus;
1020:../Generated_Code/tasks.c **** 
1021:../Generated_Code/tasks.c **** 		configASSERT( pxTaskToResume );
1022:../Generated_Code/tasks.c **** 
1023:../Generated_Code/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
1024:../Generated_Code/tasks.c **** 
1025:../Generated_Code/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1026:../Generated_Code/tasks.c **** 		{
1027:../Generated_Code/tasks.c **** 			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
1028:../Generated_Code/tasks.c **** 			{
1029:../Generated_Code/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1030:../Generated_Code/tasks.c **** 
1031:../Generated_Code/tasks.c **** 				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1032:../Generated_Code/tasks.c **** 				{
1033:../Generated_Code/tasks.c **** 					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
1034:../Generated_Code/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
1035:../Generated_Code/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
1036:../Generated_Code/tasks.c **** 				}
1037:../Generated_Code/tasks.c **** 				else
1038:../Generated_Code/tasks.c **** 				{
1039:../Generated_Code/tasks.c **** 					/* We cannot access the delayed or ready lists, so will hold this
1040:../Generated_Code/tasks.c **** 					task pending until the scheduler is resumed, at which point a
1041:../Generated_Code/tasks.c **** 					yield will be performed if necessary. */
1042:../Generated_Code/tasks.c **** 					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1043:../Generated_Code/tasks.c **** 				}
1044:../Generated_Code/tasks.c **** 			}
1045:../Generated_Code/tasks.c **** 		}
1046:../Generated_Code/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1047:../Generated_Code/tasks.c **** 
1048:../Generated_Code/tasks.c **** 		return xYieldRequired;
1049:../Generated_Code/tasks.c **** 	}
1050:../Generated_Code/tasks.c **** 
1051:../Generated_Code/tasks.c **** #endif
1052:../Generated_Code/tasks.c **** 
1053:../Generated_Code/tasks.c **** 
1054:../Generated_Code/tasks.c **** 
1055:../Generated_Code/tasks.c **** 
1056:../Generated_Code/tasks.c **** /*-----------------------------------------------------------
1057:../Generated_Code/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1058:../Generated_Code/tasks.c ****  *----------------------------------------------------------*/
1059:../Generated_Code/tasks.c **** 
1060:../Generated_Code/tasks.c **** 
1061:../Generated_Code/tasks.c **** void vTaskStartScheduler( void )
1062:../Generated_Code/tasks.c **** {
1063:../Generated_Code/tasks.c **** portBASE_TYPE xReturn;
1064:../Generated_Code/tasks.c **** 
1065:../Generated_Code/tasks.c **** 	/* Add the idle task at the lowest priority. */
1066:../Generated_Code/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1067:../Generated_Code/tasks.c **** 	{
1068:../Generated_Code/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1069:../Generated_Code/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1070:../Generated_Code/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1071:../Generated_Code/tasks.c **** 	}
1072:../Generated_Code/tasks.c **** 	#else
1073:../Generated_Code/tasks.c **** 	{
1074:../Generated_Code/tasks.c **** 		/* Create the idle task without storing its handle. */
1075:../Generated_Code/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1076:../Generated_Code/tasks.c **** 	}
1077:../Generated_Code/tasks.c **** 	#endif
1078:../Generated_Code/tasks.c **** 
1079:../Generated_Code/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1080:../Generated_Code/tasks.c **** 	{
1081:../Generated_Code/tasks.c **** 		if( xReturn == pdPASS )
1082:../Generated_Code/tasks.c **** 		{
1083:../Generated_Code/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1084:../Generated_Code/tasks.c **** 		}
1085:../Generated_Code/tasks.c **** 	}
1086:../Generated_Code/tasks.c **** 	#endif
1087:../Generated_Code/tasks.c **** 
1088:../Generated_Code/tasks.c **** 	if( xReturn == pdPASS )
1089:../Generated_Code/tasks.c **** 	{
1090:../Generated_Code/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1091:../Generated_Code/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1092:../Generated_Code/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1093:../Generated_Code/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1094:../Generated_Code/tasks.c **** 		starts to run.
1095:../Generated_Code/tasks.c **** 
1096:../Generated_Code/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1097:../Generated_Code/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1098:../Generated_Code/tasks.c **** 		portDISABLE_INTERRUPTS();
1099:../Generated_Code/tasks.c **** 
1100:../Generated_Code/tasks.c **** 		xSchedulerRunning = pdTRUE;
1101:../Generated_Code/tasks.c **** 		xTickCount = ( portTickType ) 0U;
1102:../Generated_Code/tasks.c **** 
1103:../Generated_Code/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1104:../Generated_Code/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1105:../Generated_Code/tasks.c **** 		the run time counter time base. */
1106:../Generated_Code/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1107:../Generated_Code/tasks.c **** 		
1108:../Generated_Code/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1109:../Generated_Code/tasks.c **** 		portable interface. */
1110:../Generated_Code/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
1111:../Generated_Code/tasks.c **** 		{
1112:../Generated_Code/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1113:../Generated_Code/tasks.c **** 			function will not return. */
1114:../Generated_Code/tasks.c **** 		}
1115:../Generated_Code/tasks.c **** 		else
1116:../Generated_Code/tasks.c **** 		{
1117:../Generated_Code/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1118:../Generated_Code/tasks.c **** 		}
1119:../Generated_Code/tasks.c **** 	}
1120:../Generated_Code/tasks.c **** 
1121:../Generated_Code/tasks.c **** 	/* This line will only be reached if the kernel could not be started. */
1122:../Generated_Code/tasks.c **** 	configASSERT( xReturn );
1123:../Generated_Code/tasks.c **** }
1124:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1125:../Generated_Code/tasks.c **** 
1126:../Generated_Code/tasks.c **** void vTaskSuspendAll( void )
1127:../Generated_Code/tasks.c **** {
1128:../Generated_Code/tasks.c **** 	/* A critical section is not required as the variable is of type
1129:../Generated_Code/tasks.c **** 	portBASE_TYPE. */
1130:../Generated_Code/tasks.c **** 	++uxSchedulerSuspended;
1131:../Generated_Code/tasks.c **** }
1132:../Generated_Code/tasks.c **** /*----------------------------------------------------------*/
1133:../Generated_Code/tasks.c **** 
1134:../Generated_Code/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1135:../Generated_Code/tasks.c **** {
1136:../Generated_Code/tasks.c **** register tskTCB *pxTCB;
1137:../Generated_Code/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
1138:../Generated_Code/tasks.c **** 
1139:../Generated_Code/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1140:../Generated_Code/tasks.c **** 	previous call to vTaskSuspendAll(). */
1141:../Generated_Code/tasks.c **** 	configASSERT( uxSchedulerSuspended );
1142:../Generated_Code/tasks.c **** 
1143:../Generated_Code/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1144:../Generated_Code/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1145:../Generated_Code/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1146:../Generated_Code/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1147:../Generated_Code/tasks.c **** 	tasks from this list into their appropriate ready list. */
1148:../Generated_Code/tasks.c **** 	taskENTER_CRITICAL();
1149:../Generated_Code/tasks.c **** 	{
1150:../Generated_Code/tasks.c **** 		--uxSchedulerSuspended;
1151:../Generated_Code/tasks.c **** 
1152:../Generated_Code/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1153:../Generated_Code/tasks.c **** 		{
1154:../Generated_Code/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
1155:../Generated_Code/tasks.c **** 			{
1156:../Generated_Code/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
1157:../Generated_Code/tasks.c **** 
1158:../Generated_Code/tasks.c **** 				/* Move any readied tasks from the pending list into the
1159:../Generated_Code/tasks.c **** 				appropriate ready list. */
1160:../Generated_Code/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
1161:../Generated_Code/tasks.c **** 				{
1162:../Generated_Code/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
1163:../Generated_Code/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
1164:../Generated_Code/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
1165:../Generated_Code/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
1166:../Generated_Code/tasks.c **** 
1167:../Generated_Code/tasks.c **** 					/* If we have moved a task that has a priority higher than
1168:../Generated_Code/tasks.c **** 					the current task then we should yield. */
1169:../Generated_Code/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1170:../Generated_Code/tasks.c **** 					{
1171:../Generated_Code/tasks.c **** 						xYieldRequired = pdTRUE;
1172:../Generated_Code/tasks.c **** 					}
1173:../Generated_Code/tasks.c **** 				}
1174:../Generated_Code/tasks.c **** 
1175:../Generated_Code/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1176:../Generated_Code/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1177:../Generated_Code/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1178:../Generated_Code/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
1179:../Generated_Code/tasks.c **** 				{
1180:../Generated_Code/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
1181:../Generated_Code/tasks.c **** 					{
1182:../Generated_Code/tasks.c **** 						vTaskIncrementTick();
1183:../Generated_Code/tasks.c **** 						--uxMissedTicks;
1184:../Generated_Code/tasks.c **** 					}
1185:../Generated_Code/tasks.c **** 
1186:../Generated_Code/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1187:../Generated_Code/tasks.c **** 					to ensure the highest priority task that is ready to run is
1188:../Generated_Code/tasks.c **** 					the task actually running. */
1189:../Generated_Code/tasks.c **** 					#if configUSE_PREEMPTION == 1
1190:../Generated_Code/tasks.c **** 					{
1191:../Generated_Code/tasks.c **** 						xYieldRequired = pdTRUE;
1192:../Generated_Code/tasks.c **** 					}
1193:../Generated_Code/tasks.c **** 					#endif
1194:../Generated_Code/tasks.c **** 				}
1195:../Generated_Code/tasks.c **** 
1196:../Generated_Code/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
1197:../Generated_Code/tasks.c **** 				{
1198:../Generated_Code/tasks.c **** 					xAlreadyYielded = pdTRUE;
1199:../Generated_Code/tasks.c **** 					xMissedYield = pdFALSE;
1200:../Generated_Code/tasks.c **** 					portYIELD_WITHIN_API();
1201:../Generated_Code/tasks.c **** 				}
1202:../Generated_Code/tasks.c **** 			}
1203:../Generated_Code/tasks.c **** 		}
1204:../Generated_Code/tasks.c **** 	}
1205:../Generated_Code/tasks.c **** 	taskEXIT_CRITICAL();
1206:../Generated_Code/tasks.c **** 
1207:../Generated_Code/tasks.c **** 	return xAlreadyYielded;
1208:../Generated_Code/tasks.c **** }
1209:../Generated_Code/tasks.c **** 
1210:../Generated_Code/tasks.c **** 
1211:../Generated_Code/tasks.c **** 
1212:../Generated_Code/tasks.c **** 
1213:../Generated_Code/tasks.c **** 
1214:../Generated_Code/tasks.c **** 
1215:../Generated_Code/tasks.c **** /*-----------------------------------------------------------
1216:../Generated_Code/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1217:../Generated_Code/tasks.c ****  *----------------------------------------------------------*/
1218:../Generated_Code/tasks.c **** 
1219:../Generated_Code/tasks.c **** 
1220:../Generated_Code/tasks.c **** 
1221:../Generated_Code/tasks.c **** portTickType xTaskGetTickCount( void )
1222:../Generated_Code/tasks.c **** {
1223:../Generated_Code/tasks.c **** portTickType xTicks;
1224:../Generated_Code/tasks.c **** 
1225:../Generated_Code/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1226:../Generated_Code/tasks.c **** 	taskENTER_CRITICAL();
1227:../Generated_Code/tasks.c **** 	{
1228:../Generated_Code/tasks.c **** 		xTicks = xTickCount;
1229:../Generated_Code/tasks.c **** 	}
1230:../Generated_Code/tasks.c **** 	taskEXIT_CRITICAL();
1231:../Generated_Code/tasks.c **** 
1232:../Generated_Code/tasks.c **** 	return xTicks;
1233:../Generated_Code/tasks.c **** }
1234:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1235:../Generated_Code/tasks.c **** 
1236:../Generated_Code/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1237:../Generated_Code/tasks.c **** {
1238:../Generated_Code/tasks.c **** portTickType xReturn;
1239:../Generated_Code/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1240:../Generated_Code/tasks.c **** 
1241:../Generated_Code/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1242:../Generated_Code/tasks.c **** 	xReturn = xTickCount;
1243:../Generated_Code/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1244:../Generated_Code/tasks.c **** 
1245:../Generated_Code/tasks.c **** 	return xReturn;
1246:../Generated_Code/tasks.c **** }
1247:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1248:../Generated_Code/tasks.c **** 
1249:../Generated_Code/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1250:../Generated_Code/tasks.c **** {
1251:../Generated_Code/tasks.c **** 	/* A critical section is not required because the variables are of type
1252:../Generated_Code/tasks.c **** 	portBASE_TYPE. */
1253:../Generated_Code/tasks.c **** 	return uxCurrentNumberOfTasks;
1254:../Generated_Code/tasks.c **** }
1255:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1256:../Generated_Code/tasks.c **** 
1257:../Generated_Code/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1258:../Generated_Code/tasks.c **** 
1259:../Generated_Code/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1260:../Generated_Code/tasks.c **** 	{
1261:../Generated_Code/tasks.c **** 	tskTCB *pxTCB;
1262:../Generated_Code/tasks.c **** 
1263:../Generated_Code/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1264:../Generated_Code/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1265:../Generated_Code/tasks.c **** 		configASSERT( pxTCB );
1266:../Generated_Code/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1267:../Generated_Code/tasks.c **** 	}
1268:../Generated_Code/tasks.c **** 
1269:../Generated_Code/tasks.c **** #endif
1270:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1271:../Generated_Code/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1272:../Generated_Code/tasks.c **** 
1273:../Generated_Code/tasks.c **** 	void vTaskList(unsigned char *pcWriteBuffer, size_t bufSize)
1274:../Generated_Code/tasks.c **** 	{
1275:../Generated_Code/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1276:../Generated_Code/tasks.c **** 
1277:../Generated_Code/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1278:../Generated_Code/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1279:../Generated_Code/tasks.c **** 
1280:../Generated_Code/tasks.c **** 		vTaskSuspendAll();
1281:../Generated_Code/tasks.c **** 		{
1282:../Generated_Code/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1283:../Generated_Code/tasks.c **** 			report the task name, state and stack high water mark. */
1284:../Generated_Code/tasks.c **** 
1285:../Generated_Code/tasks.c **** 		  UTIL1_strcpy(pcWriteBuffer, bufSize, (const unsigned char *) "\r\n" );
1286:../Generated_Code/tasks.c **** 
1287:../Generated_Code/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1288:../Generated_Code/tasks.c **** 
1289:../Generated_Code/tasks.c **** 			do
1290:../Generated_Code/tasks.c **** 			{
1291:../Generated_Code/tasks.c **** 				uxQueue--;
1292:../Generated_Code/tasks.c **** 
1293:../Generated_Code/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1294:../Generated_Code/tasks.c **** 				{
1295:../Generated_Code/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, bufSize, ( xList * ) &( pxReadyTasksLists[ uxQueue
1296:../Generated_Code/tasks.c **** 				}
1297:../Generated_Code/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1298:../Generated_Code/tasks.c **** 
1299:../Generated_Code/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1300:../Generated_Code/tasks.c **** 			{
1301:../Generated_Code/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, bufSize, ( xList * ) pxDelayedTaskList, tskBLOCKED_
1302:../Generated_Code/tasks.c **** 			}
1303:../Generated_Code/tasks.c **** 
1304:../Generated_Code/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1305:../Generated_Code/tasks.c **** 			{
1306:../Generated_Code/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, bufSize, ( xList * ) pxOverflowDelayedTaskList, tsk
1307:../Generated_Code/tasks.c **** 			}
1308:../Generated_Code/tasks.c **** 
1309:../Generated_Code/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1310:../Generated_Code/tasks.c **** 			{
1311:../Generated_Code/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1312:../Generated_Code/tasks.c **** 				{
1313:../Generated_Code/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, bufSize, &xTasksWaitingTermination, tskDELETED_CHA
1314:../Generated_Code/tasks.c **** 				}
1315:../Generated_Code/tasks.c **** 			}
1316:../Generated_Code/tasks.c **** 			#endif
1317:../Generated_Code/tasks.c **** 
1318:../Generated_Code/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1319:../Generated_Code/tasks.c **** 			{
1320:../Generated_Code/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1321:../Generated_Code/tasks.c **** 				{
1322:../Generated_Code/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, bufSize, &xSuspendedTaskList, tskSUSPENDED_CHAR );
1323:../Generated_Code/tasks.c **** 				}
1324:../Generated_Code/tasks.c **** 			}
1325:../Generated_Code/tasks.c **** 			#endif
1326:../Generated_Code/tasks.c **** 		}
1327:../Generated_Code/tasks.c **** 		(void)xTaskResumeAll();
1328:../Generated_Code/tasks.c **** 	}
1329:../Generated_Code/tasks.c **** 
1330:../Generated_Code/tasks.c **** #endif
1331:../Generated_Code/tasks.c **** /*----------------------------------------------------------*/
1332:../Generated_Code/tasks.c **** 
1333:../Generated_Code/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1334:../Generated_Code/tasks.c **** 
1335:../Generated_Code/tasks.c ****   void vTaskGetRunTimeStats(unsigned char *pcWriteBuffer, size_t bufSize)
1336:../Generated_Code/tasks.c **** 	{
1337:../Generated_Code/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1338:../Generated_Code/tasks.c **** 	unsigned long ulTotalRunTime;
1339:../Generated_Code/tasks.c **** 
1340:../Generated_Code/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1341:../Generated_Code/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1342:../Generated_Code/tasks.c **** 
1343:../Generated_Code/tasks.c **** 		vTaskSuspendAll();
1344:../Generated_Code/tasks.c **** 		{
1345:../Generated_Code/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1346:../Generated_Code/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1347:../Generated_Code/tasks.c **** 			#else
1348:../Generated_Code/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1349:../Generated_Code/tasks.c **** 			#endif
1350:../Generated_Code/tasks.c **** 
1351:../Generated_Code/tasks.c **** 			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
1352:../Generated_Code/tasks.c **** 			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
1353:../Generated_Code/tasks.c **** 			ulTotalRunTime /= 100UL;
1354:../Generated_Code/tasks.c **** 			
1355:../Generated_Code/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1356:../Generated_Code/tasks.c **** 			generating a table of run timer percentages in the provided
1357:../Generated_Code/tasks.c **** 			buffer. */
1358:../Generated_Code/tasks.c **** 
1359:../Generated_Code/tasks.c ****       UTIL1_strcpy(pcWriteBuffer, bufSize, (const unsigned char*)"\r\n");
1360:../Generated_Code/tasks.c **** 
1361:../Generated_Code/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1362:../Generated_Code/tasks.c **** 
1363:../Generated_Code/tasks.c **** 			do
1364:../Generated_Code/tasks.c **** 			{
1365:../Generated_Code/tasks.c **** 				uxQueue--;
1366:../Generated_Code/tasks.c **** 
1367:../Generated_Code/tasks.c ****         if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1368:../Generated_Code/tasks.c ****         {
1369:../Generated_Code/tasks.c ****           prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, bufSize, ( xList * ) &( pxReadyTask
1370:../Generated_Code/tasks.c ****         }
1371:../Generated_Code/tasks.c ****       }while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1372:../Generated_Code/tasks.c **** 
1373:../Generated_Code/tasks.c ****       if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1374:../Generated_Code/tasks.c ****       {
1375:../Generated_Code/tasks.c ****         prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, bufSize, ( xList * ) pxDelayedTaskLis
1376:../Generated_Code/tasks.c ****       }
1377:../Generated_Code/tasks.c **** 
1378:../Generated_Code/tasks.c ****       if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1379:../Generated_Code/tasks.c ****       {
1380:../Generated_Code/tasks.c ****         prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, bufSize, ( xList * ) pxOverflowDelaye
1381:../Generated_Code/tasks.c ****       }
1382:../Generated_Code/tasks.c **** 
1383:../Generated_Code/tasks.c ****       #if ( INCLUDE_vTaskDelete == 1 )
1384:../Generated_Code/tasks.c ****       {
1385:../Generated_Code/tasks.c ****         if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1386:../Generated_Code/tasks.c ****         {
1387:../Generated_Code/tasks.c ****           prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, bufSize, &xTasksWaitingTermination,
1388:../Generated_Code/tasks.c ****         }
1389:../Generated_Code/tasks.c ****       }
1390:../Generated_Code/tasks.c ****       #endif
1391:../Generated_Code/tasks.c **** 
1392:../Generated_Code/tasks.c ****       #if ( INCLUDE_vTaskSuspend == 1 )
1393:../Generated_Code/tasks.c ****       {
1394:../Generated_Code/tasks.c ****         if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1395:../Generated_Code/tasks.c ****         {
1396:../Generated_Code/tasks.c ****           prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, bufSize, &xSuspendedTaskList, ulTot
1397:../Generated_Code/tasks.c ****         }
1398:../Generated_Code/tasks.c ****       }
1399:../Generated_Code/tasks.c ****       #endif
1400:../Generated_Code/tasks.c ****     }
1401:../Generated_Code/tasks.c ****     (void)xTaskResumeAll();
1402:../Generated_Code/tasks.c ****   }
1403:../Generated_Code/tasks.c **** 
1404:../Generated_Code/tasks.c **** #endif
1405:../Generated_Code/tasks.c **** /*----------------------------------------------------------*/
1406:../Generated_Code/tasks.c **** 
1407:../Generated_Code/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1408:../Generated_Code/tasks.c **** 
1409:../Generated_Code/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1410:../Generated_Code/tasks.c **** 	{
1411:../Generated_Code/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1412:../Generated_Code/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1413:../Generated_Code/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1414:../Generated_Code/tasks.c **** 		return xIdleTaskHandle;
1415:../Generated_Code/tasks.c **** 	}
1416:../Generated_Code/tasks.c **** 	
1417:../Generated_Code/tasks.c **** #endif
1418:../Generated_Code/tasks.c **** 
1419:../Generated_Code/tasks.c **** /*-----------------------------------------------------------
1420:../Generated_Code/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1421:../Generated_Code/tasks.c ****  * documented in task.h
1422:../Generated_Code/tasks.c ****  *----------------------------------------------------------*/
1423:../Generated_Code/tasks.c **** 
1424:../Generated_Code/tasks.c **** void vTaskIncrementTick( void )
1425:../Generated_Code/tasks.c **** {
1426:../Generated_Code/tasks.c **** tskTCB * pxTCB;
1427:../Generated_Code/tasks.c **** 
1428:../Generated_Code/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1429:../Generated_Code/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1430:../Generated_Code/tasks.c **** 	tasks to be unblocked. */
1431:../Generated_Code/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1432:../Generated_Code/tasks.c **** 	{
1433:../Generated_Code/tasks.c **** 		++xTickCount;
1434:../Generated_Code/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
1435:../Generated_Code/tasks.c **** 		{
1436:../Generated_Code/tasks.c **** 			xList *pxTemp;
1437:../Generated_Code/tasks.c **** 
1438:../Generated_Code/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1439:../Generated_Code/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1440:../Generated_Code/tasks.c **** 			an error! */
1441:../Generated_Code/tasks.c **** 			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
1442:../Generated_Code/tasks.c **** 			
1443:../Generated_Code/tasks.c **** 			pxTemp = pxDelayedTaskList;
1444:../Generated_Code/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
1445:../Generated_Code/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
1446:../Generated_Code/tasks.c **** 			xNumOfOverflows++;
1447:../Generated_Code/tasks.c **** 	
1448:../Generated_Code/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
1449:../Generated_Code/tasks.c **** 			{
1450:../Generated_Code/tasks.c **** 				/* The new current delayed list is empty.  Set
1451:../Generated_Code/tasks.c **** 				xNextTaskUnblockTime to the maximum possible value so it is
1452:../Generated_Code/tasks.c **** 				extremely unlikely that the	
1453:../Generated_Code/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
1454:../Generated_Code/tasks.c **** 				there is an item in the delayed list. */
1455:../Generated_Code/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;
1456:../Generated_Code/tasks.c **** 			}
1457:../Generated_Code/tasks.c **** 			else
1458:../Generated_Code/tasks.c **** 			{
1459:../Generated_Code/tasks.c **** 				/* The new current delayed list is not empty, get the value of
1460:../Generated_Code/tasks.c **** 				the item at the head of the delayed list.  This is the time at
1461:../Generated_Code/tasks.c **** 				which the task at the head of the delayed list should be removed
1462:../Generated_Code/tasks.c **** 				from the Blocked state. */
1463:../Generated_Code/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
1464:../Generated_Code/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
1465:../Generated_Code/tasks.c **** 			}
1466:../Generated_Code/tasks.c **** 		}
1467:../Generated_Code/tasks.c **** 
1468:../Generated_Code/tasks.c **** 		/* See if this tick has made a timeout expire. */
1469:../Generated_Code/tasks.c **** 		prvCheckDelayedTasks();
1470:../Generated_Code/tasks.c **** 	}
1471:../Generated_Code/tasks.c **** 	else
1472:../Generated_Code/tasks.c **** 	{
1473:../Generated_Code/tasks.c **** 		++uxMissedTicks;
1474:../Generated_Code/tasks.c **** 
1475:../Generated_Code/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1476:../Generated_Code/tasks.c **** 		scheduler is locked. */
1477:../Generated_Code/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1478:../Generated_Code/tasks.c **** 		{
1479:../Generated_Code/tasks.c ****       FRTOS1_vApplicationTickHook();
1480:../Generated_Code/tasks.c **** 		}
1481:../Generated_Code/tasks.c **** 		#endif
1482:../Generated_Code/tasks.c **** 	}
1483:../Generated_Code/tasks.c **** 
1484:../Generated_Code/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1485:../Generated_Code/tasks.c **** 	{
1486:../Generated_Code/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1487:../Generated_Code/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1488:../Generated_Code/tasks.c **** 		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
1489:../Generated_Code/tasks.c **** 		{
1490:../Generated_Code/tasks.c **** 
1491:../Generated_Code/tasks.c ****         FRTOS1_vApplicationTickHook();
1492:../Generated_Code/tasks.c **** 		}
1493:../Generated_Code/tasks.c **** 	}
1494:../Generated_Code/tasks.c **** 	#endif
1495:../Generated_Code/tasks.c **** 
1496:../Generated_Code/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1497:../Generated_Code/tasks.c **** }
1498:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1499:../Generated_Code/tasks.c **** 
1500:../Generated_Code/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1501:../Generated_Code/tasks.c **** 
1502:../Generated_Code/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1503:../Generated_Code/tasks.c **** 	{
1504:../Generated_Code/tasks.c **** 	tskTCB *xTCB;
1505:../Generated_Code/tasks.c **** 
1506:../Generated_Code/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1507:../Generated_Code/tasks.c **** 		if( xTask == NULL )
1508:../Generated_Code/tasks.c **** 		{
1509:../Generated_Code/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1510:../Generated_Code/tasks.c **** 		}
1511:../Generated_Code/tasks.c **** 		else
1512:../Generated_Code/tasks.c **** 		{
1513:../Generated_Code/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1514:../Generated_Code/tasks.c **** 		}
1515:../Generated_Code/tasks.c **** 
1516:../Generated_Code/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1517:../Generated_Code/tasks.c **** 		the value can be accessed from an interrupt. */
1518:../Generated_Code/tasks.c **** 		taskENTER_CRITICAL();
1519:../Generated_Code/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
1520:../Generated_Code/tasks.c **** 		taskEXIT_CRITICAL();
1521:../Generated_Code/tasks.c **** 	}
1522:../Generated_Code/tasks.c **** 
1523:../Generated_Code/tasks.c **** #endif
1524:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1525:../Generated_Code/tasks.c **** 
1526:../Generated_Code/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1527:../Generated_Code/tasks.c **** 
1528:../Generated_Code/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1529:../Generated_Code/tasks.c **** 	{
1530:../Generated_Code/tasks.c **** 	tskTCB *xTCB;
1531:../Generated_Code/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1532:../Generated_Code/tasks.c **** 
1533:../Generated_Code/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1534:../Generated_Code/tasks.c **** 		if( xTask == NULL )
1535:../Generated_Code/tasks.c **** 		{
1536:../Generated_Code/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1537:../Generated_Code/tasks.c **** 		}
1538:../Generated_Code/tasks.c **** 		else
1539:../Generated_Code/tasks.c **** 		{
1540:../Generated_Code/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1541:../Generated_Code/tasks.c **** 		}
1542:../Generated_Code/tasks.c **** 
1543:../Generated_Code/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1544:../Generated_Code/tasks.c **** 		the value can be accessed from an interrupt. */
1545:../Generated_Code/tasks.c **** 		taskENTER_CRITICAL();
1546:../Generated_Code/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1547:../Generated_Code/tasks.c **** 		taskEXIT_CRITICAL();
1548:../Generated_Code/tasks.c **** 
1549:../Generated_Code/tasks.c **** 		return xReturn;
1550:../Generated_Code/tasks.c **** 	}
1551:../Generated_Code/tasks.c **** 
1552:../Generated_Code/tasks.c **** #endif
1553:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1554:../Generated_Code/tasks.c **** 
1555:../Generated_Code/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1556:../Generated_Code/tasks.c **** 
1557:../Generated_Code/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1558:../Generated_Code/tasks.c **** 	{
1559:../Generated_Code/tasks.c **** 	tskTCB *xTCB;
1560:../Generated_Code/tasks.c **** 	portBASE_TYPE xReturn;
1561:../Generated_Code/tasks.c **** 
1562:../Generated_Code/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1563:../Generated_Code/tasks.c **** 		if( xTask == NULL )
1564:../Generated_Code/tasks.c **** 		{
1565:../Generated_Code/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1566:../Generated_Code/tasks.c **** 		}
1567:../Generated_Code/tasks.c **** 		else
1568:../Generated_Code/tasks.c **** 		{
1569:../Generated_Code/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1570:../Generated_Code/tasks.c **** 		}
1571:../Generated_Code/tasks.c **** 
1572:../Generated_Code/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1573:../Generated_Code/tasks.c **** 		{
1574:../Generated_Code/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1575:../Generated_Code/tasks.c **** 		}
1576:../Generated_Code/tasks.c **** 		else
1577:../Generated_Code/tasks.c **** 		{
1578:../Generated_Code/tasks.c **** 			xReturn = pdFAIL;
1579:../Generated_Code/tasks.c **** 		}
1580:../Generated_Code/tasks.c **** 
1581:../Generated_Code/tasks.c **** 		return xReturn;
1582:../Generated_Code/tasks.c **** 	}
1583:../Generated_Code/tasks.c **** 
1584:../Generated_Code/tasks.c **** #endif
1585:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1586:../Generated_Code/tasks.c **** 
1587:../Generated_Code/tasks.c **** void vTaskSwitchContext( void )
1588:../Generated_Code/tasks.c **** {
1589:../Generated_Code/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
1590:../Generated_Code/tasks.c **** 	{
1591:../Generated_Code/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1592:../Generated_Code/tasks.c **** 		switch. */
1593:../Generated_Code/tasks.c **** 		xMissedYield = pdTRUE;
1594:../Generated_Code/tasks.c **** 	}
1595:../Generated_Code/tasks.c **** 	else
1596:../Generated_Code/tasks.c **** 	{
1597:../Generated_Code/tasks.c **** 		traceTASK_SWITCHED_OUT();
1598:../Generated_Code/tasks.c **** 	
1599:../Generated_Code/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1600:../Generated_Code/tasks.c **** 		{
1601:../Generated_Code/tasks.c **** 			unsigned long ulTempCounter;
1602:../Generated_Code/tasks.c **** 			
1603:../Generated_Code/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1604:../Generated_Code/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
1605:../Generated_Code/tasks.c **** 				#else
1606:../Generated_Code/tasks.c **** 					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
1607:../Generated_Code/tasks.c **** 				#endif
1608:../Generated_Code/tasks.c **** 	
1609:../Generated_Code/tasks.c **** 				/* Add the amount of time the task has been running to the accumulated
1610:../Generated_Code/tasks.c **** 				time so far.  The time the task started running was stored in
1611:../Generated_Code/tasks.c **** 				ulTaskSwitchedInTime.  Note that there is no overflow protection here
1612:../Generated_Code/tasks.c **** 				so count values are only valid until the timer overflows.  Generally
1613:../Generated_Code/tasks.c **** 				this will be about 1 hour assuming a 1uS timer increment. */
1614:../Generated_Code/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
1615:../Generated_Code/tasks.c **** 				ulTaskSwitchedInTime = ulTempCounter;
1616:../Generated_Code/tasks.c **** 		}
1617:../Generated_Code/tasks.c **** 		#endif
1618:../Generated_Code/tasks.c **** 	
1619:../Generated_Code/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1620:../Generated_Code/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1621:../Generated_Code/tasks.c **** 	
1622:../Generated_Code/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */
1623:../Generated_Code/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
1624:../Generated_Code/tasks.c **** 		{
1625:../Generated_Code/tasks.c **** 			configASSERT( uxTopReadyPriority );
1626:../Generated_Code/tasks.c **** 			--uxTopReadyPriority;
1627:../Generated_Code/tasks.c **** 		}
1628:../Generated_Code/tasks.c **** 	
1629:../Generated_Code/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1630:../Generated_Code/tasks.c **** 		same priority get an equal share of the processor time. */
1631:../Generated_Code/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
1632:../Generated_Code/tasks.c **** 	
1633:../Generated_Code/tasks.c **** 		traceTASK_SWITCHED_IN();
1634:../Generated_Code/tasks.c **** 	}
1635:../Generated_Code/tasks.c **** }
1636:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1637:../Generated_Code/tasks.c **** 
1638:../Generated_Code/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1639:../Generated_Code/tasks.c **** {
1640:../Generated_Code/tasks.c **** portTickType xTimeToWake;
1641:../Generated_Code/tasks.c **** 
1642:../Generated_Code/tasks.c **** 	configASSERT( pxEventList );
1643:../Generated_Code/tasks.c **** 
1644:../Generated_Code/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1645:../Generated_Code/tasks.c **** 	SCHEDULER SUSPENDED. */
1646:../Generated_Code/tasks.c **** 
1647:../Generated_Code/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1648:../Generated_Code/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1649:../Generated_Code/tasks.c **** 	is the first to be woken by the event. */
1650:../Generated_Code/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1651:../Generated_Code/tasks.c **** 
1652:../Generated_Code/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1653:../Generated_Code/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1654:../Generated_Code/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1655:../Generated_Code/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
1656:../Generated_Code/tasks.c **** 
1657:../Generated_Code/tasks.c **** 
1658:../Generated_Code/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1659:../Generated_Code/tasks.c **** 	{
1660:../Generated_Code/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
1661:../Generated_Code/tasks.c **** 		{
1662:../Generated_Code/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1663:../Generated_Code/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1664:../Generated_Code/tasks.c **** 			indefinitely. */
1665:../Generated_Code/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
1666:../Generated_Code/tasks.c **** 		}
1667:../Generated_Code/tasks.c **** 		else
1668:../Generated_Code/tasks.c **** 		{
1669:../Generated_Code/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1670:../Generated_Code/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1671:../Generated_Code/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1672:../Generated_Code/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1673:../Generated_Code/tasks.c **** 		}
1674:../Generated_Code/tasks.c **** 	}
1675:../Generated_Code/tasks.c **** 	#else
1676:../Generated_Code/tasks.c **** 	{
1677:../Generated_Code/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1678:../Generated_Code/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1679:../Generated_Code/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1680:../Generated_Code/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1681:../Generated_Code/tasks.c **** 	}
1682:../Generated_Code/tasks.c **** 	#endif
1683:../Generated_Code/tasks.c **** }
1684:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1685:../Generated_Code/tasks.c **** 
1686:../Generated_Code/tasks.c **** #if configUSE_TIMERS == 1
1687:../Generated_Code/tasks.c **** 
1688:../Generated_Code/tasks.c **** 	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
1689:../Generated_Code/tasks.c **** 	{
1690:../Generated_Code/tasks.c **** 	portTickType xTimeToWake;
1691:../Generated_Code/tasks.c **** 
1692:../Generated_Code/tasks.c **** 		configASSERT( pxEventList );
1693:../Generated_Code/tasks.c **** 
1694:../Generated_Code/tasks.c **** 		/* This function should not be called by application code hence the
1695:../Generated_Code/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1696:../Generated_Code/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1697:../Generated_Code/tasks.c **** 		it should be called from a critical section. */
1698:../Generated_Code/tasks.c **** 
1699:../Generated_Code/tasks.c **** 	
1700:../Generated_Code/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1701:../Generated_Code/tasks.c **** 		In this case it is assume that this is the only task that is going to
1702:../Generated_Code/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1703:../Generated_Code/tasks.c **** 		can be used in place of vListInsert. */
1704:../Generated_Code/tasks.c **** 		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1705:../Generated_Code/tasks.c **** 
1706:../Generated_Code/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1707:../Generated_Code/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1708:../Generated_Code/tasks.c **** 		function is called form a critical section. */
1709:../Generated_Code/tasks.c **** 		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
1710:../Generated_Code/tasks.c **** 
1711:../Generated_Code/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1712:../Generated_Code/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1713:../Generated_Code/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
1714:../Generated_Code/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
1715:../Generated_Code/tasks.c **** 	}
1716:../Generated_Code/tasks.c **** 	
1717:../Generated_Code/tasks.c **** #endif /* configUSE_TIMERS */
1718:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1719:../Generated_Code/tasks.c **** 
1720:../Generated_Code/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1721:../Generated_Code/tasks.c **** {
1722:../Generated_Code/tasks.c **** tskTCB *pxUnblockedTCB;
1723:../Generated_Code/tasks.c **** portBASE_TYPE xReturn;
1724:../Generated_Code/tasks.c **** 
1725:../Generated_Code/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1726:../Generated_Code/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1727:../Generated_Code/tasks.c **** 
1728:../Generated_Code/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1729:../Generated_Code/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1730:../Generated_Code/tasks.c **** 	it to the ready list.
1731:../Generated_Code/tasks.c **** 
1732:../Generated_Code/tasks.c **** 	If an event is for a queue that is locked then this function will never
1733:../Generated_Code/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1734:../Generated_Code/tasks.c **** 	means we can always expect exclusive access to the event list here.
1735:../Generated_Code/tasks.c **** 	
1736:../Generated_Code/tasks.c **** 	This function assumes that a check has already been made to ensure that
1737:../Generated_Code/tasks.c **** 	pxEventList is not empty. */
1738:../Generated_Code/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
1739:../Generated_Code/tasks.c **** 	configASSERT( pxUnblockedTCB );
1740:../Generated_Code/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
1741:../Generated_Code/tasks.c **** 
1742:../Generated_Code/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1743:../Generated_Code/tasks.c **** 	{
1744:../Generated_Code/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
1745:../Generated_Code/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
1746:../Generated_Code/tasks.c **** 	}
1747:../Generated_Code/tasks.c **** 	else
1748:../Generated_Code/tasks.c **** 	{
1749:../Generated_Code/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1750:../Generated_Code/tasks.c **** 		task pending until the scheduler is resumed. */
1751:../Generated_Code/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
1752:../Generated_Code/tasks.c **** 	}
1753:../Generated_Code/tasks.c **** 
1754:../Generated_Code/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
1755:../Generated_Code/tasks.c **** 	{
1756:../Generated_Code/tasks.c **** 		/* Return true if the task removed from the event list has
1757:../Generated_Code/tasks.c **** 		a higher priority than the calling task.  This allows
1758:../Generated_Code/tasks.c **** 		the calling task to know if it should force a context
1759:../Generated_Code/tasks.c **** 		switch now. */
1760:../Generated_Code/tasks.c **** 		xReturn = pdTRUE;
1761:../Generated_Code/tasks.c **** 	}
1762:../Generated_Code/tasks.c **** 	else
1763:../Generated_Code/tasks.c **** 	{
1764:../Generated_Code/tasks.c **** 		xReturn = pdFALSE;
1765:../Generated_Code/tasks.c **** 	}
1766:../Generated_Code/tasks.c **** 
1767:../Generated_Code/tasks.c **** 	return xReturn;
1768:../Generated_Code/tasks.c **** }
1769:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1770:../Generated_Code/tasks.c **** 
1771:../Generated_Code/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1772:../Generated_Code/tasks.c **** {
1773:../Generated_Code/tasks.c **** 	configASSERT( pxTimeOut );
1774:../Generated_Code/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
1775:../Generated_Code/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
1776:../Generated_Code/tasks.c **** }
1777:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1778:../Generated_Code/tasks.c **** 
1779:../Generated_Code/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1780:../Generated_Code/tasks.c **** {
1781:../Generated_Code/tasks.c **** portBASE_TYPE xReturn;
1782:../Generated_Code/tasks.c **** 
1783:../Generated_Code/tasks.c **** 	configASSERT( pxTimeOut );
1784:../Generated_Code/tasks.c **** 	configASSERT( pxTicksToWait );
1785:../Generated_Code/tasks.c **** 
1786:../Generated_Code/tasks.c **** 	taskENTER_CRITICAL();
1787:../Generated_Code/tasks.c **** 	{
1788:../Generated_Code/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
1789:../Generated_Code/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1790:../Generated_Code/tasks.c **** 			the maximum block time then the task should block indefinitely, and
1791:../Generated_Code/tasks.c **** 			therefore never time out. */
1792:../Generated_Code/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
1793:../Generated_Code/tasks.c **** 			{
1794:../Generated_Code/tasks.c **** 				xReturn = pdFALSE;
1795:../Generated_Code/tasks.c **** 			}
1796:../Generated_Code/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
1797:../Generated_Code/tasks.c **** 		#endif
1798:../Generated_Code/tasks.c **** 
1799:../Generated_Code/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
1800:../Generated_Code/tasks.c **** 		{
1801:../Generated_Code/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
1802:../Generated_Code/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
1803:../Generated_Code/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
1804:../Generated_Code/tasks.c **** 			passed since vTaskSetTimeout() was called. */
1805:../Generated_Code/tasks.c **** 			xReturn = pdTRUE;
1806:../Generated_Code/tasks.c **** 		}
1807:../Generated_Code/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
1808:../Generated_Code/tasks.c **** 		{
1809:../Generated_Code/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
1810:../Generated_Code/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
1811:../Generated_Code/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
1812:../Generated_Code/tasks.c **** 			xReturn = pdFALSE;
1813:../Generated_Code/tasks.c **** 		}
1814:../Generated_Code/tasks.c **** 		else
1815:../Generated_Code/tasks.c **** 		{
1816:../Generated_Code/tasks.c **** 			xReturn = pdTRUE;
1817:../Generated_Code/tasks.c **** 		}
1818:../Generated_Code/tasks.c **** 	}
1819:../Generated_Code/tasks.c **** 	taskEXIT_CRITICAL();
1820:../Generated_Code/tasks.c **** 
1821:../Generated_Code/tasks.c **** 	return xReturn;
1822:../Generated_Code/tasks.c **** }
1823:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1824:../Generated_Code/tasks.c **** 
1825:../Generated_Code/tasks.c **** void vTaskMissedYield( void )
1826:../Generated_Code/tasks.c **** {
1827:../Generated_Code/tasks.c **** 	xMissedYield = pdTRUE;
1828:../Generated_Code/tasks.c **** }
1829:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1830:../Generated_Code/tasks.c **** 
1831:../Generated_Code/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1832:../Generated_Code/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
1833:../Generated_Code/tasks.c **** 	{
1834:../Generated_Code/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
1835:../Generated_Code/tasks.c **** 	tskTCB *pxTCB;
1836:../Generated_Code/tasks.c **** 	
1837:../Generated_Code/tasks.c **** 		if( xTask != NULL )
1838:../Generated_Code/tasks.c **** 		{
1839:../Generated_Code/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
1840:../Generated_Code/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
1841:../Generated_Code/tasks.c **** 		}
1842:../Generated_Code/tasks.c **** 		else
1843:../Generated_Code/tasks.c **** 		{
1844:../Generated_Code/tasks.c **** 			uxReturn = 0U;
1845:../Generated_Code/tasks.c **** 		}
1846:../Generated_Code/tasks.c **** 		
1847:../Generated_Code/tasks.c **** 		return uxReturn;
1848:../Generated_Code/tasks.c **** 	}
1849:../Generated_Code/tasks.c **** #endif
1850:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
1851:../Generated_Code/tasks.c **** 
1852:../Generated_Code/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1853:../Generated_Code/tasks.c **** 	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
1854:../Generated_Code/tasks.c **** 	{
1855:../Generated_Code/tasks.c **** 	tskTCB *pxTCB;
1856:../Generated_Code/tasks.c **** 	
1857:../Generated_Code/tasks.c **** 		if( xTask != NULL )
1858:../Generated_Code/tasks.c **** 		{
1859:../Generated_Code/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
1860:../Generated_Code/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
1861:../Generated_Code/tasks.c **** 		}
1862:../Generated_Code/tasks.c **** 	}
1863:../Generated_Code/tasks.c **** #endif
1864:../Generated_Code/tasks.c **** 
1865:../Generated_Code/tasks.c **** 
1866:../Generated_Code/tasks.c **** /*
1867:../Generated_Code/tasks.c ****  * -----------------------------------------------------------
1868:../Generated_Code/tasks.c ****  * The Idle task.
1869:../Generated_Code/tasks.c ****  * ----------------------------------------------------------
1870:../Generated_Code/tasks.c ****  *
1871:../Generated_Code/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1872:../Generated_Code/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
1873:../Generated_Code/tasks.c ****  *
1874:../Generated_Code/tasks.c ****  * void prvIdleTask( void *pvParameters );
1875:../Generated_Code/tasks.c ****  *
1876:../Generated_Code/tasks.c ****  */
1877:../Generated_Code/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
1878:../Generated_Code/tasks.c **** {
  25              		.loc 1 1878 0
  26              		.cfi_startproc
  27              	.LVL0:
  28 0000 08B5     		push	{r3, lr}
  29              	.LCFI0:
  30              		.cfi_def_cfa_offset 8
  31              		.cfi_offset 3, -8
  32              		.cfi_offset 14, -4
  33              	.LVL1:
  34              	.L3:
1879:../Generated_Code/tasks.c **** 	/* Stop warnings. */
1880:../Generated_Code/tasks.c **** 	( void ) pvParameters;
1881:../Generated_Code/tasks.c **** 
1882:../Generated_Code/tasks.c **** 	for( ;; )
1883:../Generated_Code/tasks.c **** 	{
1884:../Generated_Code/tasks.c **** 		/* See if any tasks have been deleted. */
1885:../Generated_Code/tasks.c **** 		prvCheckTasksWaitingTermination();
1886:../Generated_Code/tasks.c **** 
1887:../Generated_Code/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
1888:../Generated_Code/tasks.c **** 		{
1889:../Generated_Code/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
1890:../Generated_Code/tasks.c **** 			see if any other task has become available.  If we are using
1891:../Generated_Code/tasks.c **** 			preemption we don't need to do this as any task becoming available
1892:../Generated_Code/tasks.c **** 			will automatically get the processor anyway. */
1893:../Generated_Code/tasks.c **** 			taskYIELD();
1894:../Generated_Code/tasks.c **** 		}
1895:../Generated_Code/tasks.c **** 		#endif
1896:../Generated_Code/tasks.c **** 
1897:../Generated_Code/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1898:../Generated_Code/tasks.c **** 		{
1899:../Generated_Code/tasks.c **** 			/* When using preemption tasks of equal priority will be
1900:../Generated_Code/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
1901:../Generated_Code/tasks.c **** 			to run then the idle task should yield before the end of the
1902:../Generated_Code/tasks.c **** 			timeslice.
1903:../Generated_Code/tasks.c **** 
1904:../Generated_Code/tasks.c **** 			A critical region is not required here as we are just reading from
1905:../Generated_Code/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
1906:../Generated_Code/tasks.c **** 			the ready list at the idle priority contains more than one task
1907:../Generated_Code/tasks.c **** 			then a task other than the idle task is ready to execute. */
1908:../Generated_Code/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
  35              		.loc 1 1908 0
  36 0002 044B     		ldr	r3, .L5
  37 0004 1868     		ldr	r0, [r3]
  38 0006 0128     		cmp	r0, #1
  39 0008 01D9     		bls	.L2
1909:../Generated_Code/tasks.c **** 			{
1910:../Generated_Code/tasks.c **** 				taskYIELD();
  40              		.loc 1 1910 0
  41 000a FFF7FEFF 		bl	vPortYieldFromISR
  42              	.LVL2:
  43              	.L2:
1911:../Generated_Code/tasks.c **** 			}
1912:../Generated_Code/tasks.c **** 		}
1913:../Generated_Code/tasks.c **** 		#endif
1914:../Generated_Code/tasks.c **** 
1915:../Generated_Code/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
1916:../Generated_Code/tasks.c **** 		{
1917:../Generated_Code/tasks.c **** 
1918:../Generated_Code/tasks.c **** 			/* Call the user defined function from within the idle task.  This
1919:../Generated_Code/tasks.c **** 			allows the application designer to add background functionality
1920:../Generated_Code/tasks.c **** 			without the overhead of a separate task.
1921:../Generated_Code/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1922:../Generated_Code/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
1923:../Generated_Code/tasks.c ****       FRTOS1_vApplicationIdleHook();
  44              		.loc 1 1923 0
  45 000e FFF7FEFF 		bl	FRTOS1_vApplicationIdleHook
  46              	.LVL3:
1924:../Generated_Code/tasks.c **** 		}
1925:../Generated_Code/tasks.c **** 		#endif
1926:../Generated_Code/tasks.c **** 	}
  47              		.loc 1 1926 0
  48 0012 F6E7     		b	.L3
  49              	.L6:
  50              		.align	2
  51              	.L5:
  52 0014 00000000 		.word	.LANCHOR0
  53              		.cfi_endproc
  54              	.LFE22:
  56              		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
  57              		.align	1
  58              		.code	16
  59              		.thumb_func
  61              	prvAddCurrentTaskToDelayedList:
  62              	.LFB26:
1927:../Generated_Code/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1928:../Generated_Code/tasks.c **** 
1929:../Generated_Code/tasks.c **** 
1930:../Generated_Code/tasks.c **** 
1931:../Generated_Code/tasks.c **** 
1932:../Generated_Code/tasks.c **** 
1933:../Generated_Code/tasks.c **** 
1934:../Generated_Code/tasks.c **** 
1935:../Generated_Code/tasks.c **** /*-----------------------------------------------------------
1936:../Generated_Code/tasks.c ****  * File private functions documented at the top of the file.
1937:../Generated_Code/tasks.c ****  *----------------------------------------------------------*/
1938:../Generated_Code/tasks.c **** 
1939:../Generated_Code/tasks.c **** 
1940:../Generated_Code/tasks.c **** 
1941:../Generated_Code/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
1942:../Generated_Code/tasks.c **** {
1943:../Generated_Code/tasks.c **** 	/* Store the function name in the TCB. */
1944:../Generated_Code/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
1945:../Generated_Code/tasks.c **** 	{
1946:../Generated_Code/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
1947:../Generated_Code/tasks.c **** 		(void)strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMA
1948:../Generated_Code/tasks.c **** 	}
1949:../Generated_Code/tasks.c **** 	#endif
1950:../Generated_Code/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
1951:../Generated_Code/tasks.c **** 
1952:../Generated_Code/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
1953:../Generated_Code/tasks.c **** 	remove the privilege bit if one is present. */
1954:../Generated_Code/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
1955:../Generated_Code/tasks.c **** 	{
1956:../Generated_Code/tasks.c **** 		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
1957:../Generated_Code/tasks.c **** 	}
1958:../Generated_Code/tasks.c **** 
1959:../Generated_Code/tasks.c **** 	pxTCB->uxPriority = uxPriority;
1960:../Generated_Code/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
1961:../Generated_Code/tasks.c **** 	{
1962:../Generated_Code/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
1963:../Generated_Code/tasks.c **** 	}
1964:../Generated_Code/tasks.c **** 	#endif
1965:../Generated_Code/tasks.c **** 
1966:../Generated_Code/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
1967:../Generated_Code/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
1968:../Generated_Code/tasks.c **** 
1969:../Generated_Code/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
1970:../Generated_Code/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
1971:../Generated_Code/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
1972:../Generated_Code/tasks.c **** 
1973:../Generated_Code/tasks.c **** 	/* Event lists are always in priority order. */
1974:../Generated_Code/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
1975:../Generated_Code/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
1976:../Generated_Code/tasks.c **** 
1977:../Generated_Code/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
1978:../Generated_Code/tasks.c **** 	{
1979:../Generated_Code/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
1980:../Generated_Code/tasks.c **** 	}
1981:../Generated_Code/tasks.c **** 	#endif
1982:../Generated_Code/tasks.c **** 
1983:../Generated_Code/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
1984:../Generated_Code/tasks.c **** 	{
1985:../Generated_Code/tasks.c **** 		pxTCB->pxTaskTag = NULL;
1986:../Generated_Code/tasks.c **** 	}
1987:../Generated_Code/tasks.c **** 	#endif
1988:../Generated_Code/tasks.c **** 
1989:../Generated_Code/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1990:../Generated_Code/tasks.c **** 	{
1991:../Generated_Code/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
1992:../Generated_Code/tasks.c **** 	}
1993:../Generated_Code/tasks.c **** 	#endif
1994:../Generated_Code/tasks.c **** 
1995:../Generated_Code/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
1996:../Generated_Code/tasks.c **** 	{
1997:../Generated_Code/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
1998:../Generated_Code/tasks.c **** 	}
1999:../Generated_Code/tasks.c **** 	#else
2000:../Generated_Code/tasks.c **** 	{
2001:../Generated_Code/tasks.c **** 		( void ) xRegions;
2002:../Generated_Code/tasks.c **** 		( void ) usStackDepth;
2003:../Generated_Code/tasks.c **** 	}
2004:../Generated_Code/tasks.c **** 	#endif
2005:../Generated_Code/tasks.c **** }
2006:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2007:../Generated_Code/tasks.c **** 
2008:../Generated_Code/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2009:../Generated_Code/tasks.c **** 
2010:../Generated_Code/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2011:../Generated_Code/tasks.c **** 	{
2012:../Generated_Code/tasks.c **** 	tskTCB *pxTCB;
2013:../Generated_Code/tasks.c **** 	
2014:../Generated_Code/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
2015:../Generated_Code/tasks.c **** 		{
2016:../Generated_Code/tasks.c **** 			xTaskToModify = NULL;
2017:../Generated_Code/tasks.c **** 		}
2018:../Generated_Code/tasks.c **** 
2019:../Generated_Code/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2020:../Generated_Code/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2021:../Generated_Code/tasks.c **** 
2022:../Generated_Code/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2023:../Generated_Code/tasks.c **** 	}
2024:../Generated_Code/tasks.c **** 	/*-----------------------------------------------------------*/
2025:../Generated_Code/tasks.c **** #endif
2026:../Generated_Code/tasks.c **** 
2027:../Generated_Code/tasks.c **** static void prvInitialiseTaskLists( void )
2028:../Generated_Code/tasks.c **** {
2029:../Generated_Code/tasks.c **** unsigned portBASE_TYPE uxPriority;
2030:../Generated_Code/tasks.c **** 
2031:../Generated_Code/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
2032:../Generated_Code/tasks.c **** 	{
2033:../Generated_Code/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
2034:../Generated_Code/tasks.c **** 	}
2035:../Generated_Code/tasks.c **** 
2036:../Generated_Code/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
2037:../Generated_Code/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
2038:../Generated_Code/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
2039:../Generated_Code/tasks.c **** 
2040:../Generated_Code/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2041:../Generated_Code/tasks.c **** 	{
2042:../Generated_Code/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
2043:../Generated_Code/tasks.c **** 	}
2044:../Generated_Code/tasks.c **** 	#endif
2045:../Generated_Code/tasks.c **** 
2046:../Generated_Code/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2047:../Generated_Code/tasks.c **** 	{
2048:../Generated_Code/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
2049:../Generated_Code/tasks.c **** 	}
2050:../Generated_Code/tasks.c **** 	#endif
2051:../Generated_Code/tasks.c **** 
2052:../Generated_Code/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2053:../Generated_Code/tasks.c **** 	using list2. */
2054:../Generated_Code/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
2055:../Generated_Code/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
2056:../Generated_Code/tasks.c **** }
2057:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2058:../Generated_Code/tasks.c **** 
2059:../Generated_Code/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2060:../Generated_Code/tasks.c **** {
2061:../Generated_Code/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2062:../Generated_Code/tasks.c **** 	{
2063:../Generated_Code/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2064:../Generated_Code/tasks.c **** 
2065:../Generated_Code/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2066:../Generated_Code/tasks.c **** 		too often in the idle task. */
2067:../Generated_Code/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
2068:../Generated_Code/tasks.c **** 		{
2069:../Generated_Code/tasks.c **** 			vTaskSuspendAll();
2070:../Generated_Code/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
2071:../Generated_Code/tasks.c **** 			(void)xTaskResumeAll();
2072:../Generated_Code/tasks.c **** 
2073:../Generated_Code/tasks.c **** 			if( xListIsEmpty == pdFALSE )
2074:../Generated_Code/tasks.c **** 			{
2075:../Generated_Code/tasks.c **** 				tskTCB *pxTCB;
2076:../Generated_Code/tasks.c **** 
2077:../Generated_Code/tasks.c **** 				taskENTER_CRITICAL();
2078:../Generated_Code/tasks.c **** 				{
2079:../Generated_Code/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
2080:../Generated_Code/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
2081:../Generated_Code/tasks.c **** 					--uxCurrentNumberOfTasks;
2082:../Generated_Code/tasks.c **** 					--uxTasksDeleted;
2083:../Generated_Code/tasks.c **** 				}
2084:../Generated_Code/tasks.c **** 				taskEXIT_CRITICAL();
2085:../Generated_Code/tasks.c **** 
2086:../Generated_Code/tasks.c **** 				prvDeleteTCB( pxTCB );
2087:../Generated_Code/tasks.c **** 			}
2088:../Generated_Code/tasks.c **** 		}
2089:../Generated_Code/tasks.c **** 	}
2090:../Generated_Code/tasks.c **** 	#endif
2091:../Generated_Code/tasks.c **** }
2092:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2093:../Generated_Code/tasks.c **** 
2094:../Generated_Code/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2095:../Generated_Code/tasks.c **** {
  63              		.loc 1 2095 0
  64              		.cfi_startproc
  65              	.LVL4:
2096:../Generated_Code/tasks.c **** 	/* The list item will be inserted in wake time order. */
2097:../Generated_Code/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  66              		.loc 1 2097 0
  67 0000 0D4B     		ldr	r3, .L10
2095:../Generated_Code/tasks.c **** {
  68              		.loc 1 2095 0
  69 0002 10B5     		push	{r4, lr}
  70              	.LCFI1:
  71              		.cfi_def_cfa_offset 8
  72              		.cfi_offset 4, -8
  73              		.cfi_offset 14, -4
  74              		.loc 1 2097 0
  75 0004 1A68     		ldr	r2, [r3]
2095:../Generated_Code/tasks.c **** {
  76              		.loc 1 2095 0
  77 0006 041C     		mov	r4, r0
  78              		.loc 1 2097 0
  79 0008 5060     		str	r0, [r2, #4]
2098:../Generated_Code/tasks.c **** 
2099:../Generated_Code/tasks.c **** 	if( xTimeToWake < xTickCount )
  80              		.loc 1 2099 0
  81 000a 0C48     		ldr	r0, .L10+4
  82              	.LVL5:
  83 000c 0168     		ldr	r1, [r0]
  84 000e 8C42     		cmp	r4, r1
  85 0010 06D2     		bcs	.L8
  86              	.LBB6:
  87              	.LBB7:
2100:../Generated_Code/tasks.c **** 	{
2101:../Generated_Code/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2102:../Generated_Code/tasks.c **** 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericList
  88              		.loc 1 2102 0
  89 0012 0B4C     		ldr	r4, .L10+8
  90              	.LVL6:
  91 0014 2068     		ldr	r0, [r4]
  92 0016 1968     		ldr	r1, [r3]
  93 0018 0431     		add	r1, r1, #4
  94 001a FFF7FEFF 		bl	vListInsert
  95              	.LVL7:
  96 001e 0AE0     		b	.L7
  97              	.LVL8:
  98              	.L8:
  99              	.LBE7:
 100              	.LBE6:
2103:../Generated_Code/tasks.c **** 	}
2104:../Generated_Code/tasks.c **** 	else
2105:../Generated_Code/tasks.c **** 	{
2106:../Generated_Code/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2107:../Generated_Code/tasks.c **** 		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) )
 101              		.loc 1 2107 0
 102 0020 084A     		ldr	r2, .L10+12
 103 0022 1068     		ldr	r0, [r2]
 104 0024 1968     		ldr	r1, [r3]
 105 0026 0431     		add	r1, r1, #4
 106 0028 FFF7FEFF 		bl	vListInsert
 107              	.LVL9:
2108:../Generated_Code/tasks.c **** 
2109:../Generated_Code/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2110:../Generated_Code/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2111:../Generated_Code/tasks.c **** 		too. */
2112:../Generated_Code/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 108              		.loc 1 2112 0
 109 002c 064B     		ldr	r3, .L10+16
 110 002e 1868     		ldr	r0, [r3]
 111 0030 8442     		cmp	r4, r0
 112 0032 00D2     		bcs	.L7
2113:../Generated_Code/tasks.c **** 		{
2114:../Generated_Code/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 113              		.loc 1 2114 0
 114 0034 1C60     		str	r4, [r3]
 115              	.LVL10:
 116              	.L7:
2115:../Generated_Code/tasks.c **** 		}
2116:../Generated_Code/tasks.c **** 	}
2117:../Generated_Code/tasks.c **** }
 117              		.loc 1 2117 0
 118              		@ sp needed for prologue
 119 0036 10BD     		pop	{r4, pc}
 120              	.L11:
 121              		.align	2
 122              	.L10:
 123 0038 00000000 		.word	.LANCHOR1
 124 003c 00000000 		.word	.LANCHOR2
 125 0040 00000000 		.word	.LANCHOR3
 126 0044 00000000 		.word	.LANCHOR4
 127 0048 00000000 		.word	.LANCHOR5
 128              		.cfi_endproc
 129              	.LFE26:
 131              		.section	.text.xTaskGenericCreate,"ax",%progbits
 132              		.align	1
 133              		.global	xTaskGenericCreate
 134              		.code	16
 135              		.thumb_func
 137              	xTaskGenericCreate:
 138              	.LFB0:
 401:../Generated_Code/tasks.c **** {
 139              		.loc 1 401 0
 140              		.cfi_startproc
 141              	.LVL11:
 142 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 143              	.LCFI2:
 144              		.cfi_def_cfa_offset 32
 145              		.cfi_offset 0, -32
 146              		.cfi_offset 1, -28
 147              		.cfi_offset 2, -24
 148              		.cfi_offset 4, -20
 149              		.cfi_offset 5, -16
 150              		.cfi_offset 6, -12
 151              		.cfi_offset 7, -8
 152              		.cfi_offset 14, -4
 401:../Generated_Code/tasks.c **** {
 153              		.loc 1 401 0
 154 0002 0A9D     		ldr	r5, [sp, #40]
 155 0004 071C     		mov	r7, r0
 156 0006 161C     		mov	r6, r2
 157 0008 0193     		str	r3, [sp, #4]
 405:../Generated_Code/tasks.c **** 	configASSERT( pxTaskCode );
 158              		.loc 1 405 0
 159 000a 0028     		cmp	r0, #0
 160 000c 03D1     		bne	.L13
 405:../Generated_Code/tasks.c **** 	configASSERT( pxTaskCode );
 161              		.loc 1 405 0 is_stmt 0
 162              	@ 405 "../Generated_Code/tasks.c" 1
 163 000e 5020     		  mov r0, #80 
 164 0010 80F31188 	  msr basepri, r0 
 165              	
 166              	@ 0 "" 2
 167              	.LVL12:
 168              		.code	16
 169              	.L14:
 170 0014 FEE7     		b	.L14
 171              	.LVL13:
 172              	.L13:
 406:../Generated_Code/tasks.c **** 	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 173              		.loc 1 406 0 is_stmt 1
 174 0016 0899     		ldr	r1, [sp, #32]
 175              	.LVL14:
 176 0018 0029     		cmp	r1, #0
 177 001a 03D0     		beq	.L15
 406:../Generated_Code/tasks.c **** 	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 178              		.loc 1 406 0 is_stmt 0
 179              	@ 406 "../Generated_Code/tasks.c" 1
 180 001c 5020     		  mov r0, #80 
 181 001e 80F31188 	  msr basepri, r0 
 182              	
 183              	@ 0 "" 2
 184              	.LVL15:
 185              		.code	16
 186              	.L16:
 187 0022 FEE7     		b	.L16
 188              	.LVL16:
 189              	.L15:
 190              	.LBB15:
 191              	.LBB16:
2118:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2119:../Generated_Code/tasks.c **** 
2120:../Generated_Code/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2121:../Generated_Code/tasks.c **** {
2122:../Generated_Code/tasks.c **** tskTCB *pxNewTCB;
2123:../Generated_Code/tasks.c **** 
2124:../Generated_Code/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2125:../Generated_Code/tasks.c **** 	the implementation of the port malloc function. */
2126:../Generated_Code/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 192              		.loc 1 2126 0 is_stmt 1
 193 0024 3820     		mov	r0, #56
 194              	.LVL17:
 195 0026 FFF7FEFF 		bl	pvPortMalloc
 196              	.LVL18:
 197 002a 041E     		sub	r4, r0, #0
 198              	.LVL19:
2127:../Generated_Code/tasks.c **** 
2128:../Generated_Code/tasks.c **** 	if( pxNewTCB != NULL )
 199              		.loc 1 2128 0
 200 002c 7DD0     		beq	.L17
2129:../Generated_Code/tasks.c **** 	{
2130:../Generated_Code/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2131:../Generated_Code/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2132:../Generated_Code/tasks.c **** 		be deleted later if required. */
2133:../Generated_Code/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 201              		.loc 1 2133 0
 202 002e 002D     		cmp	r5, #0
 203 0030 03D1     		bne	.L18
 204 0032 B000     		lsl	r0, r6, #2
 205              	.LVL20:
 206 0034 FFF7FEFF 		bl	pvPortMalloc
 207              	.LVL21:
 208 0038 051C     		mov	r5, r0
 209              	.LVL22:
 210              	.L18:
 211 003a 2563     		str	r5, [r4, #48]
2134:../Generated_Code/tasks.c **** 
2135:../Generated_Code/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 212              		.loc 1 2135 0
 213 003c 002D     		cmp	r5, #0
 214 003e 03D1     		bne	.L19
2136:../Generated_Code/tasks.c **** 		{
2137:../Generated_Code/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2138:../Generated_Code/tasks.c **** 			vPortFree( pxNewTCB );
 215              		.loc 1 2138 0
 216 0040 201C     		mov	r0, r4
 217 0042 FFF7FEFF 		bl	vPortFree
 218              	.LVL23:
 219 0046 70E0     		b	.L17
 220              	.LVL24:
 221              	.L19:
2139:../Generated_Code/tasks.c **** 			pxNewTCB = NULL;
2140:../Generated_Code/tasks.c **** 		}
2141:../Generated_Code/tasks.c **** 		else
2142:../Generated_Code/tasks.c **** 		{
2143:../Generated_Code/tasks.c **** 			/* Just to help debugging. */
2144:../Generated_Code/tasks.c **** 			(void)memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( p
 222              		.loc 1 2144 0
 223 0048 B200     		lsl	r2, r6, #2
 224 004a 281C     		mov	r0, r5
 225 004c A521     		mov	r1, #165
 226 004e FFF7FEFF 		bl	memset
 227              	.LVL25:
 228              	.LBE16:
 229              	.LBE15:
 230              	.LBB17:
 231              	.LBB18:
 232              	.LBB19:
1950:../Generated_Code/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 233              		.loc 1 1950 0
 234 0052 211C     		mov	r1, r4
 235              	.LBE19:
 236              	.LBE18:
 436:../Generated_Code/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 237              		.loc 1 436 0
 238 0054 226B     		ldr	r2, [r4, #48]
 239              	.LBB26:
 240              	.LBB20:
1950:../Generated_Code/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 241              		.loc 1 1950 0
 242 0056 3431     		add	r1, r1, #52
 243 0058 0025     		mov	r5, #0
 244              	.LBE20:
 245              	.LBE26:
 436:../Generated_Code/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 246              		.loc 1 436 0
 247 005a 013E     		sub	r6, r6, #1
 248              	.LVL26:
 249              	.LBB27:
 250              	.LBB21:
1950:../Generated_Code/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 251              		.loc 1 1950 0
 252 005c 0D70     		strb	r5, [r1]
 253              	.LBE21:
 254              	.LBE27:
 436:../Generated_Code/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 255              		.loc 1 436 0
 256 005e B000     		lsl	r0, r6, #2
 257              	.LBB28:
 258              	.LBB22:
1959:../Generated_Code/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 259              		.loc 1 1959 0
 260 0060 E562     		str	r5, [r4, #44]
1966:../Generated_Code/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 261              		.loc 1 1966 0
 262 0062 251D     		add	r5, r4, #4
 263              	.LBE22:
 264              	.LBE28:
 436:../Generated_Code/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 265              		.loc 1 436 0
 266 0064 1618     		add	r6, r2, r0
 267              	.LVL27:
 437:../Generated_Code/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 268              		.loc 1 437 0
 269 0066 0723     		mov	r3, #7
 270              	.LBB29:
 271              	.LBB23:
1966:../Generated_Code/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 272              		.loc 1 1966 0
 273 0068 281C     		mov	r0, r5
 274              	.LBE23:
 275              	.LBE29:
 437:../Generated_Code/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 276              		.loc 1 437 0
 277 006a 9E43     		bic	r6, r3
 278              	.LVL28:
 279              	.LBB30:
 280              	.LBB24:
1966:../Generated_Code/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 281              		.loc 1 1966 0
 282 006c FFF7FEFF 		bl	vListInitialiseItem
 283              	.LVL29:
1967:../Generated_Code/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 284              		.loc 1 1967 0
 285 0070 201C     		mov	r0, r4
 286 0072 1830     		add	r0, r0, #24
 287 0074 FFF7FEFF 		bl	vListInitialiseItem
 288              	.LVL30:
1974:../Generated_Code/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 289              		.loc 1 1974 0
 290 0078 0120     		mov	r0, #1
 291 007a A061     		str	r0, [r4, #24]
 292              	.LBE24:
 293              	.LBE30:
 469:../Generated_Code/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 294              		.loc 1 469 0
 295 007c 391C     		mov	r1, r7
 296              	.LBB31:
 297              	.LBB25:
1971:../Generated_Code/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 298              		.loc 1 1971 0
 299 007e 2461     		str	r4, [r4, #16]
1975:../Generated_Code/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 300              		.loc 1 1975 0
 301 0080 6462     		str	r4, [r4, #36]
 302              	.LBE25:
 303              	.LBE31:
 469:../Generated_Code/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 304              		.loc 1 469 0
 305 0082 301C     		mov	r0, r6
 306 0084 019A     		ldr	r2, [sp, #4]
 307 0086 FFF7FEFF 		bl	pxPortInitialiseStack
 308              	.LVL31:
 476:../Generated_Code/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 309              		.loc 1 476 0
 310 008a 099F     		ldr	r7, [sp, #36]
 311              	.LVL32:
 469:../Generated_Code/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 312              		.loc 1 469 0
 313 008c 2060     		str	r0, [r4]
 476:../Generated_Code/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 314              		.loc 1 476 0
 315 008e 002F     		cmp	r7, #0
 316 0090 00D0     		beq	.L20
 481:../Generated_Code/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 317              		.loc 1 481 0
 318 0092 3C60     		str	r4, [r7]
 319              	.L20:
 486:../Generated_Code/tasks.c **** 		taskENTER_CRITICAL();
 320              		.loc 1 486 0
 321 0094 FFF7FEFF 		bl	vPortEnterCritical
 322              	.LVL33:
 488:../Generated_Code/tasks.c **** 			uxCurrentNumberOfTasks++;
 323              		.loc 1 488 0
 324 0098 254B     		ldr	r3, .L37
 489:../Generated_Code/tasks.c **** 			if( pxCurrentTCB == NULL )
 325              		.loc 1 489 0
 326 009a 264E     		ldr	r6, .L37+4
 327              	.LVL34:
 488:../Generated_Code/tasks.c **** 			uxCurrentNumberOfTasks++;
 328              		.loc 1 488 0
 329 009c 1A68     		ldr	r2, [r3]
 330 009e 264F     		ldr	r7, .L37+8
 331 00a0 0132     		add	r2, r2, #1
 332 00a2 1A60     		str	r2, [r3]
 489:../Generated_Code/tasks.c **** 			if( pxCurrentTCB == NULL )
 333              		.loc 1 489 0
 334 00a4 3168     		ldr	r1, [r6]
 335 00a6 0029     		cmp	r1, #0
 336 00a8 19D1     		bne	.L21
 493:../Generated_Code/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 337              		.loc 1 493 0
 338 00aa 3460     		str	r4, [r6]
 495:../Generated_Code/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 339              		.loc 1 495 0
 340 00ac 1968     		ldr	r1, [r3]
 341 00ae 0129     		cmp	r1, #1
 342 00b0 1DD1     		bne	.L23
 343              	.LBB32:
 344              	.LBB33:
2033:../Generated_Code/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 345              		.loc 1 2033 0
 346 00b2 2248     		ldr	r0, .L37+12
 347 00b4 FFF7FEFF 		bl	vListInitialise
 348              	.LVL35:
2036:../Generated_Code/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 349              		.loc 1 2036 0
 350 00b8 2148     		ldr	r0, .L37+16
 351 00ba FFF7FEFF 		bl	vListInitialise
 352              	.LVL36:
2037:../Generated_Code/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 353              		.loc 1 2037 0
 354 00be 2148     		ldr	r0, .L37+20
 355 00c0 FFF7FEFF 		bl	vListInitialise
 356              	.LVL37:
2038:../Generated_Code/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 357              		.loc 1 2038 0
 358 00c4 2048     		ldr	r0, .L37+24
 359 00c6 FFF7FEFF 		bl	vListInitialise
 360              	.LVL38:
2048:../Generated_Code/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 361              		.loc 1 2048 0
 362 00ca 2048     		ldr	r0, .L37+28
 363 00cc FFF7FEFF 		bl	vListInitialise
 364              	.LVL39:
2054:../Generated_Code/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 365              		.loc 1 2054 0
 366 00d0 1F48     		ldr	r0, .L37+32
 367 00d2 1B4B     		ldr	r3, .L37+16
2055:../Generated_Code/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 368              		.loc 1 2055 0
 369 00d4 1F49     		ldr	r1, .L37+36
 370 00d6 1B4A     		ldr	r2, .L37+20
2054:../Generated_Code/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 371              		.loc 1 2054 0
 372 00d8 0360     		str	r3, [r0]
2055:../Generated_Code/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 373              		.loc 1 2055 0
 374 00da 0A60     		str	r2, [r1]
 375 00dc 07E0     		b	.L23
 376              	.LVL40:
 377              	.L21:
 378              	.LBE33:
 379              	.LBE32:
 508:../Generated_Code/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 380              		.loc 1 508 0
 381 00de 3868     		ldr	r0, [r7]
 382 00e0 0028     		cmp	r0, #0
 383 00e2 04D1     		bne	.L23
 510:../Generated_Code/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 384              		.loc 1 510 0
 385 00e4 3368     		ldr	r3, [r6]
 386 00e6 DA6A     		ldr	r2, [r3, #44]
 387 00e8 002A     		cmp	r2, #0
 388 00ea 00D1     		bne	.L23
 512:../Generated_Code/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 389              		.loc 1 512 0
 390 00ec 3460     		str	r4, [r6]
 391              	.L23:
 519:../Generated_Code/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 392              		.loc 1 519 0
 393 00ee 1A48     		ldr	r0, .L37+40
 394 00f0 E46A     		ldr	r4, [r4, #44]
 395              	.LVL41:
 396 00f2 0368     		ldr	r3, [r0]
 397 00f4 9C42     		cmp	r4, r3
 398 00f6 00D9     		bls	.L25
 521:../Generated_Code/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 399              		.loc 1 521 0
 400 00f8 0460     		str	r4, [r0]
 401              	.L25:
 530:../Generated_Code/tasks.c **** 			uxTaskNumber++;
 402              		.loc 1 530 0
 403 00fa 184A     		ldr	r2, .L37+44
 532:../Generated_Code/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 404              		.loc 1 532 0
 405 00fc 1848     		ldr	r0, .L37+48
 530:../Generated_Code/tasks.c **** 			uxTaskNumber++;
 406              		.loc 1 530 0
 407 00fe 1168     		ldr	r1, [r2]
 532:../Generated_Code/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 408              		.loc 1 532 0
 409 0100 0368     		ldr	r3, [r0]
 530:../Generated_Code/tasks.c **** 			uxTaskNumber++;
 410              		.loc 1 530 0
 411 0102 0131     		add	r1, r1, #1
 412 0104 1160     		str	r1, [r2]
 532:../Generated_Code/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 413              		.loc 1 532 0
 414 0106 9C42     		cmp	r4, r3
 415 0108 00D9     		bls	.L26
 532:../Generated_Code/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 416              		.loc 1 532 0 is_stmt 0
 417 010a 0460     		str	r4, [r0]
 418              	.L26:
 532:../Generated_Code/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 419              		.loc 1 532 0
 420 010c 1422     		mov	r2, #20
 421 010e 5443     		mul	r4, r2
 422 0110 0A49     		ldr	r1, .L37+12
 423 0112 0819     		add	r0, r1, r4
 424 0114 291C     		mov	r1, r5
 425 0116 FFF7FEFF 		bl	vListInsertEnd
 426              	.LVL42:
 538:../Generated_Code/tasks.c **** 		taskEXIT_CRITICAL();
 427              		.loc 1 538 0 is_stmt 1
 428 011a FFF7FEFF 		bl	vPortExitCritical
 429              	.LVL43:
 430              	.LBE17:
 548:../Generated_Code/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 431              		.loc 1 548 0
 432 011e 3D68     		ldr	r5, [r7]
 433              	.LVL44:
 534:../Generated_Code/tasks.c **** 			xReturn = pdPASS;
 434              		.loc 1 534 0
 435 0120 0120     		mov	r0, #1
 548:../Generated_Code/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 436              		.loc 1 548 0
 437 0122 002D     		cmp	r5, #0
 438 0124 03D0     		beq	.L33
 552:../Generated_Code/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 439              		.loc 1 552 0
 440 0126 3368     		ldr	r3, [r6]
 441 0128 01E0     		b	.L33
 442              	.LVL45:
 443              	.L17:
 542:../Generated_Code/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 444              		.loc 1 542 0
 445 012a 0126     		mov	r6, #1
 446              	.LVL46:
 447 012c 7042     		neg	r0, r6
 448              	.LVL47:
 449              	.L33:
 560:../Generated_Code/tasks.c **** }
 450              		.loc 1 560 0
 451              		@ sp needed for prologue
 452 012e FEBD     		pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 453              	.L38:
 454              		.align	2
 455              	.L37:
 456 0130 00000000 		.word	.LANCHOR6
 457 0134 00000000 		.word	.LANCHOR1
 458 0138 00000000 		.word	.LANCHOR11
 459 013c 00000000 		.word	.LANCHOR0
 460 0140 00000000 		.word	.LANCHOR7
 461 0144 00000000 		.word	.LANCHOR8
 462 0148 00000000 		.word	.LANCHOR9
 463 014c 00000000 		.word	.LANCHOR10
 464 0150 00000000 		.word	.LANCHOR4
 465 0154 00000000 		.word	.LANCHOR3
 466 0158 00000000 		.word	.LANCHOR12
 467 015c 00000000 		.word	.LANCHOR13
 468 0160 00000000 		.word	.LANCHOR14
 469              		.cfi_endproc
 470              	.LFE0:
 472              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 473              		.align	1
 474              		.global	uxTaskPriorityGet
 475              		.code	16
 476              		.thumb_func
 478              	uxTaskPriorityGet:
 479              	.LFB3:
 743:../Generated_Code/tasks.c **** 	{
 480              		.loc 1 743 0
 481              		.cfi_startproc
 482              	.LVL48:
 483 0000 10B5     		push	{r4, lr}
 484              	.LCFI3:
 485              		.cfi_def_cfa_offset 8
 486              		.cfi_offset 4, -8
 487              		.cfi_offset 14, -4
 743:../Generated_Code/tasks.c **** 	{
 488              		.loc 1 743 0
 489 0002 041C     		mov	r4, r0
 747:../Generated_Code/tasks.c **** 		taskENTER_CRITICAL();
 490              		.loc 1 747 0
 491 0004 FFF7FEFF 		bl	vPortEnterCritical
 492              	.LVL49:
 751:../Generated_Code/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 493              		.loc 1 751 0
 494 0008 201E     		sub	r0, r4, #0
 495 000a 01D1     		bne	.L40
 751:../Generated_Code/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 496              		.loc 1 751 0 is_stmt 0
 497 000c 034B     		ldr	r3, .L42
 498 000e 1868     		ldr	r0, [r3]
 499              	.L40:
 500              	.LVL50:
 752:../Generated_Code/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 501              		.loc 1 752 0 is_stmt 1
 502 0010 C46A     		ldr	r4, [r0, #44]
 503              	.LVL51:
 757:../Generated_Code/tasks.c **** 	}
 504              		.loc 1 757 0
 505              		@ sp needed for prologue
 754:../Generated_Code/tasks.c **** 		taskEXIT_CRITICAL();
 506              		.loc 1 754 0
 507 0012 FFF7FEFF 		bl	vPortExitCritical
 508              	.LVL52:
 757:../Generated_Code/tasks.c **** 	}
 509              		.loc 1 757 0
 510 0016 201C     		mov	r0, r4
 511              	.LVL53:
 512 0018 10BD     		pop	{r4, pc}
 513              	.L43:
 514 001a C046     		.align	2
 515              	.L42:
 516 001c 00000000 		.word	.LANCHOR1
 517              		.cfi_endproc
 518              	.LFE3:
 520              		.section	.text.vTaskPrioritySet,"ax",%progbits
 521              		.align	1
 522              		.global	vTaskPrioritySet
 523              		.code	16
 524              		.thumb_func
 526              	vTaskPrioritySet:
 527              	.LFB4:
 765:../Generated_Code/tasks.c **** 	{
 528              		.loc 1 765 0
 529              		.cfi_startproc
 530              	.LVL54:
 531 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 532              	.LCFI4:
 533              		.cfi_def_cfa_offset 24
 534              		.cfi_offset 3, -24
 535              		.cfi_offset 4, -20
 536              		.cfi_offset 5, -16
 537              		.cfi_offset 6, -12
 538              		.cfi_offset 7, -8
 539              		.cfi_offset 14, -4
 765:../Generated_Code/tasks.c **** 	{
 540              		.loc 1 765 0
 541 0002 051C     		mov	r5, r0
 770:../Generated_Code/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 542              		.loc 1 770 0
 543 0004 0029     		cmp	r1, #0
 544 0006 03D0     		beq	.L45
 770:../Generated_Code/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 545              		.loc 1 770 0 is_stmt 0
 546              	@ 770 "../Generated_Code/tasks.c" 1
 547 0008 5020     		  mov r0, #80 
 548 000a 80F31188 	  msr basepri, r0 
 549              	
 550              	@ 0 "" 2
 551              	.LVL55:
 552              		.code	16
 553              	.L46:
 554 000e FEE7     		b	.L46
 555              	.LVL56:
 556              	.L45:
 778:../Generated_Code/tasks.c **** 		taskENTER_CRITICAL();
 557              		.loc 1 778 0 is_stmt 1
 558 0010 FFF7FEFF 		bl	vPortEnterCritical
 559              	.LVL57:
 780:../Generated_Code/tasks.c **** 			if( pxTask == pxCurrentTCB )
 560              		.loc 1 780 0
 561 0014 164B     		ldr	r3, .L55
 562 0016 1A68     		ldr	r2, [r3]
 563 0018 9542     		cmp	r5, r2
 564 001a 01D0     		beq	.L47
 787:../Generated_Code/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 565              		.loc 1 787 0
 566 001c 2C1E     		sub	r4, r5, #0
 567 001e 01D1     		bne	.L48
 568              	.L47:
 787:../Generated_Code/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 569              		.loc 1 787 0 is_stmt 0
 570 0020 1C68     		ldr	r4, [r3]
 571 0022 0025     		mov	r5, #0
 572              	.LVL58:
 573              	.L48:
 797:../Generated_Code/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 574              		.loc 1 797 0 is_stmt 1
 575 0024 E06A     		ldr	r0, [r4, #44]
 576              	.LVL59:
 801:../Generated_Code/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 577              		.loc 1 801 0
 578 0026 0028     		cmp	r0, #0
 579 0028 1ED0     		beq	.L50
 580              	.LVL60:
 849:../Generated_Code/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 581              		.loc 1 849 0
 582 002a 1423     		mov	r3, #20
 583 002c 5843     		mul	r0, r3
 584              	.LVL61:
 585 002e 114F     		ldr	r7, .L55+4
 586 0030 6269     		ldr	r2, [r4, #20]
 839:../Generated_Code/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 587              		.loc 1 839 0
 588 0032 0021     		mov	r1, #0
 843:../Generated_Code/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 589              		.loc 1 843 0
 590 0034 0126     		mov	r6, #1
 849:../Generated_Code/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 591              		.loc 1 849 0
 592 0036 3818     		add	r0, r7, r0
 839:../Generated_Code/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 593              		.loc 1 839 0
 594 0038 E162     		str	r1, [r4, #44]
 843:../Generated_Code/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 595              		.loc 1 843 0
 596 003a A661     		str	r6, [r4, #24]
 849:../Generated_Code/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 597              		.loc 1 849 0
 598 003c 8242     		cmp	r2, r0
 599 003e 0FD1     		bne	.L51
 854:../Generated_Code/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 600              		.loc 1 854 0
 601 0040 261D     		add	r6, r4, #4
 602 0042 301C     		mov	r0, r6
 603 0044 FFF7FEFF 		bl	vListRemove
 604              	.LVL62:
 855:../Generated_Code/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 605              		.loc 1 855 0
 606 0048 0B4B     		ldr	r3, .L55+8
 607 004a E46A     		ldr	r4, [r4, #44]
 608              	.LVL63:
 609 004c 1968     		ldr	r1, [r3]
 610 004e 8C42     		cmp	r4, r1
 611 0050 00D9     		bls	.L52
 855:../Generated_Code/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 612              		.loc 1 855 0 is_stmt 0
 613 0052 1C60     		str	r4, [r3]
 614              	.L52:
 855:../Generated_Code/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 615              		.loc 1 855 0
 616 0054 1420     		mov	r0, #20
 617 0056 4443     		mul	r4, r0
 618 0058 311C     		mov	r1, r6
 619 005a 3819     		add	r0, r7, r4
 620 005c FFF7FEFF 		bl	vListInsertEnd
 621              	.LVL64:
 622              	.L51:
 858:../Generated_Code/tasks.c **** 				if( xYieldRequired == pdTRUE )
 623              		.loc 1 858 0 is_stmt 1
 624 0060 002D     		cmp	r5, #0
 625 0062 01D1     		bne	.L50
 860:../Generated_Code/tasks.c **** 					portYIELD_WITHIN_API();
 626              		.loc 1 860 0
 627 0064 FFF7FEFF 		bl	vPortYieldFromISR
 628              	.LVL65:
 629              	.L50:
 864:../Generated_Code/tasks.c **** 		taskEXIT_CRITICAL();
 630              		.loc 1 864 0
 631 0068 FFF7FEFF 		bl	vPortExitCritical
 632              	.LVL66:
 865:../Generated_Code/tasks.c **** 	}
 633              		.loc 1 865 0
 634              		@ sp needed for prologue
 635 006c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 636              	.L56:
 637 006e C046     		.align	2
 638              	.L55:
 639 0070 00000000 		.word	.LANCHOR1
 640 0074 00000000 		.word	.LANCHOR0
 641 0078 00000000 		.word	.LANCHOR14
 642              		.cfi_endproc
 643              	.LFE4:
 645              		.section	.text.xTaskIsTaskSuspended,"ax",%progbits
 646              		.align	1
 647              		.global	xTaskIsTaskSuspended
 648              		.code	16
 649              		.thumb_func
 651              	xTaskIsTaskSuspended:
 652              	.LFB6:
 937:../Generated_Code/tasks.c **** 	{
 653              		.loc 1 937 0
 654              		.cfi_startproc
 655              	.LVL67:
 656 0000 00B5     		push	{lr}
 657              	.LCFI5:
 658              		.cfi_def_cfa_offset 4
 659              		.cfi_offset 14, -4
 937:../Generated_Code/tasks.c **** 	{
 660              		.loc 1 937 0
 661 0002 031E     		sub	r3, r0, #0
 942:../Generated_Code/tasks.c **** 		configASSERT( xTask );
 662              		.loc 1 942 0
 663 0004 03D1     		bne	.L58
 942:../Generated_Code/tasks.c **** 		configASSERT( xTask );
 664              		.loc 1 942 0 is_stmt 0
 665              	@ 942 "../Generated_Code/tasks.c" 1
 666 0006 5020     		  mov r0, #80 
 667 0008 80F31188 	  msr basepri, r0 
 668              	
 669              	@ 0 "" 2
 670              	.LVL68:
 671              		.code	16
 672              	.L59:
 673 000c FEE7     		b	.L59
 674              	.LVL69:
 675              	.L58:
 946:../Generated_Code/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 676              		.loc 1 946 0 is_stmt 1
 677 000e 064A     		ldr	r2, .L64
 678 0010 5969     		ldr	r1, [r3, #20]
 938:../Generated_Code/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 679              		.loc 1 938 0
 680 0012 0020     		mov	r0, #0
 681              	.LVL70:
 946:../Generated_Code/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 682              		.loc 1 946 0
 683 0014 9142     		cmp	r1, r2
 684 0016 05D1     		bne	.L60
 685              	.LVL71:
 686              	.LBB36:
 687              	.LBB37:
 949:../Generated_Code/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 688              		.loc 1 949 0
 689 0018 9B6A     		ldr	r3, [r3, #40]
 690              	.LVL72:
 691 001a 044A     		ldr	r2, .L64+4
 692 001c 9342     		cmp	r3, r2
 693 001e 01D0     		beq	.L60
 938:../Generated_Code/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 694              		.loc 1 938 0
 695 0020 5842     		neg	r0, r3
 696 0022 5841     		adc	r0, r0, r3
 697              	.LVL73:
 698              	.L60:
 699              	.LBE37:
 700              	.LBE36:
 963:../Generated_Code/tasks.c **** 	}
 701              		.loc 1 963 0
 702              		@ sp needed for prologue
 703 0024 00BD     		pop	{pc}
 704              	.L65:
 705 0026 C046     		.align	2
 706              	.L64:
 707 0028 00000000 		.word	.LANCHOR10
 708 002c 00000000 		.word	.LANCHOR9
 709              		.cfi_endproc
 710              	.LFE6:
 712              		.section	.text.vTaskResume,"ax",%progbits
 713              		.align	1
 714              		.global	vTaskResume
 715              		.code	16
 716              		.thumb_func
 718              	vTaskResume:
 719              	.LFB7:
 971:../Generated_Code/tasks.c **** 	{
 720              		.loc 1 971 0
 721              		.cfi_startproc
 722              	.LVL74:
 723 0000 70B5     		push	{r4, r5, r6, lr}
 724              	.LCFI6:
 725              		.cfi_def_cfa_offset 16
 726              		.cfi_offset 4, -16
 727              		.cfi_offset 5, -12
 728              		.cfi_offset 6, -8
 729              		.cfi_offset 14, -4
 971:../Generated_Code/tasks.c **** 	{
 730              		.loc 1 971 0
 731 0002 041E     		sub	r4, r0, #0
 975:../Generated_Code/tasks.c **** 		configASSERT( pxTaskToResume );
 732              		.loc 1 975 0
 733 0004 03D1     		bne	.L67
 975:../Generated_Code/tasks.c **** 		configASSERT( pxTaskToResume );
 734              		.loc 1 975 0 is_stmt 0
 735              	@ 975 "../Generated_Code/tasks.c" 1
 736 0006 5020     		  mov r0, #80 
 737 0008 80F31188 	  msr basepri, r0 
 738              	
 739              	@ 0 "" 2
 740              	.LVL75:
 741              		.code	16
 742              	.L68:
 743 000c FEE7     		b	.L68
 744              	.LVL76:
 745              	.L67:
 983:../Generated_Code/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 746              		.loc 1 983 0 is_stmt 1
 747 000e 134E     		ldr	r6, .L74
 748 0010 3368     		ldr	r3, [r6]
 749 0012 9842     		cmp	r0, r3
 750 0014 20D0     		beq	.L66
 985:../Generated_Code/tasks.c **** 			taskENTER_CRITICAL();
 751              		.loc 1 985 0
 752 0016 FFF7FEFF 		bl	vPortEnterCritical
 753              	.LVL77:
 987:../Generated_Code/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 754              		.loc 1 987 0
 755 001a 201C     		mov	r0, r4
 756 001c FFF7FEFF 		bl	xTaskIsTaskSuspended
 757              	.LVL78:
 758 0020 0128     		cmp	r0, #1
 759 0022 17D1     		bne	.L71
 993:../Generated_Code/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 760              		.loc 1 993 0
 761 0024 251D     		add	r5, r4, #4
 762 0026 281C     		mov	r0, r5
 763 0028 FFF7FEFF 		bl	vListRemove
 764              	.LVL79:
 994:../Generated_Code/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 765              		.loc 1 994 0
 766 002c 0C4A     		ldr	r2, .L74+4
 767 002e E36A     		ldr	r3, [r4, #44]
 768 0030 1168     		ldr	r1, [r2]
 769 0032 8B42     		cmp	r3, r1
 770 0034 00D9     		bls	.L72
 994:../Generated_Code/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 771              		.loc 1 994 0 is_stmt 0
 772 0036 1360     		str	r3, [r2]
 773              	.L72:
 994:../Generated_Code/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 774              		.loc 1 994 0
 775 0038 1420     		mov	r0, #20
 776 003a 4343     		mul	r3, r0
 777 003c 094A     		ldr	r2, .L74+8
 778 003e 291C     		mov	r1, r5
 779 0040 D018     		add	r0, r2, r3
 780 0042 FFF7FEFF 		bl	vListInsertEnd
 781              	.LVL80:
 997:../Generated_Code/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 782              		.loc 1 997 0 is_stmt 1
 783 0046 3668     		ldr	r6, [r6]
 784 0048 E46A     		ldr	r4, [r4, #44]
 785              	.LVL81:
 786 004a F56A     		ldr	r5, [r6, #44]
 787              	.LVL82:
 788 004c AC42     		cmp	r4, r5
 789 004e 01D3     		bcc	.L71
1001:../Generated_Code/tasks.c **** 						portYIELD_WITHIN_API();
 790              		.loc 1 1001 0
 791 0050 FFF7FEFF 		bl	vPortYieldFromISR
 792              	.LVL83:
 793              	.L71:
1005:../Generated_Code/tasks.c **** 			taskEXIT_CRITICAL();
 794              		.loc 1 1005 0
 795 0054 FFF7FEFF 		bl	vPortExitCritical
 796              	.LVL84:
 797              	.L66:
1007:../Generated_Code/tasks.c **** 	}
 798              		.loc 1 1007 0
 799              		@ sp needed for prologue
 800 0058 70BD     		pop	{r4, r5, r6, pc}
 801              	.L75:
 802 005a C046     		.align	2
 803              	.L74:
 804 005c 00000000 		.word	.LANCHOR1
 805 0060 00000000 		.word	.LANCHOR14
 806 0064 00000000 		.word	.LANCHOR0
 807              		.cfi_endproc
 808              	.LFE7:
 810              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 811              		.align	1
 812              		.global	xTaskResumeFromISR
 813              		.code	16
 814              		.thumb_func
 816              	xTaskResumeFromISR:
 817              	.LFB8:
1016:../Generated_Code/tasks.c **** 	{
 818              		.loc 1 1016 0
 819              		.cfi_startproc
 820              	.LVL85:
 821 0000 70B5     		push	{r4, r5, r6, lr}
 822              	.LCFI7:
 823              		.cfi_def_cfa_offset 16
 824              		.cfi_offset 4, -16
 825              		.cfi_offset 5, -12
 826              		.cfi_offset 6, -8
 827              		.cfi_offset 14, -4
1016:../Generated_Code/tasks.c **** 	{
 828              		.loc 1 1016 0
 829 0002 041C     		mov	r4, r0
1021:../Generated_Code/tasks.c **** 		configASSERT( pxTaskToResume );
 830              		.loc 1 1021 0
 831              	@ 1021 "../Generated_Code/tasks.c" 1
 832 0004 5020     		  mov r0, #80 
 833 0006 80F31188 	  msr basepri, r0 
 834              	
 835              	@ 0 "" 2
 836              	.LVL86:
 837              		.code	16
 838 000a 002C     		cmp	r4, #0
 839 000c 00D1     		bne	.L77
 840              	.L78:
 841 000e FEE7     		b	.L78
 842              	.L77:
 843              	.LVL87:
1027:../Generated_Code/tasks.c **** 			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 844              		.loc 1 1027 0
 845 0010 201C     		mov	r0, r4
 846 0012 FFF7FEFF 		bl	xTaskIsTaskSuspended
 847              	.LVL88:
1017:../Generated_Code/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 848              		.loc 1 1017 0
 849 0016 0025     		mov	r5, #0
1027:../Generated_Code/tasks.c **** 			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 850              		.loc 1 1027 0
 851 0018 0128     		cmp	r0, #1
 852 001a 1ED1     		bne	.L79
1031:../Generated_Code/tasks.c **** 				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 853              		.loc 1 1031 0
 854 001c 114B     		ldr	r3, .L84
 855 001e 1868     		ldr	r0, [r3]
 856 0020 A842     		cmp	r0, r5
 857 0022 15D1     		bne	.L80
1033:../Generated_Code/tasks.c **** 					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 858              		.loc 1 1033 0
 859 0024 1049     		ldr	r1, .L84+4
 860 0026 E36A     		ldr	r3, [r4, #44]
 861 0028 0A68     		ldr	r2, [r1]
 862 002a D66A     		ldr	r6, [r2, #44]
 863 002c B342     		cmp	r3, r6
 864 002e 6D41     		adc	r5, r5, r5
 865              	.LVL89:
1034:../Generated_Code/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 866              		.loc 1 1034 0
 867 0030 261D     		add	r6, r4, #4
 868 0032 301C     		mov	r0, r6
 869 0034 FFF7FEFF 		bl	vListRemove
 870              	.LVL90:
1035:../Generated_Code/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 871              		.loc 1 1035 0
 872 0038 0C48     		ldr	r0, .L84+8
 873 003a E46A     		ldr	r4, [r4, #44]
 874              	.LVL91:
 875 003c 0168     		ldr	r1, [r0]
 876 003e 8C42     		cmp	r4, r1
 877 0040 00D9     		bls	.L81
1035:../Generated_Code/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 878              		.loc 1 1035 0 is_stmt 0
 879 0042 0460     		str	r4, [r0]
 880              	.L81:
1035:../Generated_Code/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 881              		.loc 1 1035 0
 882 0044 1422     		mov	r2, #20
 883 0046 5443     		mul	r4, r2
 884 0048 094B     		ldr	r3, .L84+12
 885 004a 311C     		mov	r1, r6
 886 004c 1819     		add	r0, r3, r4
 887 004e 02E0     		b	.L83
 888              	.LVL92:
 889              	.L80:
1042:../Generated_Code/tasks.c **** 					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 890              		.loc 1 1042 0 is_stmt 1
 891 0050 211C     		mov	r1, r4
 892 0052 0848     		ldr	r0, .L84+16
 893 0054 1831     		add	r1, r1, #24
 894              	.LVL93:
 895              	.L83:
 896 0056 FFF7FEFF 		bl	vListInsertEnd
 897              	.LVL94:
 898              	.L79:
1046:../Generated_Code/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 899              		.loc 1 1046 0
 900              	@ 1046 "../Generated_Code/tasks.c" 1
 901 005a 0020     		  mov r0, #0      
 902 005c 80F31188 	  msr basepri, r0 
 903              	
 904              	@ 0 "" 2
1049:../Generated_Code/tasks.c **** 	}
 905              		.loc 1 1049 0
 906              		.code	16
 907 0060 281C     		mov	r0, r5
 908              		@ sp needed for prologue
 909              	.LVL95:
 910 0062 70BD     		pop	{r4, r5, r6, pc}
 911              	.L85:
 912              		.align	2
 913              	.L84:
 914 0064 00000000 		.word	.LANCHOR15
 915 0068 00000000 		.word	.LANCHOR1
 916 006c 00000000 		.word	.LANCHOR14
 917 0070 00000000 		.word	.LANCHOR0
 918 0074 00000000 		.word	.LANCHOR9
 919              		.cfi_endproc
 920              	.LFE8:
 922              		.section	.text.vTaskStartScheduler,"ax",%progbits
 923              		.align	1
 924              		.global	vTaskStartScheduler
 925              		.code	16
 926              		.thumb_func
 928              	vTaskStartScheduler:
 929              	.LFB9:
1062:../Generated_Code/tasks.c **** {
 930              		.loc 1 1062 0
 931              		.cfi_startproc
 932 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 933              	.LCFI8:
 934              		.cfi_def_cfa_offset 24
 935              		.cfi_offset 0, -24
 936              		.cfi_offset 1, -20
 937              		.cfi_offset 2, -16
 938              		.cfi_offset 3, -12
 939              		.cfi_offset 4, -8
 940              		.cfi_offset 14, -4
1075:../Generated_Code/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 941              		.loc 1 1075 0
 942 0002 0024     		mov	r4, #0
 943 0004 231C     		mov	r3, r4
 944 0006 0094     		str	r4, [sp]
 945 0008 0194     		str	r4, [sp, #4]
 946 000a 0294     		str	r4, [sp, #8]
 947 000c 0394     		str	r4, [sp, #12]
 948 000e 0C48     		ldr	r0, .L90
 949 0010 0C49     		ldr	r1, .L90+4
 950 0012 6422     		mov	r2, #100
 951 0014 FFF7FEFF 		bl	xTaskGenericCreate
 952              	.LVL96:
 953 0018 031E     		sub	r3, r0, #0
 954              	.LVL97:
1088:../Generated_Code/tasks.c **** 	if( xReturn == pdPASS )
 955              		.loc 1 1088 0
 956 001a 012B     		cmp	r3, #1
 957 001c 09D1     		bne	.L87
1098:../Generated_Code/tasks.c **** 		portDISABLE_INTERRUPTS();
 958              		.loc 1 1098 0
 959              	@ 1098 "../Generated_Code/tasks.c" 1
 960 001e 5020     		  mov r0, #80 
 961 0020 80F31188 	  msr basepri, r0 
 962              	
 963              	@ 0 "" 2
 964              	.LVL98:
1100:../Generated_Code/tasks.c **** 		xSchedulerRunning = pdTRUE;
 965              		.loc 1 1100 0
 966              		.code	16
 967 0024 084A     		ldr	r2, .L90+8
1101:../Generated_Code/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 968              		.loc 1 1101 0
 969 0026 0948     		ldr	r0, .L90+12
1100:../Generated_Code/tasks.c **** 		xSchedulerRunning = pdTRUE;
 970              		.loc 1 1100 0
 971 0028 1360     		str	r3, [r2]
1101:../Generated_Code/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 972              		.loc 1 1101 0
 973 002a 0460     		str	r4, [r0]
1110:../Generated_Code/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 974              		.loc 1 1110 0
 975 002c FFF7FEFF 		bl	xPortStartScheduler
 976              	.LVL99:
 977 0030 05E0     		b	.L86
 978              	.LVL100:
 979              	.L87:
1122:../Generated_Code/tasks.c **** 	configASSERT( xReturn );
 980              		.loc 1 1122 0
 981 0032 0028     		cmp	r0, #0
 982 0034 03D1     		bne	.L86
1122:../Generated_Code/tasks.c **** 	configASSERT( xReturn );
 983              		.loc 1 1122 0 is_stmt 0
 984              	@ 1122 "../Generated_Code/tasks.c" 1
 985 0036 5020     		  mov r0, #80 
 986 0038 80F31188 	  msr basepri, r0 
 987              	
 988              	@ 0 "" 2
 989              	.LVL101:
 990              		.code	16
 991              	.L89:
 992 003c FEE7     		b	.L89
 993              	.LVL102:
 994              	.L86:
1123:../Generated_Code/tasks.c **** }
 995              		.loc 1 1123 0 is_stmt 1
 996              		@ sp needed for prologue
 997 003e 1FBD     		pop	{r0, r1, r2, r3, r4, pc}
 998              	.L91:
 999              		.align	2
 1000              	.L90:
 1001 0040 00000000 		.word	prvIdleTask
 1002 0044 00000000 		.word	.LC34
 1003 0048 00000000 		.word	.LANCHOR11
 1004 004c 00000000 		.word	.LANCHOR2
 1005              		.cfi_endproc
 1006              	.LFE9:
 1008              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1009              		.align	1
 1010              		.global	vTaskSuspendAll
 1011              		.code	16
 1012              		.thumb_func
 1014              	vTaskSuspendAll:
 1015              	.LFB10:
1127:../Generated_Code/tasks.c **** {
 1016              		.loc 1 1127 0
 1017              		.cfi_startproc
1130:../Generated_Code/tasks.c **** 	++uxSchedulerSuspended;
 1018              		.loc 1 1130 0
 1019 0000 024B     		ldr	r3, .L93
1131:../Generated_Code/tasks.c **** }
 1020              		.loc 1 1131 0
 1021              		@ sp needed for prologue
1130:../Generated_Code/tasks.c **** 	++uxSchedulerSuspended;
 1022              		.loc 1 1130 0
 1023 0002 1A68     		ldr	r2, [r3]
 1024 0004 0132     		add	r2, r2, #1
 1025 0006 1A60     		str	r2, [r3]
1131:../Generated_Code/tasks.c **** }
 1026              		.loc 1 1131 0
 1027 0008 7047     		bx	lr
 1028              	.L94:
 1029 000a C046     		.align	2
 1030              	.L93:
 1031 000c 00000000 		.word	.LANCHOR15
 1032              		.cfi_endproc
 1033              	.LFE10:
 1035              		.section	.text.xTaskGetTickCount,"ax",%progbits
 1036              		.align	1
 1037              		.global	xTaskGetTickCount
 1038              		.code	16
 1039              		.thumb_func
 1041              	xTaskGetTickCount:
 1042              	.LFB12:
1222:../Generated_Code/tasks.c **** {
 1043              		.loc 1 1222 0
 1044              		.cfi_startproc
 1045 0000 10B5     		push	{r4, lr}
 1046              	.LCFI9:
 1047              		.cfi_def_cfa_offset 8
 1048              		.cfi_offset 4, -8
 1049              		.cfi_offset 14, -4
1226:../Generated_Code/tasks.c **** 	taskENTER_CRITICAL();
 1050              		.loc 1 1226 0
 1051 0002 FFF7FEFF 		bl	vPortEnterCritical
 1052              	.LVL103:
1228:../Generated_Code/tasks.c **** 		xTicks = xTickCount;
 1053              		.loc 1 1228 0
 1054 0006 034B     		ldr	r3, .L96
1233:../Generated_Code/tasks.c **** }
 1055              		.loc 1 1233 0
 1056              		@ sp needed for prologue
1228:../Generated_Code/tasks.c **** 		xTicks = xTickCount;
 1057              		.loc 1 1228 0
 1058 0008 1C68     		ldr	r4, [r3]
 1059              	.LVL104:
1230:../Generated_Code/tasks.c **** 	taskEXIT_CRITICAL();
 1060              		.loc 1 1230 0
 1061 000a FFF7FEFF 		bl	vPortExitCritical
 1062              	.LVL105:
1233:../Generated_Code/tasks.c **** }
 1063              		.loc 1 1233 0
 1064 000e 201C     		mov	r0, r4
 1065              	.LVL106:
 1066 0010 10BD     		pop	{r4, pc}
 1067              	.L97:
 1068 0012 C046     		.align	2
 1069              	.L96:
 1070 0014 00000000 		.word	.LANCHOR2
 1071              		.cfi_endproc
 1072              	.LFE12:
 1074              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1075              		.align	1
 1076              		.global	xTaskGetTickCountFromISR
 1077              		.code	16
 1078              		.thumb_func
 1080              	xTaskGetTickCountFromISR:
 1081              	.LFB13:
1237:../Generated_Code/tasks.c **** {
 1082              		.loc 1 1237 0
 1083              		.cfi_startproc
 1084              	.LVL107:
1241:../Generated_Code/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1085              		.loc 1 1241 0
 1086              	@ 1241 "../Generated_Code/tasks.c" 1
 1087 0000 5020     		  mov r0, #80 
 1088 0002 80F31188 	  msr basepri, r0 
 1089              	
 1090              	@ 0 "" 2
1242:../Generated_Code/tasks.c **** 	xReturn = xTickCount;
 1091              		.loc 1 1242 0
 1092              		.code	16
 1093 0006 034B     		ldr	r3, .L99
 1094 0008 1968     		ldr	r1, [r3]
 1095              	.LVL108:
1243:../Generated_Code/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1096              		.loc 1 1243 0
 1097              	@ 1243 "../Generated_Code/tasks.c" 1
 1098 000a 0020     		  mov r0, #0      
 1099 000c 80F31188 	  msr basepri, r0 
 1100              	
 1101              	@ 0 "" 2
1246:../Generated_Code/tasks.c **** }
 1102              		.loc 1 1246 0
 1103              		.code	16
 1104 0010 081C     		mov	r0, r1
 1105              		@ sp needed for prologue
 1106 0012 7047     		bx	lr
 1107              	.L100:
 1108              		.align	2
 1109              	.L99:
 1110 0014 00000000 		.word	.LANCHOR2
 1111              		.cfi_endproc
 1112              	.LFE13:
 1114              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 1115              		.align	1
 1116              		.global	uxTaskGetNumberOfTasks
 1117              		.code	16
 1118              		.thumb_func
 1120              	uxTaskGetNumberOfTasks:
 1121              	.LFB14:
1250:../Generated_Code/tasks.c **** {
 1122              		.loc 1 1250 0
 1123              		.cfi_startproc
1253:../Generated_Code/tasks.c **** 	return uxCurrentNumberOfTasks;
 1124              		.loc 1 1253 0
 1125 0000 014B     		ldr	r3, .L102
1254:../Generated_Code/tasks.c **** }
 1126              		.loc 1 1254 0
 1127              		@ sp needed for prologue
1253:../Generated_Code/tasks.c **** 	return uxCurrentNumberOfTasks;
 1128              		.loc 1 1253 0
 1129 0002 1868     		ldr	r0, [r3]
1254:../Generated_Code/tasks.c **** }
 1130              		.loc 1 1254 0
 1131 0004 7047     		bx	lr
 1132              	.L103:
 1133 0006 C046     		.align	2
 1134              	.L102:
 1135 0008 00000000 		.word	.LANCHOR6
 1136              		.cfi_endproc
 1137              	.LFE14:
 1139              		.section	.text.vTaskIncrementTick,"ax",%progbits
 1140              		.align	1
 1141              		.global	vTaskIncrementTick
 1142              		.code	16
 1143              		.thumb_func
 1145              	vTaskIncrementTick:
 1146              	.LFB15:
1425:../Generated_Code/tasks.c **** {
 1147              		.loc 1 1425 0
 1148              		.cfi_startproc
 1149 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1150              	.LCFI10:
 1151              		.cfi_def_cfa_offset 24
 1152              		.cfi_offset 3, -24
 1153              		.cfi_offset 4, -20
 1154              		.cfi_offset 5, -16
 1155              		.cfi_offset 6, -12
 1156              		.cfi_offset 7, -8
 1157              		.cfi_offset 14, -4
1431:../Generated_Code/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1158              		.loc 1 1431 0
 1159 0002 334B     		ldr	r3, .L123
 1160 0004 1868     		ldr	r0, [r3]
 1161 0006 0028     		cmp	r0, #0
 1162 0008 55D1     		bne	.L105
1433:../Generated_Code/tasks.c **** 		++xTickCount;
 1163              		.loc 1 1433 0
 1164 000a 324C     		ldr	r4, .L123+4
 1165 000c 2568     		ldr	r5, [r4]
 1166 000e 261C     		mov	r6, r4
 1167 0010 0135     		add	r5, r5, #1
 1168 0012 2560     		str	r5, [r4]
1434:../Generated_Code/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
 1169              		.loc 1 1434 0
 1170 0014 2768     		ldr	r7, [r4]
 1171 0016 002F     		cmp	r7, #0
 1172 0018 1ED1     		bne	.L106
 1173              	.LBB38:
1441:../Generated_Code/tasks.c **** 			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
 1174              		.loc 1 1441 0
 1175 001a 2F4B     		ldr	r3, .L123+8
 1176 001c 1868     		ldr	r0, [r3]
 1177 001e 0168     		ldr	r1, [r0]
 1178 0020 0029     		cmp	r1, #0
 1179 0022 03D0     		beq	.L107
1441:../Generated_Code/tasks.c **** 			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
 1180              		.loc 1 1441 0 is_stmt 0
 1181              	@ 1441 "../Generated_Code/tasks.c" 1
 1182 0024 5020     		  mov r0, #80 
 1183 0026 80F31188 	  msr basepri, r0 
 1184              	
 1185              	@ 0 "" 2
 1186              		.code	16
 1187              	.L108:
 1188 002a FEE7     		b	.L108
 1189              	.L107:
1444:../Generated_Code/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 1190              		.loc 1 1444 0 is_stmt 1
 1191 002c 2B4A     		ldr	r2, .L123+12
1443:../Generated_Code/tasks.c **** 			pxTemp = pxDelayedTaskList;
 1192              		.loc 1 1443 0
 1193 002e 1C68     		ldr	r4, [r3]
 1194              	.LVL109:
1444:../Generated_Code/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 1195              		.loc 1 1444 0
 1196 0030 1568     		ldr	r5, [r2]
1446:../Generated_Code/tasks.c **** 			xNumOfOverflows++;
 1197              		.loc 1 1446 0
 1198 0032 2B4F     		ldr	r7, .L123+16
1444:../Generated_Code/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 1199              		.loc 1 1444 0
 1200 0034 1D60     		str	r5, [r3]
1445:../Generated_Code/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 1201              		.loc 1 1445 0
 1202 0036 1460     		str	r4, [r2]
1446:../Generated_Code/tasks.c **** 			xNumOfOverflows++;
 1203              		.loc 1 1446 0
 1204 0038 3868     		ldr	r0, [r7]
 1205 003a 2A4A     		ldr	r2, .L123+20
 1206 003c 0130     		add	r0, r0, #1
 1207 003e 3860     		str	r0, [r7]
1448:../Generated_Code/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 1208              		.loc 1 1448 0
 1209 0040 1968     		ldr	r1, [r3]
 1210 0042 0C68     		ldr	r4, [r1]
 1211              	.LVL110:
 1212 0044 002C     		cmp	r4, #0
 1213 0046 02D1     		bne	.L109
1455:../Generated_Code/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;
 1214              		.loc 1 1455 0
 1215 0048 0121     		mov	r1, #1
 1216 004a 4842     		neg	r0, r1
 1217 004c 03E0     		b	.L121
 1218              	.L109:
1463:../Generated_Code/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 1219              		.loc 1 1463 0
 1220 004e 1B68     		ldr	r3, [r3]
 1221 0050 DD68     		ldr	r5, [r3, #12]
 1222 0052 EF68     		ldr	r7, [r5, #12]
 1223              	.LVL111:
1464:../Generated_Code/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 1224              		.loc 1 1464 0
 1225 0054 7868     		ldr	r0, [r7, #4]
 1226              	.LVL112:
 1227              	.L121:
 1228 0056 1060     		str	r0, [r2]
 1229              	.LVL113:
 1230              	.L106:
 1231              	.LBE38:
 1232              	.LBB39:
1469:../Generated_Code/tasks.c **** 		prvCheckDelayedTasks();
 1233              		.loc 1 1469 0
 1234 0058 224F     		ldr	r7, .L123+20
 1235 005a 3468     		ldr	r4, [r6]
 1236 005c 3A68     		ldr	r2, [r7]
 1237 005e 9442     		cmp	r4, r2
 1238 0060 2FD3     		bcc	.L110
 1239              	.L120:
1469:../Generated_Code/tasks.c **** 		prvCheckDelayedTasks();
 1240              		.loc 1 1469 0 is_stmt 0
 1241 0062 1D4B     		ldr	r3, .L123+8
 1242 0064 1D68     		ldr	r5, [r3]
 1243 0066 2868     		ldr	r0, [r5]
 1244 0068 0028     		cmp	r0, #0
 1245 006a 02D1     		bne	.L111
1469:../Generated_Code/tasks.c **** 		prvCheckDelayedTasks();
 1246              		.loc 1 1469 0
 1247 006c 0126     		mov	r6, #1
 1248 006e 7342     		neg	r3, r6
 1249 0070 06E0     		b	.L122
 1250              	.L111:
1469:../Generated_Code/tasks.c **** 		prvCheckDelayedTasks();
 1251              		.loc 1 1469 0
 1252 0072 1968     		ldr	r1, [r3]
 1253 0074 CC68     		ldr	r4, [r1, #12]
 1254 0076 E468     		ldr	r4, [r4, #12]
 1255              	.LVL114:
 1256 0078 3268     		ldr	r2, [r6]
 1257 007a 6368     		ldr	r3, [r4, #4]
 1258              	.LVL115:
 1259 007c 9A42     		cmp	r2, r3
 1260 007e 01D2     		bcs	.L112
 1261              	.LVL116:
 1262              	.L122:
1469:../Generated_Code/tasks.c **** 		prvCheckDelayedTasks();
 1263              		.loc 1 1469 0
 1264 0080 3B60     		str	r3, [r7]
 1265 0082 1EE0     		b	.L110
 1266              	.LVL117:
 1267              	.L112:
1469:../Generated_Code/tasks.c **** 		prvCheckDelayedTasks();
 1268              		.loc 1 1469 0
 1269 0084 251D     		add	r5, r4, #4
 1270 0086 281C     		mov	r0, r5
 1271 0088 FFF7FEFF 		bl	vListRemove
 1272              	.LVL118:
 1273 008c A06A     		ldr	r0, [r4, #40]
 1274 008e 0028     		cmp	r0, #0
 1275 0090 03D0     		beq	.L113
1469:../Generated_Code/tasks.c **** 		prvCheckDelayedTasks();
 1276              		.loc 1 1469 0
 1277 0092 201C     		mov	r0, r4
 1278 0094 1830     		add	r0, r0, #24
 1279 0096 FFF7FEFF 		bl	vListRemove
 1280              	.LVL119:
 1281              	.L113:
1469:../Generated_Code/tasks.c **** 		prvCheckDelayedTasks();
 1282              		.loc 1 1469 0
 1283 009a 134B     		ldr	r3, .L123+24
 1284 009c E46A     		ldr	r4, [r4, #44]
 1285              	.LVL120:
 1286 009e 1968     		ldr	r1, [r3]
 1287 00a0 8C42     		cmp	r4, r1
 1288 00a2 00D9     		bls	.L114
1469:../Generated_Code/tasks.c **** 		prvCheckDelayedTasks();
 1289              		.loc 1 1469 0
 1290 00a4 1C60     		str	r4, [r3]
 1291              	.L114:
1469:../Generated_Code/tasks.c **** 		prvCheckDelayedTasks();
 1292              		.loc 1 1469 0
 1293 00a6 1422     		mov	r2, #20
 1294 00a8 5443     		mul	r4, r2
 1295 00aa 1048     		ldr	r0, .L123+28
 1296 00ac 291C     		mov	r1, r5
 1297 00ae 0019     		add	r0, r0, r4
 1298 00b0 FFF7FEFF 		bl	vListInsertEnd
 1299              	.LVL121:
 1300 00b4 D5E7     		b	.L120
 1301              	.LVL122:
 1302              	.L105:
 1303              	.LBE39:
1473:../Generated_Code/tasks.c **** 		++uxMissedTicks;
 1304              		.loc 1 1473 0 is_stmt 1
 1305 00b6 0E49     		ldr	r1, .L123+32
 1306 00b8 0A68     		ldr	r2, [r1]
 1307 00ba 0132     		add	r2, r2, #1
 1308 00bc 0A60     		str	r2, [r1]
1479:../Generated_Code/tasks.c ****       FRTOS1_vApplicationTickHook();
 1309              		.loc 1 1479 0
 1310 00be FFF7FEFF 		bl	FRTOS1_vApplicationTickHook
 1311              	.LVL123:
 1312              	.L110:
1488:../Generated_Code/tasks.c **** 		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
 1313              		.loc 1 1488 0
 1314 00c2 0B4F     		ldr	r7, .L123+32
 1315 00c4 3D68     		ldr	r5, [r7]
 1316 00c6 002D     		cmp	r5, #0
 1317 00c8 01D1     		bne	.L104
1491:../Generated_Code/tasks.c ****         FRTOS1_vApplicationTickHook();
 1318              		.loc 1 1491 0
 1319 00ca FFF7FEFF 		bl	FRTOS1_vApplicationTickHook
 1320              	.LVL124:
 1321              	.L104:
1497:../Generated_Code/tasks.c **** }
 1322              		.loc 1 1497 0
 1323              		@ sp needed for prologue
 1324 00ce F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1325              	.L124:
 1326              		.align	2
 1327              	.L123:
 1328 00d0 00000000 		.word	.LANCHOR15
 1329 00d4 00000000 		.word	.LANCHOR2
 1330 00d8 00000000 		.word	.LANCHOR4
 1331 00dc 00000000 		.word	.LANCHOR3
 1332 00e0 00000000 		.word	.LANCHOR16
 1333 00e4 00000000 		.word	.LANCHOR5
 1334 00e8 00000000 		.word	.LANCHOR14
 1335 00ec 00000000 		.word	.LANCHOR0
 1336 00f0 00000000 		.word	.LANCHOR17
 1337              		.cfi_endproc
 1338              	.LFE15:
 1340              		.section	.text.xTaskResumeAll,"ax",%progbits
 1341              		.align	1
 1342              		.global	xTaskResumeAll
 1343              		.code	16
 1344              		.thumb_func
 1346              	xTaskResumeAll:
 1347              	.LFB11:
1135:../Generated_Code/tasks.c **** {
 1348              		.loc 1 1135 0
 1349              		.cfi_startproc
 1350              	.LVL125:
 1351 0000 70B5     		push	{r4, r5, r6, lr}
 1352              	.LCFI11:
 1353              		.cfi_def_cfa_offset 16
 1354              		.cfi_offset 4, -16
 1355              		.cfi_offset 5, -12
 1356              		.cfi_offset 6, -8
 1357              		.cfi_offset 14, -4
1141:../Generated_Code/tasks.c **** 	configASSERT( uxSchedulerSuspended );
 1358              		.loc 1 1141 0
 1359 0002 2C4C     		ldr	r4, .L156
 1360 0004 2368     		ldr	r3, [r4]
 1361 0006 002B     		cmp	r3, #0
 1362 0008 03D1     		bne	.L126
1141:../Generated_Code/tasks.c **** 	configASSERT( uxSchedulerSuspended );
 1363              		.loc 1 1141 0 is_stmt 0
 1364              	@ 1141 "../Generated_Code/tasks.c" 1
 1365 000a 5020     		  mov r0, #80 
 1366 000c 80F31188 	  msr basepri, r0 
 1367              	
 1368              	@ 0 "" 2
 1369              		.code	16
 1370              	.L127:
 1371 0010 FEE7     		b	.L127
 1372              	.L126:
1148:../Generated_Code/tasks.c **** 	taskENTER_CRITICAL();
 1373              		.loc 1 1148 0 is_stmt 1
 1374 0012 FFF7FEFF 		bl	vPortEnterCritical
 1375              	.LVL126:
1150:../Generated_Code/tasks.c **** 		--uxSchedulerSuspended;
 1376              		.loc 1 1150 0
 1377 0016 2068     		ldr	r0, [r4]
 1378 0018 0138     		sub	r0, r0, #1
 1379 001a 2060     		str	r0, [r4]
1152:../Generated_Code/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1380              		.loc 1 1152 0
 1381 001c 2568     		ldr	r5, [r4]
 1382 001e 002D     		cmp	r5, #0
 1383 0020 01D0     		beq	.L128
 1384              	.L131:
1137:../Generated_Code/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 1385              		.loc 1 1137 0
 1386 0022 0024     		mov	r4, #0
 1387 0024 41E0     		b	.L129
 1388              	.L128:
1154:../Generated_Code/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 1389              		.loc 1 1154 0
 1390 0026 2449     		ldr	r1, .L156+4
 1391 0028 0A68     		ldr	r2, [r1]
 1392 002a 002A     		cmp	r2, #0
 1393 002c F9D0     		beq	.L131
 1394              	.L151:
 1395              	.LBB40:
1160:../Generated_Code/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 1396              		.loc 1 1160 0
 1397 002e 234E     		ldr	r6, .L156+8
 1398 0030 3468     		ldr	r4, [r6]
 1399 0032 002C     		cmp	r4, #0
 1400 0034 1ED0     		beq	.L153
 1401              	.L134:
1162:../Generated_Code/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 1402              		.loc 1 1162 0
 1403 0036 F068     		ldr	r0, [r6, #12]
 1404 0038 C468     		ldr	r4, [r0, #12]
 1405              	.LVL127:
1163:../Generated_Code/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 1406              		.loc 1 1163 0
 1407 003a 201C     		mov	r0, r4
 1408 003c 1830     		add	r0, r0, #24
1164:../Generated_Code/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1409              		.loc 1 1164 0
 1410 003e 261D     		add	r6, r4, #4
1163:../Generated_Code/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 1411              		.loc 1 1163 0
 1412 0040 FFF7FEFF 		bl	vListRemove
 1413              	.LVL128:
1164:../Generated_Code/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1414              		.loc 1 1164 0
 1415 0044 301C     		mov	r0, r6
 1416 0046 FFF7FEFF 		bl	vListRemove
 1417              	.LVL129:
1165:../Generated_Code/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1418              		.loc 1 1165 0
 1419 004a 1D4A     		ldr	r2, .L156+12
 1420 004c E36A     		ldr	r3, [r4, #44]
 1421 004e 1168     		ldr	r1, [r2]
 1422 0050 8B42     		cmp	r3, r1
 1423 0052 00D9     		bls	.L132
1165:../Generated_Code/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1424              		.loc 1 1165 0 is_stmt 0
 1425 0054 1360     		str	r3, [r2]
 1426              	.L132:
1165:../Generated_Code/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1427              		.loc 1 1165 0
 1428 0056 1420     		mov	r0, #20
 1429 0058 4343     		mul	r3, r0
 1430 005a 1A4A     		ldr	r2, .L156+16
 1431 005c 311C     		mov	r1, r6
 1432 005e D018     		add	r0, r2, r3
 1433 0060 FFF7FEFF 		bl	vListInsertEnd
 1434              	.LVL130:
1169:../Generated_Code/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1435              		.loc 1 1169 0 is_stmt 1
 1436 0064 184E     		ldr	r6, .L156+20
 1437 0066 E46A     		ldr	r4, [r4, #44]
 1438              	.LVL131:
 1439 0068 3368     		ldr	r3, [r6]
 1440 006a D96A     		ldr	r1, [r3, #44]
 1441 006c 8C42     		cmp	r4, r1
 1442 006e DED3     		bcc	.L151
1171:../Generated_Code/tasks.c **** 						xYieldRequired = pdTRUE;
 1443              		.loc 1 1171 0
 1444 0070 0125     		mov	r5, #1
 1445 0072 DCE7     		b	.L151
 1446              	.L153:
1178:../Generated_Code/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1447              		.loc 1 1178 0
 1448 0074 154E     		ldr	r6, .L156+24
 1449 0076 3368     		ldr	r3, [r6]
 1450 0078 002B     		cmp	r3, #0
 1451 007a 08D0     		beq	.L154
 1452              	.L148:
1180:../Generated_Code/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 1453              		.loc 1 1180 0
 1454 007c 3168     		ldr	r1, [r6]
 1455 007e 0029     		cmp	r1, #0
 1456 0080 07D0     		beq	.L138
 1457              	.L137:
1182:../Generated_Code/tasks.c **** 						vTaskIncrementTick();
 1458              		.loc 1 1182 0
 1459 0082 FFF7FEFF 		bl	vTaskIncrementTick
 1460              	.LVL132:
1183:../Generated_Code/tasks.c **** 						--uxMissedTicks;
 1461              		.loc 1 1183 0
 1462 0086 3368     		ldr	r3, [r6]
 1463 0088 013B     		sub	r3, r3, #1
 1464 008a 3360     		str	r3, [r6]
 1465 008c F6E7     		b	.L148
 1466              	.L154:
 1467              	.LVL133:
1196:../Generated_Code/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1468              		.loc 1 1196 0
 1469 008e 012D     		cmp	r5, #1
 1470 0090 06D1     		bne	.L155
 1471              	.LVL134:
 1472              	.L138:
1199:../Generated_Code/tasks.c **** 					xMissedYield = pdFALSE;
 1473              		.loc 1 1199 0
 1474 0092 0F4E     		ldr	r6, .L156+28
 1475 0094 0022     		mov	r2, #0
 1476 0096 3260     		str	r2, [r6]
1198:../Generated_Code/tasks.c **** 					xAlreadyYielded = pdTRUE;
 1477              		.loc 1 1198 0
 1478 0098 0124     		mov	r4, #1
1200:../Generated_Code/tasks.c **** 					portYIELD_WITHIN_API();
 1479              		.loc 1 1200 0
 1480 009a FFF7FEFF 		bl	vPortYieldFromISR
 1481              	.LVL135:
 1482 009e 04E0     		b	.L129
 1483              	.LVL136:
 1484              	.L155:
1196:../Generated_Code/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1485              		.loc 1 1196 0
 1486 00a0 0B4D     		ldr	r5, .L156+28
 1487              	.LVL137:
 1488 00a2 2868     		ldr	r0, [r5]
 1489 00a4 0128     		cmp	r0, #1
 1490 00a6 BCD1     		bne	.L131
 1491 00a8 F3E7     		b	.L138
 1492              	.LVL138:
 1493              	.L129:
 1494              	.LBE40:
1205:../Generated_Code/tasks.c **** 	taskEXIT_CRITICAL();
 1495              		.loc 1 1205 0
 1496 00aa FFF7FEFF 		bl	vPortExitCritical
 1497              	.LVL139:
1208:../Generated_Code/tasks.c **** }
 1498              		.loc 1 1208 0
 1499              		@ sp needed for prologue
 1500 00ae 201C     		mov	r0, r4
 1501              	.LVL140:
 1502 00b0 70BD     		pop	{r4, r5, r6, pc}
 1503              	.L157:
 1504 00b2 C046     		.align	2
 1505              	.L156:
 1506 00b4 00000000 		.word	.LANCHOR15
 1507 00b8 00000000 		.word	.LANCHOR6
 1508 00bc 00000000 		.word	.LANCHOR9
 1509 00c0 00000000 		.word	.LANCHOR14
 1510 00c4 00000000 		.word	.LANCHOR0
 1511 00c8 00000000 		.word	.LANCHOR1
 1512 00cc 00000000 		.word	.LANCHOR17
 1513 00d0 00000000 		.word	.LANCHOR18
 1514              		.cfi_endproc
 1515              	.LFE11:
 1517              		.section	.text.vTaskDelay,"ax",%progbits
 1518              		.align	1
 1519              		.global	vTaskDelay
 1520              		.code	16
 1521              		.thumb_func
 1523              	vTaskDelay:
 1524              	.LFB2:
 697:../Generated_Code/tasks.c **** 	{
 1525              		.loc 1 697 0
 1526              		.cfi_startproc
 1527              	.LVL141:
 1528 0000 10B5     		push	{r4, lr}
 1529              	.LCFI12:
 1530              		.cfi_def_cfa_offset 8
 1531              		.cfi_offset 4, -8
 1532              		.cfi_offset 14, -4
 697:../Generated_Code/tasks.c **** 	{
 1533              		.loc 1 697 0
 1534 0002 041E     		sub	r4, r0, #0
 702:../Generated_Code/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 1535              		.loc 1 702 0
 1536 0004 02D1     		bne	.L159
 1537              	.LVL142:
 1538              	.L161:
 733:../Generated_Code/tasks.c **** 			portYIELD_WITHIN_API();
 1539              		.loc 1 733 0
 1540 0006 FFF7FEFF 		bl	vPortYieldFromISR
 1541              	.LVL143:
 1542 000a 10E0     		b	.L158
 1543              	.LVL144:
 1544              	.L159:
 704:../Generated_Code/tasks.c **** 			vTaskSuspendAll();
 1545              		.loc 1 704 0
 1546 000c FFF7FEFF 		bl	vTaskSuspendAll
 1547              	.LVL145:
 718:../Generated_Code/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 1548              		.loc 1 718 0
 1549 0010 074B     		ldr	r3, .L165
 723:../Generated_Code/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 1550              		.loc 1 723 0
 1551 0012 0849     		ldr	r1, .L165+4
 718:../Generated_Code/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 1552              		.loc 1 718 0
 1553 0014 1868     		ldr	r0, [r3]
 1554 0016 2418     		add	r4, r4, r0
 1555              	.LVL146:
 723:../Generated_Code/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 1556              		.loc 1 723 0
 1557 0018 0868     		ldr	r0, [r1]
 1558 001a 0430     		add	r0, r0, #4
 1559 001c FFF7FEFF 		bl	vListRemove
 1560              	.LVL147:
 724:../Generated_Code/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 1561              		.loc 1 724 0
 1562 0020 201C     		mov	r0, r4
 1563 0022 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 1564              	.LVL148:
 726:../Generated_Code/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 1565              		.loc 1 726 0
 1566 0026 FFF7FEFF 		bl	xTaskResumeAll
 1567              	.LVL149:
 731:../Generated_Code/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 1568              		.loc 1 731 0
 1569 002a 0028     		cmp	r0, #0
 1570 002c EBD0     		beq	.L161
 1571              	.LVL150:
 1572              	.L158:
 735:../Generated_Code/tasks.c **** 	}
 1573              		.loc 1 735 0
 1574              		@ sp needed for prologue
 1575 002e 10BD     		pop	{r4, pc}
 1576              	.L166:
 1577              		.align	2
 1578              	.L165:
 1579 0030 00000000 		.word	.LANCHOR2
 1580 0034 00000000 		.word	.LANCHOR1
 1581              		.cfi_endproc
 1582              	.LFE2:
 1584              		.section	.text.vTaskDelayUntil,"ax",%progbits
 1585              		.align	1
 1586              		.global	vTaskDelayUntil
 1587              		.code	16
 1588              		.thumb_func
 1590              	vTaskDelayUntil:
 1591              	.LFB1:
 632:../Generated_Code/tasks.c **** 	{
 1592              		.loc 1 632 0
 1593              		.cfi_startproc
 1594              	.LVL151:
 1595 0000 38B5     		push	{r3, r4, r5, lr}
 1596              	.LCFI13:
 1597              		.cfi_def_cfa_offset 16
 1598              		.cfi_offset 3, -16
 1599              		.cfi_offset 4, -12
 1600              		.cfi_offset 5, -8
 1601              		.cfi_offset 14, -4
 632:../Generated_Code/tasks.c **** 	{
 1602              		.loc 1 632 0
 1603 0002 051C     		mov	r5, r0
 1604 0004 0C1C     		mov	r4, r1
 636:../Generated_Code/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 1605              		.loc 1 636 0
 1606 0006 0028     		cmp	r0, #0
 1607 0008 03D1     		bne	.L168
 636:../Generated_Code/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 1608              		.loc 1 636 0 is_stmt 0
 1609              	@ 636 "../Generated_Code/tasks.c" 1
 1610 000a 5020     		  mov r0, #80 
 1611 000c 80F31188 	  msr basepri, r0 
 1612              	
 1613              	@ 0 "" 2
 1614              	.LVL152:
 1615              		.code	16
 1616              	.L169:
 1617 0010 FEE7     		b	.L169
 1618              	.LVL153:
 1619              	.L168:
 637:../Generated_Code/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 1620              		.loc 1 637 0 is_stmt 1
 1621 0012 0029     		cmp	r1, #0
 1622 0014 03D1     		bne	.L170
 637:../Generated_Code/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 1623              		.loc 1 637 0 is_stmt 0
 1624              	@ 637 "../Generated_Code/tasks.c" 1
 1625 0016 5020     		  mov r0, #80 
 1626 0018 80F31188 	  msr basepri, r0 
 1627              	
 1628              	@ 0 "" 2
 1629              	.LVL154:
 1630              		.code	16
 1631              	.L171:
 1632 001c FEE7     		b	.L171
 1633              	.LVL155:
 1634              	.L170:
 639:../Generated_Code/tasks.c **** 		vTaskSuspendAll();
 1635              		.loc 1 639 0 is_stmt 1
 1636 001e FFF7FEFF 		bl	vTaskSuspendAll
 1637              	.LVL156:
 644:../Generated_Code/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 1638              		.loc 1 644 0
 1639 0022 1149     		ldr	r1, .L182
 642:../Generated_Code/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 1640              		.loc 1 642 0
 1641 0024 2A68     		ldr	r2, [r5]
 644:../Generated_Code/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 1642              		.loc 1 644 0
 1643 0026 0B68     		ldr	r3, [r1]
 642:../Generated_Code/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 1644              		.loc 1 642 0
 1645 0028 1419     		add	r4, r2, r4
 1646              	.LVL157:
 644:../Generated_Code/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 1647              		.loc 1 644 0
 1648 002a 9342     		cmp	r3, r2
 1649 002c 03D2     		bcs	.L172
 634:../Generated_Code/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 1650              		.loc 1 634 0
 1651 002e 0023     		mov	r3, #0
 651:../Generated_Code/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 1652              		.loc 1 651 0
 1653 0030 9442     		cmp	r4, r2
 1654 0032 07D2     		bcs	.L173
 1655 0034 02E0     		b	.L181
 1656              	.L172:
 663:../Generated_Code/tasks.c **** 					xShouldDelay = pdTRUE;
 1657              		.loc 1 663 0
 1658 0036 0123     		mov	r3, #1
 661:../Generated_Code/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 1659              		.loc 1 661 0
 1660 0038 9442     		cmp	r4, r2
 1661 003a 03D3     		bcc	.L173
 1662              	.L181:
 661:../Generated_Code/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 1663              		.loc 1 661 0 is_stmt 0
 1664 003c 0868     		ldr	r0, [r1]
 1665 003e A042     		cmp	r0, r4
 1666 0040 9241     		sbc	r2, r2, r2
 1667 0042 5342     		neg	r3, r2
 1668              	.L173:
 1669              	.LVL158:
 668:../Generated_Code/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 1670              		.loc 1 668 0 is_stmt 1
 1671 0044 2C60     		str	r4, [r5]
 670:../Generated_Code/tasks.c **** 			if( xShouldDelay != pdFALSE )
 1672              		.loc 1 670 0
 1673 0046 002B     		cmp	r3, #0
 1674 0048 07D0     		beq	.L174
 677:../Generated_Code/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 1675              		.loc 1 677 0
 1676 004a 084D     		ldr	r5, .L182+4
 1677              	.LVL159:
 1678 004c 2868     		ldr	r0, [r5]
 1679 004e 0430     		add	r0, r0, #4
 1680 0050 FFF7FEFF 		bl	vListRemove
 1681              	.LVL160:
 678:../Generated_Code/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 1682              		.loc 1 678 0
 1683 0054 201C     		mov	r0, r4
 1684 0056 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 1685              	.LVL161:
 1686              	.L174:
 681:../Generated_Code/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 1687              		.loc 1 681 0
 1688 005a FFF7FEFF 		bl	xTaskResumeAll
 1689              	.LVL162:
 685:../Generated_Code/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 1690              		.loc 1 685 0
 1691 005e 0028     		cmp	r0, #0
 1692 0060 01D1     		bne	.L167
 687:../Generated_Code/tasks.c **** 			portYIELD_WITHIN_API();
 1693              		.loc 1 687 0
 1694 0062 FFF7FEFF 		bl	vPortYieldFromISR
 1695              	.LVL163:
 1696              	.L167:
 689:../Generated_Code/tasks.c **** 	}
 1697              		.loc 1 689 0
 1698              		@ sp needed for prologue
 1699              	.LVL164:
 1700 0066 38BD     		pop	{r3, r4, r5, pc}
 1701              	.L183:
 1702              		.align	2
 1703              	.L182:
 1704 0068 00000000 		.word	.LANCHOR2
 1705 006c 00000000 		.word	.LANCHOR1
 1706              		.cfi_endproc
 1707              	.LFE1:
 1709              		.section	.text.vTaskSwitchContext,"ax",%progbits
 1710              		.align	1
 1711              		.global	vTaskSwitchContext
 1712              		.code	16
 1713              		.thumb_func
 1715              	vTaskSwitchContext:
 1716              	.LFB16:
1588:../Generated_Code/tasks.c **** {
 1717              		.loc 1 1588 0
 1718              		.cfi_startproc
1589:../Generated_Code/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 1719              		.loc 1 1589 0
 1720 0000 1B4B     		ldr	r3, .L195
1588:../Generated_Code/tasks.c **** {
 1721              		.loc 1 1588 0
 1722 0002 10B5     		push	{r4, lr}
 1723              	.LCFI14:
 1724              		.cfi_def_cfa_offset 8
 1725              		.cfi_offset 4, -8
 1726              		.cfi_offset 14, -4
1589:../Generated_Code/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 1727              		.loc 1 1589 0
 1728 0004 1868     		ldr	r0, [r3]
 1729 0006 0028     		cmp	r0, #0
 1730 0008 03D0     		beq	.L185
1593:../Generated_Code/tasks.c **** 		xMissedYield = pdTRUE;
 1731              		.loc 1 1593 0
 1732 000a 1A48     		ldr	r0, .L195+4
 1733 000c 0122     		mov	r2, #1
 1734 000e 0260     		str	r2, [r0]
 1735 0010 2DE0     		b	.L184
 1736              	.L185:
1619:../Generated_Code/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 1737              		.loc 1 1619 0
 1738 0012 194C     		ldr	r4, .L195+8
 1739 0014 2268     		ldr	r2, [r4]
 1740 0016 2168     		ldr	r1, [r4]
 1741 0018 1068     		ldr	r0, [r2]
 1742 001a 0B6B     		ldr	r3, [r1, #48]
 1743 001c 9842     		cmp	r0, r3
 1744 001e 08D8     		bhi	.L193
1619:../Generated_Code/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 1745              		.loc 1 1619 0 is_stmt 0
 1746 0020 2068     		ldr	r0, [r4]
 1747 0022 2168     		ldr	r1, [r4]
 1748 0024 3431     		add	r1, r1, #52
 1749 0026 FFF7FEFF 		bl	FRTOS1_vApplicationStackOverflowHook
 1750              	.LVL165:
 1751 002a 02E0     		b	.L193
 1752              	.L189:
1626:../Generated_Code/tasks.c **** 			--uxTopReadyPriority;
 1753              		.loc 1 1626 0 is_stmt 1
 1754 002c 1368     		ldr	r3, [r2]
 1755 002e 013B     		sub	r3, r3, #1
 1756 0030 1360     		str	r3, [r2]
 1757              	.L193:
1623:../Generated_Code/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 1758              		.loc 1 1623 0
 1759 0032 124A     		ldr	r2, .L195+12
 1760 0034 1423     		mov	r3, #20
 1761 0036 1068     		ldr	r0, [r2]
 1762 0038 1149     		ldr	r1, .L195+16
 1763 003a 5843     		mul	r0, r3
 1764 003c 4058     		ldr	r0, [r0, r1]
 1765 003e 0028     		cmp	r0, #0
 1766 0040 06D1     		bne	.L194
 1767              	.L191:
1625:../Generated_Code/tasks.c **** 			configASSERT( uxTopReadyPriority );
 1768              		.loc 1 1625 0
 1769 0042 1168     		ldr	r1, [r2]
 1770 0044 0029     		cmp	r1, #0
 1771 0046 F1D1     		bne	.L189
1625:../Generated_Code/tasks.c **** 			configASSERT( uxTopReadyPriority );
 1772              		.loc 1 1625 0 is_stmt 0
 1773              	@ 1625 "../Generated_Code/tasks.c" 1
 1774 0048 5020     		  mov r0, #80 
 1775 004a 80F31188 	  msr basepri, r0 
 1776              	
 1777              	@ 0 "" 2
 1778              		.code	16
 1779              	.L190:
 1780 004e FEE7     		b	.L190
 1781              	.L194:
 1782              	.LBB41:
1631:../Generated_Code/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 1783              		.loc 1 1631 0 is_stmt 1
 1784 0050 1268     		ldr	r2, [r2]
 1785 0052 5343     		mul	r3, r2
 1786 0054 CB18     		add	r3, r1, r3
 1787              	.LVL166:
 1788 0056 5968     		ldr	r1, [r3, #4]
 1789 0058 1A1C     		mov	r2, r3
 1790 005a 4868     		ldr	r0, [r1, #4]
 1791 005c 0832     		add	r2, r2, #8
 1792 005e 5860     		str	r0, [r3, #4]
 1793 0060 9042     		cmp	r0, r2
 1794 0062 01D1     		bne	.L192
1631:../Generated_Code/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 1795              		.loc 1 1631 0 is_stmt 0
 1796 0064 4168     		ldr	r1, [r0, #4]
 1797 0066 5960     		str	r1, [r3, #4]
 1798              	.L192:
1631:../Generated_Code/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 1799              		.loc 1 1631 0
 1800 0068 5B68     		ldr	r3, [r3, #4]
 1801              	.LVL167:
 1802 006a D868     		ldr	r0, [r3, #12]
 1803 006c 2060     		str	r0, [r4]
 1804              	.LVL168:
 1805              	.L184:
 1806              	.LBE41:
1635:../Generated_Code/tasks.c **** }
 1807              		.loc 1 1635 0 is_stmt 1
 1808              		@ sp needed for prologue
 1809 006e 10BD     		pop	{r4, pc}
 1810              	.L196:
 1811              		.align	2
 1812              	.L195:
 1813 0070 00000000 		.word	.LANCHOR15
 1814 0074 00000000 		.word	.LANCHOR18
 1815 0078 00000000 		.word	.LANCHOR1
 1816 007c 00000000 		.word	.LANCHOR14
 1817 0080 00000000 		.word	.LANCHOR0
 1818              		.cfi_endproc
 1819              	.LFE16:
 1821              		.section	.text.vTaskSuspend,"ax",%progbits
 1822              		.align	1
 1823              		.global	vTaskSuspend
 1824              		.code	16
 1825              		.thumb_func
 1827              	vTaskSuspend:
 1828              	.LFB5:
 873:../Generated_Code/tasks.c **** 	{
 1829              		.loc 1 873 0
 1830              		.cfi_startproc
 1831              	.LVL169:
 1832 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1833              	.LCFI15:
 1834              		.cfi_def_cfa_offset 24
 1835              		.cfi_offset 3, -24
 1836              		.cfi_offset 4, -20
 1837              		.cfi_offset 5, -16
 1838              		.cfi_offset 6, -12
 1839              		.cfi_offset 7, -8
 1840              		.cfi_offset 14, -4
 873:../Generated_Code/tasks.c **** 	{
 1841              		.loc 1 873 0
 1842 0002 041C     		mov	r4, r0
 876:../Generated_Code/tasks.c **** 		taskENTER_CRITICAL();
 1843              		.loc 1 876 0
 1844 0004 FFF7FEFF 		bl	vPortEnterCritical
 1845              	.LVL170:
 880:../Generated_Code/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 1846              		.loc 1 880 0
 1847 0008 164E     		ldr	r6, .L208
 1848 000a 3368     		ldr	r3, [r6]
 1849 000c 9C42     		cmp	r4, r3
 1850 000e 01D0     		beq	.L198
 886:../Generated_Code/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 1851              		.loc 1 886 0
 1852 0010 251E     		sub	r5, r4, #0
 1853 0012 01D1     		bne	.L199
 1854              	.L198:
 886:../Generated_Code/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 1855              		.loc 1 886 0 is_stmt 0
 1856 0014 3568     		ldr	r5, [r6]
 1857 0016 0024     		mov	r4, #0
 1858              	.LVL171:
 1859              	.L199:
 891:../Generated_Code/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 1860              		.loc 1 891 0 is_stmt 1
 1861 0018 2F1D     		add	r7, r5, #4
 1862 001a 381C     		mov	r0, r7
 1863 001c FFF7FEFF 		bl	vListRemove
 1864              	.LVL172:
 894:../Generated_Code/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 1865              		.loc 1 894 0
 1866 0020 A86A     		ldr	r0, [r5, #40]
 1867 0022 0028     		cmp	r0, #0
 1868 0024 03D0     		beq	.L200
 896:../Generated_Code/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 1869              		.loc 1 896 0
 1870 0026 281C     		mov	r0, r5
 1871 0028 1830     		add	r0, r0, #24
 1872 002a FFF7FEFF 		bl	vListRemove
 1873              	.LVL173:
 1874              	.L200:
 899:../Generated_Code/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 1875              		.loc 1 899 0
 1876 002e 0E4D     		ldr	r5, .L208+4
 1877              	.LVL174:
 1878 0030 391C     		mov	r1, r7
 1879 0032 281C     		mov	r0, r5
 1880 0034 FFF7FEFF 		bl	vListInsertEnd
 1881              	.LVL175:
 901:../Generated_Code/tasks.c **** 		taskEXIT_CRITICAL();
 1882              		.loc 1 901 0
 1883 0038 FFF7FEFF 		bl	vPortExitCritical
 1884              	.LVL176:
 903:../Generated_Code/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 1885              		.loc 1 903 0
 1886 003c 002C     		cmp	r4, #0
 1887 003e 0FD1     		bne	.L197
 905:../Generated_Code/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1888              		.loc 1 905 0
 1889 0040 0A49     		ldr	r1, .L208+8
 1890 0042 0A68     		ldr	r2, [r1]
 1891 0044 002A     		cmp	r2, #0
 1892 0046 02D0     		beq	.L202
 908:../Generated_Code/tasks.c **** 				portYIELD_WITHIN_API();
 1893              		.loc 1 908 0
 1894 0048 FFF7FEFF 		bl	vPortYieldFromISR
 1895              	.LVL177:
 1896 004c 08E0     		b	.L197
 1897              	.L202:
 915:../Generated_Code/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 1898              		.loc 1 915 0
 1899 004e 084B     		ldr	r3, .L208+12
 1900 0050 2F68     		ldr	r7, [r5]
 1901              	.LVL178:
 1902 0052 1868     		ldr	r0, [r3]
 1903 0054 8742     		cmp	r7, r0
 1904 0056 01D1     		bne	.L203
 921:../Generated_Code/tasks.c **** 					pxCurrentTCB = NULL;
 1905              		.loc 1 921 0
 1906 0058 3460     		str	r4, [r6]
 1907 005a 01E0     		b	.L197
 1908              	.L203:
 925:../Generated_Code/tasks.c **** 					vTaskSwitchContext();
 1909              		.loc 1 925 0
 1910 005c FFF7FEFF 		bl	vTaskSwitchContext
 1911              	.LVL179:
 1912              	.L197:
 929:../Generated_Code/tasks.c **** 	}
 1913              		.loc 1 929 0
 1914              		@ sp needed for prologue
 1915 0060 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1916              	.L209:
 1917 0062 C046     		.align	2
 1918              	.L208:
 1919 0064 00000000 		.word	.LANCHOR1
 1920 0068 00000000 		.word	.LANCHOR10
 1921 006c 00000000 		.word	.LANCHOR11
 1922 0070 00000000 		.word	.LANCHOR6
 1923              		.cfi_endproc
 1924              	.LFE5:
 1926              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 1927              		.align	1
 1928              		.global	vTaskPlaceOnEventList
 1929              		.code	16
 1930              		.thumb_func
 1932              	vTaskPlaceOnEventList:
 1933              	.LFB17:
1639:../Generated_Code/tasks.c **** {
 1934              		.loc 1 1639 0
 1935              		.cfi_startproc
 1936              	.LVL180:
 1937 0000 38B5     		push	{r3, r4, r5, lr}
 1938              	.LCFI16:
 1939              		.cfi_def_cfa_offset 16
 1940              		.cfi_offset 3, -16
 1941              		.cfi_offset 4, -12
 1942              		.cfi_offset 5, -8
 1943              		.cfi_offset 14, -4
1639:../Generated_Code/tasks.c **** {
 1944              		.loc 1 1639 0
 1945 0002 0D1C     		mov	r5, r1
1642:../Generated_Code/tasks.c **** 	configASSERT( pxEventList );
 1946              		.loc 1 1642 0
 1947 0004 0028     		cmp	r0, #0
 1948 0006 03D1     		bne	.L211
1642:../Generated_Code/tasks.c **** 	configASSERT( pxEventList );
 1949              		.loc 1 1642 0 is_stmt 0
 1950              	@ 1642 "../Generated_Code/tasks.c" 1
 1951 0008 5020     		  mov r0, #80 
 1952 000a 80F31188 	  msr basepri, r0 
 1953              	
 1954              	@ 0 "" 2
 1955              	.LVL181:
 1956              		.code	16
 1957              	.L212:
 1958 000e FEE7     		b	.L212
 1959              	.LVL182:
 1960              	.L211:
1650:../Generated_Code/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 1961              		.loc 1 1650 0 is_stmt 1
 1962 0010 0B4C     		ldr	r4, .L215
 1963 0012 2168     		ldr	r1, [r4]
 1964              	.LVL183:
 1965 0014 1831     		add	r1, r1, #24
 1966 0016 FFF7FEFF 		bl	vListInsert
 1967              	.LVL184:
1655:../Generated_Code/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 1968              		.loc 1 1655 0
 1969 001a 2068     		ldr	r0, [r4]
 1970 001c 0430     		add	r0, r0, #4
 1971 001e FFF7FEFF 		bl	vListRemove
 1972              	.LVL185:
1660:../Generated_Code/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 1973              		.loc 1 1660 0
 1974 0022 6B1C     		add	r3, r5, #1
 1975 0024 05D1     		bne	.L213
1665:../Generated_Code/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 1976              		.loc 1 1665 0
 1977 0026 2168     		ldr	r1, [r4]
 1978 0028 0648     		ldr	r0, .L215+4
 1979 002a 0431     		add	r1, r1, #4
 1980 002c FFF7FEFF 		bl	vListInsertEnd
 1981              	.LVL186:
 1982 0030 04E0     		b	.L210
 1983              	.L213:
1671:../Generated_Code/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 1984              		.loc 1 1671 0
 1985 0032 054B     		ldr	r3, .L215+8
 1986 0034 1868     		ldr	r0, [r3]
 1987              	.LVL187:
 1988 0036 2818     		add	r0, r5, r0
 1989              	.LVL188:
1672:../Generated_Code/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 1990              		.loc 1 1672 0
 1991 0038 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 1992              	.LVL189:
 1993              	.L210:
1683:../Generated_Code/tasks.c **** }
 1994              		.loc 1 1683 0
 1995              		@ sp needed for prologue
 1996              	.LVL190:
 1997 003c 38BD     		pop	{r3, r4, r5, pc}
 1998              	.L216:
 1999 003e C046     		.align	2
 2000              	.L215:
 2001 0040 00000000 		.word	.LANCHOR1
 2002 0044 00000000 		.word	.LANCHOR10
 2003 0048 00000000 		.word	.LANCHOR2
 2004              		.cfi_endproc
 2005              	.LFE17:
 2007              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2008              		.align	1
 2009              		.global	xTaskRemoveFromEventList
 2010              		.code	16
 2011              		.thumb_func
 2013              	xTaskRemoveFromEventList:
 2014              	.LFB18:
1721:../Generated_Code/tasks.c **** {
 2015              		.loc 1 1721 0
 2016              		.cfi_startproc
 2017              	.LVL191:
 2018 0000 38B5     		push	{r3, r4, r5, lr}
 2019              	.LCFI17:
 2020              		.cfi_def_cfa_offset 16
 2021              		.cfi_offset 3, -16
 2022              		.cfi_offset 4, -12
 2023              		.cfi_offset 5, -8
 2024              		.cfi_offset 14, -4
1738:../Generated_Code/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2025              		.loc 1 1738 0
 2026 0002 C368     		ldr	r3, [r0, #12]
 2027 0004 DC68     		ldr	r4, [r3, #12]
 2028              	.LVL192:
1739:../Generated_Code/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2029              		.loc 1 1739 0
 2030 0006 002C     		cmp	r4, #0
 2031 0008 03D1     		bne	.L218
1739:../Generated_Code/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2032              		.loc 1 1739 0 is_stmt 0
 2033              	@ 1739 "../Generated_Code/tasks.c" 1
 2034 000a 5020     		  mov r0, #80 
 2035 000c 80F31188 	  msr basepri, r0 
 2036              	
 2037              	@ 0 "" 2
 2038              	.LVL193:
 2039              		.code	16
 2040              	.L219:
 2041 0010 FEE7     		b	.L219
 2042              	.LVL194:
 2043              	.L218:
1740:../Generated_Code/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2044              		.loc 1 1740 0 is_stmt 1
 2045 0012 251C     		mov	r5, r4
 2046 0014 1835     		add	r5, r5, #24
 2047 0016 281C     		mov	r0, r5
 2048              	.LVL195:
 2049 0018 FFF7FEFF 		bl	vListRemove
 2050              	.LVL196:
1742:../Generated_Code/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2051              		.loc 1 1742 0
 2052 001c 0F48     		ldr	r0, .L224
 2053 001e 0168     		ldr	r1, [r0]
 2054 0020 0029     		cmp	r1, #0
 2055 0022 0ED1     		bne	.L220
1744:../Generated_Code/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2056              		.loc 1 1744 0
 2057 0024 251D     		add	r5, r4, #4
 2058 0026 281C     		mov	r0, r5
 2059 0028 FFF7FEFF 		bl	vListRemove
 2060              	.LVL197:
1745:../Generated_Code/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2061              		.loc 1 1745 0
 2062 002c 0C4A     		ldr	r2, .L224+4
 2063 002e E36A     		ldr	r3, [r4, #44]
 2064 0030 1068     		ldr	r0, [r2]
 2065 0032 8342     		cmp	r3, r0
 2066 0034 00D9     		bls	.L221
1745:../Generated_Code/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2067              		.loc 1 1745 0 is_stmt 0
 2068 0036 1360     		str	r3, [r2]
 2069              	.L221:
1745:../Generated_Code/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2070              		.loc 1 1745 0
 2071 0038 1421     		mov	r1, #20
 2072 003a 4B43     		mul	r3, r1
 2073 003c 094A     		ldr	r2, .L224+8
 2074 003e D018     		add	r0, r2, r3
 2075 0040 00E0     		b	.L223
 2076              	.L220:
1751:../Generated_Code/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2077              		.loc 1 1751 0 is_stmt 1
 2078 0042 0948     		ldr	r0, .L224+12
 2079              	.L223:
 2080 0044 291C     		mov	r1, r5
 2081 0046 FFF7FEFF 		bl	vListInsertEnd
 2082              	.LVL198:
1754:../Generated_Code/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2083              		.loc 1 1754 0
 2084 004a 084D     		ldr	r5, .L224+16
 2085 004c E46A     		ldr	r4, [r4, #44]
 2086              	.LVL199:
 2087 004e 2B68     		ldr	r3, [r5]
 2088 0050 0020     		mov	r0, #0
 2089 0052 D96A     		ldr	r1, [r3, #44]
1768:../Generated_Code/tasks.c **** }
 2090              		.loc 1 1768 0
 2091              		@ sp needed for prologue
1754:../Generated_Code/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2092              		.loc 1 1754 0
 2093 0054 8C42     		cmp	r4, r1
 2094 0056 4041     		adc	r0, r0, r0
1768:../Generated_Code/tasks.c **** }
 2095              		.loc 1 1768 0
 2096 0058 38BD     		pop	{r3, r4, r5, pc}
 2097              	.L225:
 2098 005a C046     		.align	2
 2099              	.L224:
 2100 005c 00000000 		.word	.LANCHOR15
 2101 0060 00000000 		.word	.LANCHOR14
 2102 0064 00000000 		.word	.LANCHOR0
 2103 0068 00000000 		.word	.LANCHOR9
 2104 006c 00000000 		.word	.LANCHOR1
 2105              		.cfi_endproc
 2106              	.LFE18:
 2108              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 2109              		.align	1
 2110              		.global	vTaskSetTimeOutState
 2111              		.code	16
 2112              		.thumb_func
 2114              	vTaskSetTimeOutState:
 2115              	.LFB19:
1772:../Generated_Code/tasks.c **** {
 2116              		.loc 1 1772 0
 2117              		.cfi_startproc
 2118              	.LVL200:
 2119 0000 00B5     		push	{lr}
 2120              	.LCFI18:
 2121              		.cfi_def_cfa_offset 4
 2122              		.cfi_offset 14, -4
1773:../Generated_Code/tasks.c **** 	configASSERT( pxTimeOut );
 2123              		.loc 1 1773 0
 2124 0002 0028     		cmp	r0, #0
 2125 0004 03D1     		bne	.L227
1773:../Generated_Code/tasks.c **** 	configASSERT( pxTimeOut );
 2126              		.loc 1 1773 0 is_stmt 0
 2127              	@ 1773 "../Generated_Code/tasks.c" 1
 2128 0006 5020     		  mov r0, #80 
 2129 0008 80F31188 	  msr basepri, r0 
 2130              	
 2131              	@ 0 "" 2
 2132              	.LVL201:
 2133              		.code	16
 2134              	.L228:
 2135 000c FEE7     		b	.L228
 2136              	.LVL202:
 2137              	.L227:
1774:../Generated_Code/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2138              		.loc 1 1774 0 is_stmt 1
 2139 000e 034B     		ldr	r3, .L229
1775:../Generated_Code/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2140              		.loc 1 1775 0
 2141 0010 034A     		ldr	r2, .L229+4
1774:../Generated_Code/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2142              		.loc 1 1774 0
 2143 0012 1968     		ldr	r1, [r3]
1775:../Generated_Code/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2144              		.loc 1 1775 0
 2145 0014 1368     		ldr	r3, [r2]
1774:../Generated_Code/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2146              		.loc 1 1774 0
 2147 0016 0160     		str	r1, [r0]
1775:../Generated_Code/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2148              		.loc 1 1775 0
 2149 0018 4360     		str	r3, [r0, #4]
1776:../Generated_Code/tasks.c **** }
 2150              		.loc 1 1776 0
 2151              		@ sp needed for prologue
 2152 001a 00BD     		pop	{pc}
 2153              	.L230:
 2154              		.align	2
 2155              	.L229:
 2156 001c 00000000 		.word	.LANCHOR16
 2157 0020 00000000 		.word	.LANCHOR2
 2158              		.cfi_endproc
 2159              	.LFE19:
 2161              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 2162              		.align	1
 2163              		.global	xTaskCheckForTimeOut
 2164              		.code	16
 2165              		.thumb_func
 2167              	xTaskCheckForTimeOut:
 2168              	.LFB20:
1780:../Generated_Code/tasks.c **** {
 2169              		.loc 1 1780 0
 2170              		.cfi_startproc
 2171              	.LVL203:
 2172 0000 70B5     		push	{r4, r5, r6, lr}
 2173              	.LCFI19:
 2174              		.cfi_def_cfa_offset 16
 2175              		.cfi_offset 4, -16
 2176              		.cfi_offset 5, -12
 2177              		.cfi_offset 6, -8
 2178              		.cfi_offset 14, -4
1780:../Generated_Code/tasks.c **** {
 2179              		.loc 1 1780 0
 2180 0002 051C     		mov	r5, r0
 2181 0004 0E1C     		mov	r6, r1
1783:../Generated_Code/tasks.c **** 	configASSERT( pxTimeOut );
 2182              		.loc 1 1783 0
 2183 0006 0028     		cmp	r0, #0
 2184 0008 03D1     		bne	.L232
1783:../Generated_Code/tasks.c **** 	configASSERT( pxTimeOut );
 2185              		.loc 1 1783 0 is_stmt 0
 2186              	@ 1783 "../Generated_Code/tasks.c" 1
 2187 000a 5020     		  mov r0, #80 
 2188 000c 80F31188 	  msr basepri, r0 
 2189              	
 2190              	@ 0 "" 2
 2191              	.LVL204:
 2192              		.code	16
 2193              	.L233:
 2194 0010 FEE7     		b	.L233
 2195              	.LVL205:
 2196              	.L232:
1784:../Generated_Code/tasks.c **** 	configASSERT( pxTicksToWait );
 2197              		.loc 1 1784 0 is_stmt 1
 2198 0012 0029     		cmp	r1, #0
 2199 0014 03D1     		bne	.L234
1784:../Generated_Code/tasks.c **** 	configASSERT( pxTicksToWait );
 2200              		.loc 1 1784 0 is_stmt 0
 2201              	@ 1784 "../Generated_Code/tasks.c" 1
 2202 0016 5020     		  mov r0, #80 
 2203 0018 80F31188 	  msr basepri, r0 
 2204              	
 2205              	@ 0 "" 2
 2206              	.LVL206:
 2207              		.code	16
 2208              	.L235:
 2209 001c FEE7     		b	.L235
 2210              	.LVL207:
 2211              	.L234:
1786:../Generated_Code/tasks.c **** 	taskENTER_CRITICAL();
 2212              		.loc 1 1786 0 is_stmt 1
 2213 001e FFF7FEFF 		bl	vPortEnterCritical
 2214              	.LVL208:
1792:../Generated_Code/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 2215              		.loc 1 1792 0
 2216 0022 3368     		ldr	r3, [r6]
 2217 0024 5A1C     		add	r2, r3, #1
 2218 0026 16D0     		beq	.L238
1799:../Generated_Code/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2219              		.loc 1 1799 0
 2220 0028 0D4A     		ldr	r2, .L241
 2221 002a 2C68     		ldr	r4, [r5]
 2222 002c 1068     		ldr	r0, [r2]
 2223 002e 0D49     		ldr	r1, .L241+4
 2224 0030 6A68     		ldr	r2, [r5, #4]
 2225 0032 A042     		cmp	r0, r4
 2226 0034 03D0     		beq	.L237
1799:../Generated_Code/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2227              		.loc 1 1799 0 is_stmt 0
 2228 0036 0868     		ldr	r0, [r1]
1805:../Generated_Code/tasks.c **** 			xReturn = pdTRUE;
 2229              		.loc 1 1805 0 is_stmt 1
 2230 0038 0124     		mov	r4, #1
1799:../Generated_Code/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2231              		.loc 1 1799 0
 2232 003a 9042     		cmp	r0, r2
 2233 003c 0CD2     		bcs	.L236
 2234              	.L237:
1807:../Generated_Code/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 2235              		.loc 1 1807 0
 2236 003e 0C68     		ldr	r4, [r1]
 2237 0040 A01A     		sub	r0, r4, r2
1805:../Generated_Code/tasks.c **** 			xReturn = pdTRUE;
 2238              		.loc 1 1805 0
 2239 0042 0124     		mov	r4, #1
1807:../Generated_Code/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 2240              		.loc 1 1807 0
 2241 0044 9842     		cmp	r0, r3
 2242 0046 07D2     		bcs	.L236
1810:../Generated_Code/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 2243              		.loc 1 1810 0
 2244 0048 0968     		ldr	r1, [r1]
1811:../Generated_Code/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2245              		.loc 1 1811 0
 2246 004a 281C     		mov	r0, r5
1810:../Generated_Code/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 2247              		.loc 1 1810 0
 2248 004c 521A     		sub	r2, r2, r1
 2249 004e D318     		add	r3, r2, r3
 2250 0050 3360     		str	r3, [r6]
1811:../Generated_Code/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2251              		.loc 1 1811 0
 2252 0052 FFF7FEFF 		bl	vTaskSetTimeOutState
 2253              	.LVL209:
 2254              	.L238:
1794:../Generated_Code/tasks.c **** 				xReturn = pdFALSE;
 2255              		.loc 1 1794 0
 2256 0056 0024     		mov	r4, #0
 2257              	.L236:
 2258              	.LVL210:
1819:../Generated_Code/tasks.c **** 	taskEXIT_CRITICAL();
 2259              		.loc 1 1819 0
 2260 0058 FFF7FEFF 		bl	vPortExitCritical
 2261              	.LVL211:
1822:../Generated_Code/tasks.c **** }
 2262              		.loc 1 1822 0
 2263              		@ sp needed for prologue
 2264 005c 201C     		mov	r0, r4
 2265              	.LVL212:
 2266              	.LVL213:
 2267              	.LVL214:
 2268 005e 70BD     		pop	{r4, r5, r6, pc}
 2269              	.L242:
 2270              		.align	2
 2271              	.L241:
 2272 0060 00000000 		.word	.LANCHOR16
 2273 0064 00000000 		.word	.LANCHOR2
 2274              		.cfi_endproc
 2275              	.LFE20:
 2277              		.section	.text.vTaskMissedYield,"ax",%progbits
 2278              		.align	1
 2279              		.global	vTaskMissedYield
 2280              		.code	16
 2281              		.thumb_func
 2283              	vTaskMissedYield:
 2284              	.LFB21:
1826:../Generated_Code/tasks.c **** {
 2285              		.loc 1 1826 0
 2286              		.cfi_startproc
1827:../Generated_Code/tasks.c **** 	xMissedYield = pdTRUE;
 2287              		.loc 1 1827 0
 2288 0000 014B     		ldr	r3, .L244
 2289 0002 0122     		mov	r2, #1
 2290 0004 1A60     		str	r2, [r3]
1828:../Generated_Code/tasks.c **** }
 2291              		.loc 1 1828 0
 2292              		@ sp needed for prologue
 2293 0006 7047     		bx	lr
 2294              	.L245:
 2295              		.align	2
 2296              	.L244:
 2297 0008 00000000 		.word	.LANCHOR18
 2298              		.cfi_endproc
 2299              	.LFE21:
 2301              		.section	.text.uxTaskGetStackHighWaterMark,"ax",%progbits
 2302              		.align	1
 2303              		.global	uxTaskGetStackHighWaterMark
 2304              		.code	16
 2305              		.thumb_func
 2307              	uxTaskGetStackHighWaterMark:
 2308              	.LFB29:
2145:../Generated_Code/tasks.c **** 		}
2146:../Generated_Code/tasks.c **** 	}
2147:../Generated_Code/tasks.c **** 
2148:../Generated_Code/tasks.c **** 	return pxNewTCB;
2149:../Generated_Code/tasks.c **** }
2150:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2151:../Generated_Code/tasks.c **** 
2152:../Generated_Code/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2153:../Generated_Code/tasks.c **** 	static void prvListTaskWithinSingleList(unsigned char *pcWriteBuffer, size_t bufSize, xList *pxLis
2154:../Generated_Code/tasks.c **** 	{
2155:../Generated_Code/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2156:../Generated_Code/tasks.c **** 	unsigned short usStackRemaining;
2157:../Generated_Code/tasks.c **** 	/* PRIVILEGED_DATA static char pcStatusString[ configMAX_TASK_NAME_LEN + 30 ]; */
2158:../Generated_Code/tasks.c **** 
2159:../Generated_Code/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2160:../Generated_Code/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2161:../Generated_Code/tasks.c **** 		do
2162:../Generated_Code/tasks.c **** 		{
2163:../Generated_Code/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2164:../Generated_Code/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2165:../Generated_Code/tasks.c **** 			{
2166:../Generated_Code/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2167:../Generated_Code/tasks.c **** 			}
2168:../Generated_Code/tasks.c **** 			#else
2169:../Generated_Code/tasks.c **** 			{
2170:../Generated_Code/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2171:../Generated_Code/tasks.c **** 			}
2172:../Generated_Code/tasks.c **** 			#endif			
2173:../Generated_Code/tasks.c ****       UTIL1_strcat(pcWriteBuffer, bufSize, (const unsigned char*)pxNextTCB->pcTaskName);
2174:../Generated_Code/tasks.c ****       UTIL1_strcat(pcWriteBuffer, bufSize, (const unsigned char*)"\t\t");
2175:../Generated_Code/tasks.c ****       UTIL1_chcat(pcWriteBuffer, bufSize, (unsigned char)cStatus);
2176:../Generated_Code/tasks.c ****       UTIL1_chcat(pcWriteBuffer, bufSize, (unsigned char)'\t');
2177:../Generated_Code/tasks.c ****       UTIL1_strcatNum32u((unsigned char*)pcWriteBuffer, bufSize, pxNextTCB->uxPriority);
2178:../Generated_Code/tasks.c ****       UTIL1_chcat(pcWriteBuffer, bufSize, (unsigned char)'\t');
2179:../Generated_Code/tasks.c ****       UTIL1_strcatNum32u(pcWriteBuffer, bufSize, usStackRemaining);
2180:../Generated_Code/tasks.c ****       UTIL1_chcat(pcWriteBuffer, bufSize, (unsigned char)'\t');
2181:../Generated_Code/tasks.c ****       UTIL1_strcatNum32u(pcWriteBuffer, bufSize, pxNextTCB->uxTCBNumber);
2182:../Generated_Code/tasks.c ****       UTIL1_strcat(pcWriteBuffer, bufSize, (const unsigned char*)"\r\n");
2183:../Generated_Code/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2184:../Generated_Code/tasks.c **** 	}
2185:../Generated_Code/tasks.c **** 
2186:../Generated_Code/tasks.c **** #endif
2187:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2188:../Generated_Code/tasks.c **** 
2189:../Generated_Code/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2190:../Generated_Code/tasks.c ****   static void prvGenerateRunTimeStatsForTasksInList(unsigned char *pcWriteBuffer, size_t bufSize, x
2191:../Generated_Code/tasks.c ****   {
2192:../Generated_Code/tasks.c ****   volatile tskTCB *pxNextTCB, *pxFirstTCB;
2193:../Generated_Code/tasks.c ****   unsigned long ulStatsAsPercentage;
2194:../Generated_Code/tasks.c **** 
2195:../Generated_Code/tasks.c ****     /* Write the run time stats of all the TCB's in pxList into the buffer. */
2196:../Generated_Code/tasks.c ****     listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2197:../Generated_Code/tasks.c ****     do
2198:../Generated_Code/tasks.c ****     {
2199:../Generated_Code/tasks.c ****       /* Get next TCB in from the list. */
2200:../Generated_Code/tasks.c ****       listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2201:../Generated_Code/tasks.c **** 
2202:../Generated_Code/tasks.c ****       /* Divide by zero check. */
2203:../Generated_Code/tasks.c ****       if( ulTotalRunTime > 0UL )
2204:../Generated_Code/tasks.c ****       {
2205:../Generated_Code/tasks.c ****         /* Has the task run at all? */
2206:../Generated_Code/tasks.c ****         if( pxNextTCB->ulRunTimeCounter == 0UL )
2207:../Generated_Code/tasks.c ****         {
2208:../Generated_Code/tasks.c ****           /* The task has used no CPU time at all. */
2209:../Generated_Code/tasks.c ****           UTIL1_strcat(pcWriteBuffer, bufSize, (const unsigned char*)pxNextTCB->pcTaskName);
2210:../Generated_Code/tasks.c ****           UTIL1_strcat(pcWriteBuffer, bufSize, (const unsigned char*)"\t\t0\t\t0%\r\n");
2211:../Generated_Code/tasks.c ****         }
2212:../Generated_Code/tasks.c ****         else
2213:../Generated_Code/tasks.c ****         {
2214:../Generated_Code/tasks.c ****           /* What percentage of the total run time has the task used?
2215:../Generated_Code/tasks.c ****           This will always be rounded down to the nearest integer.
2216:../Generated_Code/tasks.c ****           ulTotalRunTime has already been divided by 100. */
2217:../Generated_Code/tasks.c ****           ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
2218:../Generated_Code/tasks.c **** 
2219:../Generated_Code/tasks.c ****           if( ulStatsAsPercentage > 0UL )
2220:../Generated_Code/tasks.c ****           {
2221:../Generated_Code/tasks.c ****             UTIL1_strcat(pcWriteBuffer, bufSize, (const unsigned char*)pxNextTCB->pcTaskName);
2222:../Generated_Code/tasks.c ****             UTIL1_strcat(pcWriteBuffer, bufSize, (const unsigned char*)"\t\t");
2223:../Generated_Code/tasks.c ****             UTIL1_strcatNum32u(pcWriteBuffer, bufSize, pxNextTCB->ulRunTimeCounter);
2224:../Generated_Code/tasks.c ****             UTIL1_strcat(pcWriteBuffer, bufSize, (const unsigned char*)"\t\t");
2225:../Generated_Code/tasks.c ****             UTIL1_strcatNum32u(pcWriteBuffer, bufSize, ulStatsAsPercentage);
2226:../Generated_Code/tasks.c ****             UTIL1_strcat(pcWriteBuffer, bufSize, (const unsigned char*)"%\r\n");
2227:../Generated_Code/tasks.c ****           }
2228:../Generated_Code/tasks.c ****           else
2229:../Generated_Code/tasks.c ****           {
2230:../Generated_Code/tasks.c ****             /* If the percentage is zero here then the task has
2231:../Generated_Code/tasks.c ****             consumed less than 1% of the total run time. */
2232:../Generated_Code/tasks.c ****             UTIL1_strcat(pcWriteBuffer, bufSize, (const unsigned char*)pxNextTCB->pcTaskName);
2233:../Generated_Code/tasks.c ****             UTIL1_strcat(pcWriteBuffer, bufSize, (const unsigned char*)"\t\t");
2234:../Generated_Code/tasks.c ****             UTIL1_strcatNum32u(pcWriteBuffer, bufSize, pxNextTCB->ulRunTimeCounter);
2235:../Generated_Code/tasks.c ****             UTIL1_strcat(pcWriteBuffer, bufSize, (const unsigned char*)"\t\t<1%\r\n");
2236:../Generated_Code/tasks.c ****           }
2237:../Generated_Code/tasks.c ****         }
2238:../Generated_Code/tasks.c ****       }
2239:../Generated_Code/tasks.c ****     } while( pxNextTCB != pxFirstTCB );
2240:../Generated_Code/tasks.c ****   }
2241:../Generated_Code/tasks.c **** 
2242:../Generated_Code/tasks.c **** #endif
2243:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2244:../Generated_Code/tasks.c **** 
2245:../Generated_Code/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2246:../Generated_Code/tasks.c **** 
2247:../Generated_Code/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2248:../Generated_Code/tasks.c **** 	{
2249:../Generated_Code/tasks.c **** 	register unsigned short usCount = 0U;
2250:../Generated_Code/tasks.c **** 
2251:../Generated_Code/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
2252:../Generated_Code/tasks.c **** 		{
2253:../Generated_Code/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
2254:../Generated_Code/tasks.c **** 			usCount++;
2255:../Generated_Code/tasks.c **** 		}
2256:../Generated_Code/tasks.c **** 
2257:../Generated_Code/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
2258:../Generated_Code/tasks.c **** 
2259:../Generated_Code/tasks.c **** 		return usCount;
2260:../Generated_Code/tasks.c **** 	}
2261:../Generated_Code/tasks.c **** 
2262:../Generated_Code/tasks.c **** #endif
2263:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2264:../Generated_Code/tasks.c **** 
2265:../Generated_Code/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2266:../Generated_Code/tasks.c **** 
2267:../Generated_Code/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2268:../Generated_Code/tasks.c **** 	{
 2309              		.loc 1 2268 0
 2310              		.cfi_startproc
 2311              	.LVL215:
 2312 0000 00B5     		push	{lr}
 2313              	.LCFI20:
 2314              		.cfi_def_cfa_offset 4
 2315              		.cfi_offset 14, -4
2269:../Generated_Code/tasks.c **** 	tskTCB *pxTCB;
2270:../Generated_Code/tasks.c **** 	unsigned char *pcEndOfStack;
2271:../Generated_Code/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2272:../Generated_Code/tasks.c **** 
2273:../Generated_Code/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 2316              		.loc 1 2273 0
 2317 0002 0028     		cmp	r0, #0
 2318 0004 01D1     		bne	.L247
 2319              		.loc 1 2273 0 is_stmt 0
 2320 0006 064B     		ldr	r3, .L252
 2321 0008 1868     		ldr	r0, [r3]
 2322              	.LVL216:
 2323              	.L247:
2274:../Generated_Code/tasks.c **** 
2275:../Generated_Code/tasks.c **** 		#if portSTACK_GROWTH < 0
2276:../Generated_Code/tasks.c **** 		{
2277:../Generated_Code/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
 2324              		.loc 1 2277 0 is_stmt 1
 2325 000a 026B     		ldr	r2, [r0, #48]
 2326              	.LVL217:
 2327 000c 131C     		mov	r3, r2
 2328              	.LVL218:
 2329              	.L248:
 2330              	.LBB44:
 2331              	.LBB45:
2251:../Generated_Code/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 2332              		.loc 1 2251 0
 2333 000e 1978     		ldrb	r1, [r3]
2267:../Generated_Code/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
 2334              		.loc 1 2267 0
 2335 0010 981A     		sub	r0, r3, r2
 2336 0012 80B2     		uxth	r0, r0
2251:../Generated_Code/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 2337              		.loc 1 2251 0
 2338 0014 A529     		cmp	r1, #165
 2339 0016 01D1     		bne	.L251
 2340              	.L249:
2253:../Generated_Code/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 2341              		.loc 1 2253 0
 2342 0018 0133     		add	r3, r3, #1
 2343              	.LVL219:
 2344 001a F8E7     		b	.L248
 2345              	.L251:
 2346              	.LVL220:
 2347              	.LBE45:
 2348              	.LBE44:
2278:../Generated_Code/tasks.c **** 		}
2279:../Generated_Code/tasks.c **** 		#else
2280:../Generated_Code/tasks.c **** 		{
2281:../Generated_Code/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2282:../Generated_Code/tasks.c **** 		}
2283:../Generated_Code/tasks.c **** 		#endif
2284:../Generated_Code/tasks.c **** 
2285:../Generated_Code/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
 2349              		.loc 1 2285 0
 2350 001c 8008     		lsr	r0, r0, #2
 2351              	.LVL221:
2286:../Generated_Code/tasks.c **** 
2287:../Generated_Code/tasks.c **** 		return uxReturn;
2288:../Generated_Code/tasks.c **** 	}
 2352              		.loc 1 2288 0
 2353              		@ sp needed for prologue
 2354 001e 00BD     		pop	{pc}
 2355              	.L253:
 2356              		.align	2
 2357              	.L252:
 2358 0020 00000000 		.word	.LANCHOR1
 2359              		.cfi_endproc
 2360              	.LFE29:
 2362              		.section	.text.xTaskGetSchedulerState,"ax",%progbits
 2363              		.align	1
 2364              		.global	xTaskGetSchedulerState
 2365              		.code	16
 2366              		.thumb_func
 2368              	xTaskGetSchedulerState:
 2369              	.LFB30:
2289:../Generated_Code/tasks.c **** 
2290:../Generated_Code/tasks.c **** #endif
2291:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2292:../Generated_Code/tasks.c **** 
2293:../Generated_Code/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2294:../Generated_Code/tasks.c **** 
2295:../Generated_Code/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2296:../Generated_Code/tasks.c **** 	{
2297:../Generated_Code/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
2298:../Generated_Code/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
2299:../Generated_Code/tasks.c **** 		want to allocate and clean RAM statically. */
2300:../Generated_Code/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
2301:../Generated_Code/tasks.c **** 
2302:../Generated_Code/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2303:../Generated_Code/tasks.c **** 		the task to free any memory allocated at the application level. */
2304:../Generated_Code/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
2305:../Generated_Code/tasks.c **** 		vPortFree( pxTCB );
2306:../Generated_Code/tasks.c **** 	}
2307:../Generated_Code/tasks.c **** 
2308:../Generated_Code/tasks.c **** #endif
2309:../Generated_Code/tasks.c **** 
2310:../Generated_Code/tasks.c **** 
2311:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2312:../Generated_Code/tasks.c **** 
2313:../Generated_Code/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2314:../Generated_Code/tasks.c **** 
2315:../Generated_Code/tasks.c **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2316:../Generated_Code/tasks.c **** 	{
2317:../Generated_Code/tasks.c **** 	xTaskHandle xReturn;
2318:../Generated_Code/tasks.c **** 
2319:../Generated_Code/tasks.c **** 		/* A critical section is not required as this is not called from
2320:../Generated_Code/tasks.c **** 		an interrupt and the current TCB will always be the same for any
2321:../Generated_Code/tasks.c **** 		individual execution thread. */
2322:../Generated_Code/tasks.c **** 		xReturn = pxCurrentTCB;
2323:../Generated_Code/tasks.c **** 
2324:../Generated_Code/tasks.c **** 		return xReturn;
2325:../Generated_Code/tasks.c **** 	}
2326:../Generated_Code/tasks.c **** 
2327:../Generated_Code/tasks.c **** #endif
2328:../Generated_Code/tasks.c **** 
2329:../Generated_Code/tasks.c **** /*-----------------------------------------------------------*/
2330:../Generated_Code/tasks.c **** 
2331:../Generated_Code/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2332:../Generated_Code/tasks.c **** 
2333:../Generated_Code/tasks.c **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2334:../Generated_Code/tasks.c **** 	{
 2370              		.loc 1 2334 0
 2371              		.cfi_startproc
2335:../Generated_Code/tasks.c **** 	portBASE_TYPE xReturn;
2336:../Generated_Code/tasks.c **** 
2337:../Generated_Code/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
 2372              		.loc 1 2337 0
 2373 0000 054B     		ldr	r3, .L259
2338:../Generated_Code/tasks.c **** 		{
2339:../Generated_Code/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
 2374              		.loc 1 2339 0
 2375 0002 0020     		mov	r0, #0
2337:../Generated_Code/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
 2376              		.loc 1 2337 0
 2377 0004 1968     		ldr	r1, [r3]
2334:../Generated_Code/tasks.c **** 	{
 2378              		.loc 1 2334 0
 2379 0006 00B5     		push	{lr}
 2380              	.LCFI21:
 2381              		.cfi_def_cfa_offset 4
 2382              		.cfi_offset 14, -4
2337:../Generated_Code/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
 2383              		.loc 1 2337 0
 2384 0008 8142     		cmp	r1, r0
 2385 000a 04D0     		beq	.L255
2340:../Generated_Code/tasks.c **** 		}
2341:../Generated_Code/tasks.c **** 		else
2342:../Generated_Code/tasks.c **** 		{
2343:../Generated_Code/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2386              		.loc 1 2343 0
 2387 000c 0348     		ldr	r0, .L259+4
 2388 000e 0068     		ldr	r0, [r0]
2344:../Generated_Code/tasks.c **** 			{
2345:../Generated_Code/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
 2389              		.loc 1 2345 0
 2390 0010 431E     		sub	r3, r0, #1
 2391 0012 9841     		sbc	r0, r0, r3
 2392 0014 0130     		add	r0, r0, #1
 2393              	.L255:
 2394              	.LVL222:
2346:../Generated_Code/tasks.c **** 			}
2347:../Generated_Code/tasks.c **** 			else
2348:../Generated_Code/tasks.c **** 			{
2349:../Generated_Code/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
2350:../Generated_Code/tasks.c **** 			}
2351:../Generated_Code/tasks.c **** 		}
2352:../Generated_Code/tasks.c **** 
2353:../Generated_Code/tasks.c **** 		return xReturn;
2354:../Generated_Code/tasks.c **** 	}
 2395              		.loc 1 2354 0
 2396              		@ sp needed for prologue
 2397 0016 00BD     		pop	{pc}
 2398              	.L260:
 2399              		.align	2
 2400              	.L259:
 2401 0018 00000000 		.word	.LANCHOR11
 2402 001c 00000000 		.word	.LANCHOR15
 2403              		.cfi_endproc
 2404              	.LFE30:
 2406              		.global	pxCurrentTCB
 2407              		.section	.bss.uxMissedTicks,"aw",%nobits
 2408              		.align	2
 2409              		.set	.LANCHOR17,. + 0
 2412              	uxMissedTicks:
 2413 0000 00000000 		.space	4
 2414              		.section	.bss.xSuspendedTaskList,"aw",%nobits
 2415              		.align	2
 2416              		.set	.LANCHOR10,. + 0
 2419              	xSuspendedTaskList:
 2420 0000 00000000 		.space	20
 2420      00000000 
 2420      00000000 
 2420      00000000 
 2420      00000000 
 2421              		.section	.bss.pxDelayedTaskList,"aw",%nobits
 2422              		.align	2
 2423              		.set	.LANCHOR4,. + 0
 2426              	pxDelayedTaskList:
 2427 0000 00000000 		.space	4
 2428              		.section	.bss.xSchedulerRunning,"aw",%nobits
 2429              		.align	2
 2430              		.set	.LANCHOR11,. + 0
 2433              	xSchedulerRunning:
 2434 0000 00000000 		.space	4
 2435              		.section	.bss.xNumOfOverflows,"aw",%nobits
 2436              		.align	2
 2437              		.set	.LANCHOR16,. + 0
 2440              	xNumOfOverflows:
 2441 0000 00000000 		.space	4
 2442              		.section	.bss.xDelayedTaskList2,"aw",%nobits
 2443              		.align	2
 2444              		.set	.LANCHOR8,. + 0
 2447              	xDelayedTaskList2:
 2448 0000 00000000 		.space	20
 2448      00000000 
 2448      00000000 
 2448      00000000 
 2448      00000000 
 2449              		.section	.bss.pxReadyTasksLists,"aw",%nobits
 2450              		.align	2
 2451              		.set	.LANCHOR0,. + 0
 2454              	pxReadyTasksLists:
 2455 0000 00000000 		.space	20
 2455      00000000 
 2455      00000000 
 2455      00000000 
 2455      00000000 
 2456              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 2457              		.align	2
 2458              		.set	.LANCHOR15,. + 0
 2461              	uxSchedulerSuspended:
 2462 0000 00000000 		.space	4
 2463              		.section	.bss.pxCurrentTCB,"aw",%nobits
 2464              		.align	2
 2465              		.set	.LANCHOR1,. + 0
 2468              	pxCurrentTCB:
 2469 0000 00000000 		.space	4
 2470              		.section	.bss.xPendingReadyList,"aw",%nobits
 2471              		.align	2
 2472              		.set	.LANCHOR9,. + 0
 2475              	xPendingReadyList:
 2476 0000 00000000 		.space	20
 2476      00000000 
 2476      00000000 
 2476      00000000 
 2476      00000000 
 2477              		.section	.rodata.str1.1,"aMS",%progbits,1
 2478              	.LC34:
 2479 0000 49444C45 		.ascii	"IDLE\000"
 2479      00
 2480              		.section	.bss.xTickCount,"aw",%nobits
 2481              		.align	2
 2482              		.set	.LANCHOR2,. + 0
 2485              	xTickCount:
 2486 0000 00000000 		.space	4
 2487              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
 2488              		.align	2
 2489              		.set	.LANCHOR3,. + 0
 2492              	pxOverflowDelayedTaskList:
 2493 0000 00000000 		.space	4
 2494              		.section	.bss.uxTopReadyPriority,"aw",%nobits
 2495              		.align	2
 2496              		.set	.LANCHOR14,. + 0
 2499              	uxTopReadyPriority:
 2500 0000 00000000 		.space	4
 2501              		.section	.bss.uxTaskNumber,"aw",%nobits
 2502              		.align	2
 2503              		.set	.LANCHOR13,. + 0
 2506              	uxTaskNumber:
 2507 0000 00000000 		.space	4
 2508              		.section	.bss.xDelayedTaskList1,"aw",%nobits
 2509              		.align	2
 2510              		.set	.LANCHOR7,. + 0
 2513              	xDelayedTaskList1:
 2514 0000 00000000 		.space	20
 2514      00000000 
 2514      00000000 
 2514      00000000 
 2514      00000000 
 2515              		.section	.data.xNextTaskUnblockTime,"aw",%progbits
 2516              		.align	2
 2517              		.set	.LANCHOR5,. + 0
 2520              	xNextTaskUnblockTime:
 2521 0000 FFFFFFFF 		.word	-1
 2522              		.section	.bss.xMissedYield,"aw",%nobits
 2523              		.align	2
 2524              		.set	.LANCHOR18,. + 0
 2527              	xMissedYield:
 2528 0000 00000000 		.space	4
 2529              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
 2530              		.align	2
 2531              		.set	.LANCHOR6,. + 0
 2534              	uxCurrentNumberOfTasks:
 2535 0000 00000000 		.space	4
 2536              		.section	.bss.uxTopUsedPriority,"aw",%nobits
 2537              		.align	2
 2538              		.set	.LANCHOR12,. + 0
 2541              	uxTopUsedPriority:
 2542 0000 00000000 		.space	4
 2543              		.text
 2544              	.Letext0:
 2545              		.file 2 "C:/Freescale/CW MCU v10.6/MCU/ARM_GCC_Support/ewl/EWL_C/include/size_t.h"
 2546              		.file 3 "C:/Users/Franco/workspace/RoboTito/RoboTitoProyecto/Generated_Code/projdefs.h"
 2547              		.file 4 "C:/Users/Franco/workspace/RoboTito/RoboTitoProyecto/Generated_Code/portmacro.h"
 2548              		.file 5 "C:/Users/Franco/workspace/RoboTito/RoboTitoProyecto/Generated_Code/list.h"
 2549              		.file 6 "C:/Users/Franco/workspace/RoboTito/RoboTitoProyecto/Generated_Code/task.h"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:18     .text.prvIdleTask:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:22     .text.prvIdleTask:00000000 prvIdleTask
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:52     .text.prvIdleTask:00000014 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:57     .text.prvAddCurrentTaskToDelayedList:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:61     .text.prvAddCurrentTaskToDelayedList:00000000 prvAddCurrentTaskToDelayedList
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:123    .text.prvAddCurrentTaskToDelayedList:00000038 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:132    .text.xTaskGenericCreate:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:137    .text.xTaskGenericCreate:00000000 xTaskGenericCreate
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:456    .text.xTaskGenericCreate:00000130 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:473    .text.uxTaskPriorityGet:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:478    .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:516    .text.uxTaskPriorityGet:0000001c $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:521    .text.vTaskPrioritySet:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:526    .text.vTaskPrioritySet:00000000 vTaskPrioritySet
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:639    .text.vTaskPrioritySet:00000070 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:646    .text.xTaskIsTaskSuspended:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:651    .text.xTaskIsTaskSuspended:00000000 xTaskIsTaskSuspended
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:707    .text.xTaskIsTaskSuspended:00000028 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:713    .text.vTaskResume:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:718    .text.vTaskResume:00000000 vTaskResume
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:804    .text.vTaskResume:0000005c $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:811    .text.xTaskResumeFromISR:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:816    .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:914    .text.xTaskResumeFromISR:00000064 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:923    .text.vTaskStartScheduler:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:928    .text.vTaskStartScheduler:00000000 vTaskStartScheduler
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1001   .text.vTaskStartScheduler:00000040 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1009   .text.vTaskSuspendAll:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1014   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1031   .text.vTaskSuspendAll:0000000c $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1036   .text.xTaskGetTickCount:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1041   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1070   .text.xTaskGetTickCount:00000014 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1075   .text.xTaskGetTickCountFromISR:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1080   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1110   .text.xTaskGetTickCountFromISR:00000014 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1115   .text.uxTaskGetNumberOfTasks:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1120   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1135   .text.uxTaskGetNumberOfTasks:00000008 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1140   .text.vTaskIncrementTick:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1145   .text.vTaskIncrementTick:00000000 vTaskIncrementTick
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1328   .text.vTaskIncrementTick:000000d0 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1341   .text.xTaskResumeAll:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1346   .text.xTaskResumeAll:00000000 xTaskResumeAll
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1506   .text.xTaskResumeAll:000000b4 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1518   .text.vTaskDelay:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1523   .text.vTaskDelay:00000000 vTaskDelay
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1579   .text.vTaskDelay:00000030 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1585   .text.vTaskDelayUntil:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1590   .text.vTaskDelayUntil:00000000 vTaskDelayUntil
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1704   .text.vTaskDelayUntil:00000068 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1710   .text.vTaskSwitchContext:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1715   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1813   .text.vTaskSwitchContext:00000070 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1822   .text.vTaskSuspend:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1827   .text.vTaskSuspend:00000000 vTaskSuspend
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1919   .text.vTaskSuspend:00000064 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1927   .text.vTaskPlaceOnEventList:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:1932   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2001   .text.vTaskPlaceOnEventList:00000040 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2008   .text.xTaskRemoveFromEventList:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2013   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2100   .text.xTaskRemoveFromEventList:0000005c $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2109   .text.vTaskSetTimeOutState:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2114   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2156   .text.vTaskSetTimeOutState:0000001c $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2162   .text.xTaskCheckForTimeOut:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2167   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2272   .text.xTaskCheckForTimeOut:00000060 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2278   .text.vTaskMissedYield:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2283   .text.vTaskMissedYield:00000000 vTaskMissedYield
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2297   .text.vTaskMissedYield:00000008 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2302   .text.uxTaskGetStackHighWaterMark:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2307   .text.uxTaskGetStackHighWaterMark:00000000 uxTaskGetStackHighWaterMark
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2358   .text.uxTaskGetStackHighWaterMark:00000020 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2363   .text.xTaskGetSchedulerState:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2368   .text.xTaskGetSchedulerState:00000000 xTaskGetSchedulerState
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2401   .text.xTaskGetSchedulerState:00000018 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2468   .bss.pxCurrentTCB:00000000 pxCurrentTCB
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2408   .bss.uxMissedTicks:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2412   .bss.uxMissedTicks:00000000 uxMissedTicks
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2415   .bss.xSuspendedTaskList:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2419   .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2422   .bss.pxDelayedTaskList:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2426   .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2429   .bss.xSchedulerRunning:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2433   .bss.xSchedulerRunning:00000000 xSchedulerRunning
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2436   .bss.xNumOfOverflows:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2440   .bss.xNumOfOverflows:00000000 xNumOfOverflows
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2443   .bss.xDelayedTaskList2:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2447   .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2450   .bss.pxReadyTasksLists:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2454   .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2457   .bss.uxSchedulerSuspended:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2461   .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2464   .bss.pxCurrentTCB:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2471   .bss.xPendingReadyList:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2475   .bss.xPendingReadyList:00000000 xPendingReadyList
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2481   .bss.xTickCount:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2485   .bss.xTickCount:00000000 xTickCount
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2488   .bss.pxOverflowDelayedTaskList:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2492   .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2495   .bss.uxTopReadyPriority:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2499   .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2502   .bss.uxTaskNumber:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2506   .bss.uxTaskNumber:00000000 uxTaskNumber
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2509   .bss.xDelayedTaskList1:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2513   .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2516   .data.xNextTaskUnblockTime:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2520   .data.xNextTaskUnblockTime:00000000 xNextTaskUnblockTime
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2523   .bss.xMissedYield:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2527   .bss.xMissedYield:00000000 xMissedYield
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2530   .bss.uxCurrentNumberOfTasks:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2534   .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2537   .bss.uxTopUsedPriority:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cczbwfzb.s:2541   .bss.uxTopUsedPriority:00000000 uxTopUsedPriority
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
vPortYieldFromISR
FRTOS1_vApplicationIdleHook
vListInsert
pvPortMalloc
vPortFree
memset
vListInitialiseItem
pxPortInitialiseStack
vPortEnterCritical
vListInitialise
vListInsertEnd
vPortExitCritical
vListRemove
xPortStartScheduler
FRTOS1_vApplicationTickHook
FRTOS1_vApplicationStackOverflowHook
