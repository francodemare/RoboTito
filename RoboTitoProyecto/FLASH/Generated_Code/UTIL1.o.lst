   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 4
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"UTIL1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.ShiftRightAndFill,"ax",%progbits
  18              		.align	1
  19              		.code	16
  20              		.thumb_func
  22              	ShiftRightAndFill:
  23              	.LFB7:
  24              		.file 1 "../Generated_Code/UTIL1.c"
   1:../Generated_Code/UTIL1.c **** /* ###################################################################
   2:../Generated_Code/UTIL1.c **** **     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
   3:../Generated_Code/UTIL1.c **** **     Filename    : UTIL1.c
   4:../Generated_Code/UTIL1.c **** **     Project     : ProcessorExpert
   5:../Generated_Code/UTIL1.c **** **     Processor   : MKL25Z128VLK4
   6:../Generated_Code/UTIL1.c **** **     Component   : Utility
   7:../Generated_Code/UTIL1.c **** **     Version     : Component 01.083, Driver 01.00, CPU db: 3.00.000
   8:../Generated_Code/UTIL1.c **** **     Compiler    : GNU C Compiler
   9:../Generated_Code/UTIL1.c **** **     Date/Time   : 2014-10-03, 19:02, # CodeGen: 1
  10:../Generated_Code/UTIL1.c **** **     Abstract    :
  11:../Generated_Code/UTIL1.c **** **          Contains various utility functions.
  12:../Generated_Code/UTIL1.c **** **     Settings    :
  13:../Generated_Code/UTIL1.c **** **          Component name                                 : UTIL1
  14:../Generated_Code/UTIL1.c **** **     Contents    :
  15:../Generated_Code/UTIL1.c **** **         strcpy                - void UTIL1_strcpy(byte *dst, size_t dstSize, const unsigned char
  16:../Generated_Code/UTIL1.c **** **         strcat                - void UTIL1_strcat(byte *dst, size_t dstSize, const unsigned char
  17:../Generated_Code/UTIL1.c **** **         chcat                 - void UTIL1_chcat(byte *dst, size_t dstSize, byte ch);
  18:../Generated_Code/UTIL1.c **** **         Num8sToStr            - void UTIL1_Num8sToStr(byte *dst, size_t dstSize, signed char val
  19:../Generated_Code/UTIL1.c **** **         Num8uToStr            - void UTIL1_Num8uToStr(byte *dst, size_t dstSize, byte val);
  20:../Generated_Code/UTIL1.c **** **         Num16sToStr           - void UTIL1_Num16sToStr(byte *dst, size_t dstSize, int16_t val);
  21:../Generated_Code/UTIL1.c **** **         Num16uToStr           - void UTIL1_Num16uToStr(byte *dst, size_t dstSize, word val);
  22:../Generated_Code/UTIL1.c **** **         Num32uToStr           - void UTIL1_Num32uToStr(byte *dst, size_t dstSize, dword val);
  23:../Generated_Code/UTIL1.c **** **         Num32sToStr           - void UTIL1_Num32sToStr(byte *dst, size_t dstSize, long val);
  24:../Generated_Code/UTIL1.c **** **         Num16sToStrFormatted  - void UTIL1_Num16sToStrFormatted(byte *dst, size_t dstSize, int16
  25:../Generated_Code/UTIL1.c **** **         Num16uToStrFormatted  - void UTIL1_Num16uToStrFormatted(byte *dst, size_t dstSize, word 
  26:../Generated_Code/UTIL1.c **** **         Num32uToStrFormatted  - void UTIL1_Num32uToStrFormatted(byte *dst, size_t dstSize, dword
  27:../Generated_Code/UTIL1.c **** **         Num32sToStrFormatted  - void UTIL1_Num32sToStrFormatted(byte *dst, size_t dstSize, long 
  28:../Generated_Code/UTIL1.c **** **         strcatNum8u           - void UTIL1_strcatNum8u(byte *dst, size_t dstSize, byte val);
  29:../Generated_Code/UTIL1.c **** **         strcatNum8s           - void UTIL1_strcatNum8s(byte *dst, size_t dstSize, signed char va
  30:../Generated_Code/UTIL1.c **** **         strcatNum16u          - void UTIL1_strcatNum16u(byte *dst, size_t dstSize, word val);
  31:../Generated_Code/UTIL1.c **** **         strcatNum16s          - void UTIL1_strcatNum16s(byte *dst, size_t dstSize, int16_t val);
  32:../Generated_Code/UTIL1.c **** **         strcatNum32u          - void UTIL1_strcatNum32u(byte *dst, size_t dstSize, dword val);
  33:../Generated_Code/UTIL1.c **** **         strcatNum32s          - void UTIL1_strcatNum32s(byte *dst, size_t dstSize, long val);
  34:../Generated_Code/UTIL1.c **** **         strcatNum16uFormatted - void UTIL1_strcatNum16uFormatted(byte *dst, size_t dstSize, word
  35:../Generated_Code/UTIL1.c **** **         strcatNum16sFormatted - void UTIL1_strcatNum16sFormatted(byte *dst, size_t dstSize, int1
  36:../Generated_Code/UTIL1.c **** **         strcatNum32uFormatted - void UTIL1_strcatNum32uFormatted(byte *dst, size_t dstSize, dwor
  37:../Generated_Code/UTIL1.c **** **         strcatNum32sFormatted - void UTIL1_strcatNum32sFormatted(byte *dst, size_t dstSize, long
  38:../Generated_Code/UTIL1.c **** **         strcatNum8Hex         - void UTIL1_strcatNum8Hex(byte *dst, size_t dstSize, byte num);
  39:../Generated_Code/UTIL1.c **** **         strcatNum16Hex        - void UTIL1_strcatNum16Hex(byte *dst, size_t dstSize, word num);
  40:../Generated_Code/UTIL1.c **** **         strcatNum24Hex        - void UTIL1_strcatNum24Hex(byte *dst, size_t dstSize, dword num);
  41:../Generated_Code/UTIL1.c **** **         strcatNum32Hex        - void UTIL1_strcatNum32Hex(byte *dst, size_t dstSize, dword num);
  42:../Generated_Code/UTIL1.c **** **         IsLeapYear            - bool UTIL1_IsLeapYear(word year);
  43:../Generated_Code/UTIL1.c **** **         WeekDay               - byte UTIL1_WeekDay(word year, byte month, byte day);
  44:../Generated_Code/UTIL1.c **** **         ReadEscapedName       - byte UTIL1_ReadEscapedName(const unsigned char *filename, byte *
  45:../Generated_Code/UTIL1.c **** **         xatoi                 - byte UTIL1_xatoi(const unsigned char **str, long *res);
  46:../Generated_Code/UTIL1.c **** **         ScanDate              - byte UTIL1_ScanDate(const unsigned char **str, byte *day, byte *
  47:../Generated_Code/UTIL1.c **** **         ScanTime              - byte UTIL1_ScanTime(const unsigned char **str, byte *hour, byte 
  48:../Generated_Code/UTIL1.c **** **         ScanDecimal8uNumber   - byte UTIL1_ScanDecimal8uNumber(const unsigned char **str, byte *
  49:../Generated_Code/UTIL1.c **** **         ScanDecimal16uNumber  - byte UTIL1_ScanDecimal16uNumber(const unsigned char **str, word 
  50:../Generated_Code/UTIL1.c **** **         ScanDecimal32uNumber  - byte UTIL1_ScanDecimal32uNumber(const unsigned char **str, dword
  51:../Generated_Code/UTIL1.c **** **         ScanHex8uNumber       - byte UTIL1_ScanHex8uNumber(const unsigned char **str, byte *val)
  52:../Generated_Code/UTIL1.c **** **         ScanHex16uNumber      - byte UTIL1_ScanHex16uNumber(const unsigned char **str, word *val
  53:../Generated_Code/UTIL1.c **** **         ScanHex32uNumber      - byte UTIL1_ScanHex32uNumber(const unsigned char **str, dword *va
  54:../Generated_Code/UTIL1.c **** **         strcmp                - int16_t UTIL1_strcmp(const char *, const char *);
  55:../Generated_Code/UTIL1.c **** **         strncmp               - int16_t UTIL1_strncmp(const char *, const char *, size_t size);
  56:../Generated_Code/UTIL1.c **** **         strtailcmp            - byte UTIL1_strtailcmp(byte *str, byte *tail);
  57:../Generated_Code/UTIL1.c **** **         strlen                - word UTIL1_strlen(const char *);
  58:../Generated_Code/UTIL1.c **** **         strCutTail            - byte UTIL1_strCutTail(byte *str, byte *tail);
  59:../Generated_Code/UTIL1.c **** **
  60:../Generated_Code/UTIL1.c **** **     License   :  Open Source (LGPL)
  61:../Generated_Code/UTIL1.c **** **     Copyright : (c) Copyright Erich Styger, 2013, all rights reserved.
  62:../Generated_Code/UTIL1.c **** **     xatoi(): Copyright (C) 2010, ChaN, all right reserved. (see copyright notice and license at 
  63:../Generated_Code/UTIL1.c **** **     This an open source software implementing utility functions using Processor Expert.
  64:../Generated_Code/UTIL1.c **** **     This is a free software and is opened for education,  research and commercial developments u
  65:../Generated_Code/UTIL1.c **** **     * This is a free software and there is NO WARRANTY.
  66:../Generated_Code/UTIL1.c **** **     * No restriction on use. You can use, modify and redistribute it for
  67:../Generated_Code/UTIL1.c **** **       personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
  68:../Generated_Code/UTIL1.c **** **     * Redistributions of source code must retain the above copyright notice.
  69:../Generated_Code/UTIL1.c **** ** ###################################################################*/
  70:../Generated_Code/UTIL1.c **** /*!
  71:../Generated_Code/UTIL1.c **** ** @file UTIL1.c
  72:../Generated_Code/UTIL1.c **** ** @version 01.00
  73:../Generated_Code/UTIL1.c **** ** @brief
  74:../Generated_Code/UTIL1.c **** **          Contains various utility functions.
  75:../Generated_Code/UTIL1.c **** */         
  76:../Generated_Code/UTIL1.c **** /*!
  77:../Generated_Code/UTIL1.c **** **  @addtogroup UTIL1_module UTIL1 module documentation
  78:../Generated_Code/UTIL1.c **** **  @{
  79:../Generated_Code/UTIL1.c **** */         
  80:../Generated_Code/UTIL1.c **** 
  81:../Generated_Code/UTIL1.c **** /* MODULE UTIL1. */
  82:../Generated_Code/UTIL1.c **** 
  83:../Generated_Code/UTIL1.c **** #include "UTIL1.h"
  84:../Generated_Code/UTIL1.c **** 
  85:../Generated_Code/UTIL1.c **** /* Internal method prototypes */
  86:../Generated_Code/UTIL1.c **** static void ShiftRightAndFill(byte *dst, byte fill, byte nofFill);
  87:../Generated_Code/UTIL1.c **** 
  88:../Generated_Code/UTIL1.c **** /*
  89:../Generated_Code/UTIL1.c **** ** ===================================================================
  90:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcpy (component Utility)
  91:../Generated_Code/UTIL1.c **** **     Description :
  92:../Generated_Code/UTIL1.c **** **         Same as normal strcpy, but safe as it does not write beyond
  93:../Generated_Code/UTIL1.c **** **         the buffer.
  94:../Generated_Code/UTIL1.c **** **     Parameters  :
  95:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
  96:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
  97:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
  98:../Generated_Code/UTIL1.c **** **                           bytes).
  99:../Generated_Code/UTIL1.c **** **       * src             - Pointer to source string.
 100:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 101:../Generated_Code/UTIL1.c **** ** ===================================================================
 102:../Generated_Code/UTIL1.c **** */
 103:../Generated_Code/UTIL1.c **** /*!
 104:../Generated_Code/UTIL1.c ****   \brief copy the string src into dst. It performs the same task as strncpy, except
 105:../Generated_Code/UTIL1.c ****      - always terminates the result string.
 106:../Generated_Code/UTIL1.c ****      - does not zero out the remaining part in dst.
 107:../Generated_Code/UTIL1.c ****      Note: dstSize is the size of dst INCLUDING zero byte.
 108:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 109:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 110:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 111:../Generated_Code/UTIL1.c ****   \param[in] src The source string to copy
 112:../Generated_Code/UTIL1.c **** */
 113:../Generated_Code/UTIL1.c **** void UTIL1_strcpy(byte *dst, size_t dstSize, const unsigned char *src)
 114:../Generated_Code/UTIL1.c **** {
 115:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 116:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *src != '\0') {
 117:../Generated_Code/UTIL1.c ****     *dst++ = *src++;
 118:../Generated_Code/UTIL1.c ****     dstSize--;
 119:../Generated_Code/UTIL1.c ****   }
 120:../Generated_Code/UTIL1.c ****   *dst = '\0';
 121:../Generated_Code/UTIL1.c **** }
 122:../Generated_Code/UTIL1.c **** 
 123:../Generated_Code/UTIL1.c **** /*
 124:../Generated_Code/UTIL1.c **** ** ===================================================================
 125:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcat (component Utility)
 126:../Generated_Code/UTIL1.c **** **     Description :
 127:../Generated_Code/UTIL1.c **** **         Same as normal strcat, but safe as it does not write beyond
 128:../Generated_Code/UTIL1.c **** **         the buffer.
 129:../Generated_Code/UTIL1.c **** **     Parameters  :
 130:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 131:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 132:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 133:../Generated_Code/UTIL1.c **** **                           bytes).
 134:../Generated_Code/UTIL1.c **** **       * src             - Pointer to source string.
 135:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 136:../Generated_Code/UTIL1.c **** ** ===================================================================
 137:../Generated_Code/UTIL1.c **** */
 138:../Generated_Code/UTIL1.c **** /*!
 139:../Generated_Code/UTIL1.c ****   \brief Concat the string src into dst. Always terminates the result string.
 140:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 141:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 142:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 143:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 144:../Generated_Code/UTIL1.c ****   \param[in] src The source string to add
 145:../Generated_Code/UTIL1.c ****   */
 146:../Generated_Code/UTIL1.c **** void UTIL1_strcat(byte *dst, size_t dstSize, const unsigned char *src)
 147:../Generated_Code/UTIL1.c **** {
 148:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 149:../Generated_Code/UTIL1.c ****   /* point to the end of the source */
 150:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *dst != '\0') {
 151:../Generated_Code/UTIL1.c ****     dst++;
 152:../Generated_Code/UTIL1.c ****     dstSize--;
 153:../Generated_Code/UTIL1.c ****   }
 154:../Generated_Code/UTIL1.c ****   /* copy the src in the destination */
 155:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *src != '\0') {
 156:../Generated_Code/UTIL1.c ****     *dst++ = *src++;
 157:../Generated_Code/UTIL1.c ****     dstSize--;
 158:../Generated_Code/UTIL1.c ****   }
 159:../Generated_Code/UTIL1.c ****   /* terminate the string */
 160:../Generated_Code/UTIL1.c ****   *dst = '\0';
 161:../Generated_Code/UTIL1.c **** }
 162:../Generated_Code/UTIL1.c **** 
 163:../Generated_Code/UTIL1.c **** /*
 164:../Generated_Code/UTIL1.c **** ** ===================================================================
 165:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_chcat (component Utility)
 166:../Generated_Code/UTIL1.c **** **     Description :
 167:../Generated_Code/UTIL1.c **** **         Adds a single character to a zero byte terminated buffer. It
 168:../Generated_Code/UTIL1.c **** **         cares about buffer overflow.
 169:../Generated_Code/UTIL1.c **** **     Parameters  :
 170:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 171:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 172:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 173:../Generated_Code/UTIL1.c **** **                           bytes).
 174:../Generated_Code/UTIL1.c **** **         ch              - character to append
 175:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 176:../Generated_Code/UTIL1.c **** ** ===================================================================
 177:../Generated_Code/UTIL1.c **** */
 178:../Generated_Code/UTIL1.c **** void UTIL1_chcat(byte *dst, size_t dstSize, byte ch)
 179:../Generated_Code/UTIL1.c **** {
 180:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 181:../Generated_Code/UTIL1.c ****   /* point to the end of the source */
 182:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *dst != '\0') {
 183:../Generated_Code/UTIL1.c ****     dst++;
 184:../Generated_Code/UTIL1.c ****     dstSize--;
 185:../Generated_Code/UTIL1.c ****   }
 186:../Generated_Code/UTIL1.c ****   /* copy the ch in the destination */
 187:../Generated_Code/UTIL1.c ****   if (dstSize > 0) {
 188:../Generated_Code/UTIL1.c ****     *dst++ = ch;
 189:../Generated_Code/UTIL1.c ****   }
 190:../Generated_Code/UTIL1.c ****   /* terminate the string */
 191:../Generated_Code/UTIL1.c ****   *dst = '\0';
 192:../Generated_Code/UTIL1.c **** }
 193:../Generated_Code/UTIL1.c **** 
 194:../Generated_Code/UTIL1.c **** /*
 195:../Generated_Code/UTIL1.c **** ** ===================================================================
 196:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num8uToStr (component Utility)
 197:../Generated_Code/UTIL1.c **** **     Description :
 198:../Generated_Code/UTIL1.c **** **         Converts an unsigned 8bit value into a string.
 199:../Generated_Code/UTIL1.c **** **     Parameters  :
 200:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 201:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 202:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 203:../Generated_Code/UTIL1.c **** **                           bytes).
 204:../Generated_Code/UTIL1.c **** **         val             - Value to be converted.
 205:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 206:../Generated_Code/UTIL1.c **** ** ===================================================================
 207:../Generated_Code/UTIL1.c **** */
 208:../Generated_Code/UTIL1.c **** /*!
 209:../Generated_Code/UTIL1.c ****   \brief Converts an 8bit unsigned number into a string.
 210:../Generated_Code/UTIL1.c ****   \param[in,out] dst String buffer to store the number.
 211:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer in bytes.
 212:../Generated_Code/UTIL1.c ****   \param[in] val 8bit unsigned number to convert.
 213:../Generated_Code/UTIL1.c ****  */
 214:../Generated_Code/UTIL1.c **** void UTIL1_Num8uToStr(byte *dst, size_t dstSize, byte val)
 215:../Generated_Code/UTIL1.c **** {
 216:../Generated_Code/UTIL1.c ****   UTIL1_Num16uToStr(dst, dstSize, (uint16_t)val);
 217:../Generated_Code/UTIL1.c **** }
 218:../Generated_Code/UTIL1.c **** 
 219:../Generated_Code/UTIL1.c **** /*
 220:../Generated_Code/UTIL1.c **** ** ===================================================================
 221:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num8sToStr (component Utility)
 222:../Generated_Code/UTIL1.c **** **     Description :
 223:../Generated_Code/UTIL1.c **** **         Converts a signed 8bit value into a string.
 224:../Generated_Code/UTIL1.c **** **     Parameters  :
 225:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 226:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 227:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 228:../Generated_Code/UTIL1.c **** **                           bytes).
 229:../Generated_Code/UTIL1.c **** **         val             - Value to be converted.
 230:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 231:../Generated_Code/UTIL1.c **** ** ===================================================================
 232:../Generated_Code/UTIL1.c **** */
 233:../Generated_Code/UTIL1.c **** /*!
 234:../Generated_Code/UTIL1.c ****   \brief Converts an 8bit signed number into a string.
 235:../Generated_Code/UTIL1.c ****   \param[in,out] dst String buffer to store the number.
 236:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer in bytes.
 237:../Generated_Code/UTIL1.c ****   \param[in] val 8bit signed number to convert.
 238:../Generated_Code/UTIL1.c ****  */
 239:../Generated_Code/UTIL1.c **** void UTIL1_Num8sToStr(byte *dst, size_t dstSize, signed char val)
 240:../Generated_Code/UTIL1.c **** {
 241:../Generated_Code/UTIL1.c ****   UTIL1_Num16sToStr(dst, dstSize, (int16_t)val);
 242:../Generated_Code/UTIL1.c **** }
 243:../Generated_Code/UTIL1.c **** 
 244:../Generated_Code/UTIL1.c **** /*
 245:../Generated_Code/UTIL1.c **** ** ===================================================================
 246:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num16uToStr (component Utility)
 247:../Generated_Code/UTIL1.c **** **     Description :
 248:../Generated_Code/UTIL1.c **** **         Converts a signed 16bit value into a string.
 249:../Generated_Code/UTIL1.c **** **     Parameters  :
 250:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 251:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 252:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 253:../Generated_Code/UTIL1.c **** **                           bytes).
 254:../Generated_Code/UTIL1.c **** **         val             - Value to be converted.
 255:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 256:../Generated_Code/UTIL1.c **** ** ===================================================================
 257:../Generated_Code/UTIL1.c **** */
 258:../Generated_Code/UTIL1.c **** /*!
 259:../Generated_Code/UTIL1.c ****   \brief Converts a 16bit unsigned number into a string.
 260:../Generated_Code/UTIL1.c ****   \param[in,out] dst String buffer to store the number.
 261:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer in bytes.
 262:../Generated_Code/UTIL1.c ****   \param[in] val 16bit unsigned number to convert.
 263:../Generated_Code/UTIL1.c ****  */
 264:../Generated_Code/UTIL1.c **** void UTIL1_Num16uToStr(byte *dst, size_t dstSize, word val)
 265:../Generated_Code/UTIL1.c **** {
 266:../Generated_Code/UTIL1.c ****   unsigned char *ptr = ((unsigned char *)dst);
 267:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 268:../Generated_Code/UTIL1.c ****   unsigned char tmp;
 269:../Generated_Code/UTIL1.c **** 
 270:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 271:../Generated_Code/UTIL1.c ****   if (val == 0 && dstSize > 0){
 272:../Generated_Code/UTIL1.c ****     ptr[i++] = '0';
 273:../Generated_Code/UTIL1.c ****     dstSize--;
 274:../Generated_Code/UTIL1.c ****   }
 275:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 276:../Generated_Code/UTIL1.c ****     ptr[i++] = (unsigned char)((val % 10) + '0');
 277:../Generated_Code/UTIL1.c ****     dstSize--;
 278:../Generated_Code/UTIL1.c ****     val /= 10;
 279:../Generated_Code/UTIL1.c ****   }
 280:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 281:../Generated_Code/UTIL1.c ****     tmp = ptr[j];
 282:../Generated_Code/UTIL1.c ****     ptr[j] = ptr[(i-j)-1];
 283:../Generated_Code/UTIL1.c ****     ptr[(i-j)-1] = tmp;
 284:../Generated_Code/UTIL1.c ****   }
 285:../Generated_Code/UTIL1.c ****   ptr[i] = '\0';
 286:../Generated_Code/UTIL1.c **** }
 287:../Generated_Code/UTIL1.c **** 
 288:../Generated_Code/UTIL1.c **** /*
 289:../Generated_Code/UTIL1.c **** ** ===================================================================
 290:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num16sToStr (component Utility)
 291:../Generated_Code/UTIL1.c **** **     Description :
 292:../Generated_Code/UTIL1.c **** **         Converts a signed 16bit value into a string.
 293:../Generated_Code/UTIL1.c **** **     Parameters  :
 294:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 295:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 296:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 297:../Generated_Code/UTIL1.c **** **                           bytes).
 298:../Generated_Code/UTIL1.c **** **         val             - Value to be converted.
 299:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 300:../Generated_Code/UTIL1.c **** ** ===================================================================
 301:../Generated_Code/UTIL1.c **** */
 302:../Generated_Code/UTIL1.c **** /*!
 303:../Generated_Code/UTIL1.c ****   \brief Converts a 16bit signed number into a string.
 304:../Generated_Code/UTIL1.c ****   \param[in,out] dst String buffer to store the number.
 305:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer in bytes.
 306:../Generated_Code/UTIL1.c ****   \param[in] val 16bit signed number to convert.
 307:../Generated_Code/UTIL1.c ****  */
 308:../Generated_Code/UTIL1.c **** void UTIL1_Num16sToStr(byte *dst, size_t dstSize, int16_t val)
 309:../Generated_Code/UTIL1.c **** {
 310:../Generated_Code/UTIL1.c ****   unsigned char *ptr =  ((unsigned char *)dst);
 311:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 312:../Generated_Code/UTIL1.c ****   unsigned char tmp;
 313:../Generated_Code/UTIL1.c ****   unsigned char sign = (unsigned char)(val < 0);
 314:../Generated_Code/UTIL1.c **** 
 315:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 316:../Generated_Code/UTIL1.c ****   if (sign){
 317:../Generated_Code/UTIL1.c ****     val *= -1;
 318:../Generated_Code/UTIL1.c ****   }
 319:../Generated_Code/UTIL1.c ****   if (val == 0 && dstSize > 0){
 320:../Generated_Code/UTIL1.c ****     ptr[i++] = '0';
 321:../Generated_Code/UTIL1.c ****     dstSize--;
 322:../Generated_Code/UTIL1.c ****   }
 323:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 324:../Generated_Code/UTIL1.c ****     ptr[i++] = (unsigned char)((val % 10) + '0');
 325:../Generated_Code/UTIL1.c ****     dstSize--;
 326:../Generated_Code/UTIL1.c ****     val /= 10;
 327:../Generated_Code/UTIL1.c ****   }
 328:../Generated_Code/UTIL1.c ****   if (sign && dstSize > 0){
 329:../Generated_Code/UTIL1.c ****     ptr[i++] = '-';
 330:../Generated_Code/UTIL1.c ****     dstSize--;
 331:../Generated_Code/UTIL1.c ****   }
 332:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 333:../Generated_Code/UTIL1.c ****     tmp = ptr[j];
 334:../Generated_Code/UTIL1.c ****     ptr[j] = ptr[(i-j)-1];
 335:../Generated_Code/UTIL1.c ****     ptr[(i-j)-1] = tmp;
 336:../Generated_Code/UTIL1.c ****   }
 337:../Generated_Code/UTIL1.c ****   ptr[i] = '\0';
 338:../Generated_Code/UTIL1.c **** }
 339:../Generated_Code/UTIL1.c **** 
 340:../Generated_Code/UTIL1.c **** /*
 341:../Generated_Code/UTIL1.c **** ** ===================================================================
 342:../Generated_Code/UTIL1.c **** **     Method      :  ShiftRightAndFill (component Utility)
 343:../Generated_Code/UTIL1.c **** **
 344:../Generated_Code/UTIL1.c **** **     Description :
 345:../Generated_Code/UTIL1.c **** **         Moves the content of a string to the right and fills the space 
 346:../Generated_Code/UTIL1.c **** **         on the left side with a pattern
 347:../Generated_Code/UTIL1.c **** **         This method is internal. It is used by Processor Expert only.
 348:../Generated_Code/UTIL1.c **** ** ===================================================================
 349:../Generated_Code/UTIL1.c **** */
 350:../Generated_Code/UTIL1.c **** static void ShiftRightAndFill(byte *dst, byte fill, byte nofFill)
 351:../Generated_Code/UTIL1.c **** {
  25              		.loc 1 351 0
  26              		.cfi_startproc
  27              	.LVL0:
  28 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
  29              	.LCFI0:
  30              		.cfi_def_cfa_offset 32
  31              		.cfi_offset 0, -32
  32              		.cfi_offset 1, -28
  33              		.cfi_offset 2, -24
  34              		.cfi_offset 4, -20
  35              		.cfi_offset 5, -16
  36              		.cfi_offset 6, -12
  37              		.cfi_offset 7, -8
  38              		.cfi_offset 14, -4
 352:../Generated_Code/UTIL1.c ****   signed char i, j;
 353:../Generated_Code/UTIL1.c **** 
 354:../Generated_Code/UTIL1.c ****   j = 0;
 355:../Generated_Code/UTIL1.c ****   while(dst[j] != '\0') {
  39              		.loc 1 355 0
  40 0002 041C     		mov	r4, r0
  41              	.LVL1:
  42              	.L2:
 350:../Generated_Code/UTIL1.c **** static void ShiftRightAndFill(byte *dst, byte fill, byte nofFill)
  43              		.loc 1 350 0
  44 0004 251A     		sub	r5, r4, r0
  45 0006 0134     		add	r4, r4, #1
  46 0008 631E     		sub	r3, r4, #1
  47              		.loc 1 355 0
  48 000a 1B78     		ldrb	r3, [r3]
 350:../Generated_Code/UTIL1.c **** static void ShiftRightAndFill(byte *dst, byte fill, byte nofFill)
  49              		.loc 1 350 0
  50 000c EDB2     		uxtb	r5, r5
  51              		.loc 1 355 0
  52 000e 002B     		cmp	r3, #0
  53 0010 F8D1     		bne	.L2
 356:../Generated_Code/UTIL1.c ****     j++;
 357:../Generated_Code/UTIL1.c ****   }
 358:../Generated_Code/UTIL1.c ****   i = (signed char)nofFill;
  54              		.loc 1 358 0
  55 0012 D2B2     		uxtb	r2, r2
 359:../Generated_Code/UTIL1.c ****   if (i==j) {
  56              		.loc 1 359 0
  57 0014 6E46     		mov	r6, sp
 358:../Generated_Code/UTIL1.c ****   i = (signed char)nofFill;
  58              		.loc 1 358 0
  59 0016 0092     		str	r2, [sp]
  60              	.LVL2:
  61              		.loc 1 359 0
  62 0018 0027     		mov	r7, #0
  63 001a F457     		ldrsb	r4, [r6, r7]
  64 001c 6EB2     		sxtb	r6, r5
  65              	.LVL3:
  66 001e B442     		cmp	r4, r6
  67 0020 1BD0     		beq	.L1
 360:../Generated_Code/UTIL1.c ****     /* nothing to do, we are done */
 361:../Generated_Code/UTIL1.c ****   } else if (i>j) {
  68              		.loc 1 361 0
  69 0022 1ADD     		ble	.L1
  70              	.LVL4:
  71              	.L5:
 350:../Generated_Code/UTIL1.c **** static void ShiftRightAndFill(byte *dst, byte fill, byte nofFill)
  72              		.loc 1 350 0
  73 0024 8219     		add	r2, r0, r6
 362:../Generated_Code/UTIL1.c ****     while (j>=0) {
 363:../Generated_Code/UTIL1.c ****       dst[i] = dst[j];
  74              		.loc 1 363 0
  75 0026 D75C     		ldrb	r7, [r2, r3]
  76 0028 BC46     		mov	ip, r7
  77 002a 6246     		mov	r2, ip
 350:../Generated_Code/UTIL1.c **** static void ShiftRightAndFill(byte *dst, byte fill, byte nofFill)
  78              		.loc 1 350 0
  79 002c 0719     		add	r7, r0, r4
  80              		.loc 1 363 0
  81 002e FA54     		strb	r2, [r7, r3]
  82 0030 013B     		sub	r3, r3, #1
 350:../Generated_Code/UTIL1.c **** static void ShiftRightAndFill(byte *dst, byte fill, byte nofFill)
  83              		.loc 1 350 0
  84 0032 5F19     		add	r7, r3, r5
 362:../Generated_Code/UTIL1.c ****     while (j>=0) {
  85              		.loc 1 362 0
  86 0034 3F06     		lsl	r7, r7, #24
  87 0036 F5D5     		bpl	.L5
 350:../Generated_Code/UTIL1.c **** static void ShiftRightAndFill(byte *dst, byte fill, byte nofFill)
  88              		.loc 1 350 0
  89 0038 6BB2     		sxtb	r3, r5
  90 003a DE43     		mvn	r6, r3
  91 003c 009C     		ldr	r4, [sp]
  92 003e F217     		asr	r2, r6, #31
  93 0040 013C     		sub	r4, r4, #1
  94 0042 1540     		and	r5, r2
  95 0044 651B     		sub	r5, r4, r5
  96 0046 EEB2     		uxtb	r6, r5
  97 0048 0023     		mov	r3, #0
  98              	.L7:
 350:../Generated_Code/UTIL1.c **** static void ShiftRightAndFill(byte *dst, byte fill, byte nofFill)
  99              		.loc 1 350 0 is_stmt 0
 100 004a 9F19     		add	r7, r3, r6
 364:../Generated_Code/UTIL1.c ****       i--; j--;
 365:../Generated_Code/UTIL1.c ****     }
 366:../Generated_Code/UTIL1.c ****     while(i>=0) {
 101              		.loc 1 366 0 is_stmt 1
 102 004c 3C06     		lsl	r4, r7, #24
 103 004e 04D4     		bmi	.L1
 104              	.L8:
 350:../Generated_Code/UTIL1.c **** static void ShiftRightAndFill(byte *dst, byte fill, byte nofFill)
 105              		.loc 1 350 0
 106 0050 74B2     		sxtb	r4, r6
 107 0052 0219     		add	r2, r0, r4
 367:../Generated_Code/UTIL1.c ****       dst[i] = fill;
 108              		.loc 1 367 0
 109 0054 D154     		strb	r1, [r2, r3]
 110 0056 013B     		sub	r3, r3, #1
 111 0058 F7E7     		b	.L7
 112              	.L1:
 368:../Generated_Code/UTIL1.c ****       i--;
 369:../Generated_Code/UTIL1.c ****     }
 370:../Generated_Code/UTIL1.c ****   } else {
 371:../Generated_Code/UTIL1.c ****     /* hmmm, not enough space, return what we have, do nothing */
 372:../Generated_Code/UTIL1.c ****   }
 373:../Generated_Code/UTIL1.c **** }
 113              		.loc 1 373 0
 114              		@ sp needed for prologue
 115 005a F7BD     		pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 116              		.cfi_endproc
 117              	.LFE7:
 119              		.section	.text.PreScanHexNumber,"ax",%progbits
 120              		.align	1
 121              		.code	16
 122              		.thumb_func
 124              	PreScanHexNumber:
 125              	.LFB37:
 374:../Generated_Code/UTIL1.c **** 
 375:../Generated_Code/UTIL1.c **** /*
 376:../Generated_Code/UTIL1.c **** ** ===================================================================
 377:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num16sToStrFormatted (component Utility)
 378:../Generated_Code/UTIL1.c **** **     Description :
 379:../Generated_Code/UTIL1.c **** **         Converts a 16bit signed value to string.
 380:../Generated_Code/UTIL1.c **** **     Parameters  :
 381:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 382:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 383:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 384:../Generated_Code/UTIL1.c **** **                           bytes).
 385:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 386:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 387:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 388:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 389:../Generated_Code/UTIL1.c **** ** ===================================================================
 390:../Generated_Code/UTIL1.c **** */
 391:../Generated_Code/UTIL1.c **** /*!
 392:../Generated_Code/UTIL1.c ****   \brief Converts a 16bit signed number to a string, in a formatted way (like printf with "%0d").
 393:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 394:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 395:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 396:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 397:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer, in bytes.
 398:../Generated_Code/UTIL1.c ****   \param[in] val The 16bit signed number to add
 399:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character, typically ' ' (like for "%2d" or '0' (for "%02d")
 400:../Generated_Code/UTIL1.c ****   \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%2d"
 401:../Generated_Code/UTIL1.c **** */
 402:../Generated_Code/UTIL1.c **** void UTIL1_Num16sToStrFormatted(byte *dst, size_t dstSize, int16_t val, char fill, byte nofFill)
 403:../Generated_Code/UTIL1.c **** {
 404:../Generated_Code/UTIL1.c ****   UTIL1_Num16sToStr(dst, dstSize, val);
 405:../Generated_Code/UTIL1.c ****   ShiftRightAndFill(dst, fill, nofFill);
 406:../Generated_Code/UTIL1.c **** }
 407:../Generated_Code/UTIL1.c **** 
 408:../Generated_Code/UTIL1.c **** /*
 409:../Generated_Code/UTIL1.c **** ** ===================================================================
 410:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num16uToStrFormatted (component Utility)
 411:../Generated_Code/UTIL1.c **** **     Description :
 412:../Generated_Code/UTIL1.c **** **         Converts a 16bit unsigned value to string.
 413:../Generated_Code/UTIL1.c **** **     Parameters  :
 414:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 415:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 416:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 417:../Generated_Code/UTIL1.c **** **                           bytes).
 418:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 419:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 420:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 421:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 422:../Generated_Code/UTIL1.c **** ** ===================================================================
 423:../Generated_Code/UTIL1.c **** */
 424:../Generated_Code/UTIL1.c **** /*!
 425:../Generated_Code/UTIL1.c ****   \brief Converts a 16bit unsigned number to a string, in a formatted way (like printf with "%0d").
 426:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 427:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 428:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 429:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 430:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer, in bytes.
 431:../Generated_Code/UTIL1.c ****   \param[in] val The 16bit unsigned number to add
 432:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character, typically ' ' (like for "%2d" or '0' (for "%02d")
 433:../Generated_Code/UTIL1.c ****   \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%2d"
 434:../Generated_Code/UTIL1.c **** */
 435:../Generated_Code/UTIL1.c **** void UTIL1_Num16uToStrFormatted(byte *dst, size_t dstSize, word val, char fill, byte nofFill)
 436:../Generated_Code/UTIL1.c **** {
 437:../Generated_Code/UTIL1.c ****   UTIL1_Num16uToStr(dst, dstSize, val);
 438:../Generated_Code/UTIL1.c ****   ShiftRightAndFill(dst, fill, nofFill);
 439:../Generated_Code/UTIL1.c **** }
 440:../Generated_Code/UTIL1.c **** 
 441:../Generated_Code/UTIL1.c **** /*
 442:../Generated_Code/UTIL1.c **** ** ===================================================================
 443:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num32uToStrFormatted (component Utility)
 444:../Generated_Code/UTIL1.c **** **     Description :
 445:../Generated_Code/UTIL1.c **** **         Converts a 32bit unsigned value to string.
 446:../Generated_Code/UTIL1.c **** **     Parameters  :
 447:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 448:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 449:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 450:../Generated_Code/UTIL1.c **** **                           bytes).
 451:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 452:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 453:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 454:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 455:../Generated_Code/UTIL1.c **** ** ===================================================================
 456:../Generated_Code/UTIL1.c **** */
 457:../Generated_Code/UTIL1.c **** /*!
 458:../Generated_Code/UTIL1.c ****   \brief Converts a 32bit unsigned number to a string, in a formatted way (like printf with "%0d").
 459:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 460:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 461:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 462:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 463:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer, in bytes.
 464:../Generated_Code/UTIL1.c ****   \param[in] val The 32bit unsigned number to add
 465:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character, typically ' ' (like for "%2d" or '0' (for "%02d")
 466:../Generated_Code/UTIL1.c ****   \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%2d"
 467:../Generated_Code/UTIL1.c **** */
 468:../Generated_Code/UTIL1.c **** void UTIL1_Num32uToStrFormatted(byte *dst, size_t dstSize, dword val, char fill, byte nofFill)
 469:../Generated_Code/UTIL1.c **** {
 470:../Generated_Code/UTIL1.c ****   UTIL1_Num32uToStr(dst, dstSize, val);
 471:../Generated_Code/UTIL1.c ****   ShiftRightAndFill(dst, fill, nofFill);
 472:../Generated_Code/UTIL1.c **** }
 473:../Generated_Code/UTIL1.c **** 
 474:../Generated_Code/UTIL1.c **** /*
 475:../Generated_Code/UTIL1.c **** ** ===================================================================
 476:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num32sToStrFormatted (component Utility)
 477:../Generated_Code/UTIL1.c **** **     Description :
 478:../Generated_Code/UTIL1.c **** **         Converts a 32bit signed value to string.
 479:../Generated_Code/UTIL1.c **** **     Parameters  :
 480:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 481:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 482:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 483:../Generated_Code/UTIL1.c **** **                           bytes).
 484:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 485:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 486:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 487:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 488:../Generated_Code/UTIL1.c **** ** ===================================================================
 489:../Generated_Code/UTIL1.c **** */
 490:../Generated_Code/UTIL1.c **** /*!
 491:../Generated_Code/UTIL1.c ****   \brief Converts a 32bit signed number to a string, in a formatted way (like printf with "%0d").
 492:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 493:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 494:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 495:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 496:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer, in bytes.
 497:../Generated_Code/UTIL1.c ****   \param[in] val The 32bit signed number to add
 498:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character, typically ' ' (like for "%2d" or '0' (for "%02d")
 499:../Generated_Code/UTIL1.c ****   \param[in] nofFill Size for the format (right aligned) string, e.g. '2' for "%2d"
 500:../Generated_Code/UTIL1.c **** */
 501:../Generated_Code/UTIL1.c **** void UTIL1_Num32sToStrFormatted(byte *dst, size_t dstSize, long val, char fill, byte nofFill)
 502:../Generated_Code/UTIL1.c **** {
 503:../Generated_Code/UTIL1.c ****   UTIL1_Num32sToStr(dst, dstSize, val);
 504:../Generated_Code/UTIL1.c ****   ShiftRightAndFill(dst, fill, nofFill);
 505:../Generated_Code/UTIL1.c **** }
 506:../Generated_Code/UTIL1.c **** 
 507:../Generated_Code/UTIL1.c **** /*
 508:../Generated_Code/UTIL1.c **** ** ===================================================================
 509:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum8u (component Utility)
 510:../Generated_Code/UTIL1.c **** **     Description :
 511:../Generated_Code/UTIL1.c **** **         Appends a 8bit unsigned value to a string buffer.
 512:../Generated_Code/UTIL1.c **** **     Parameters  :
 513:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 514:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 515:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 516:../Generated_Code/UTIL1.c **** **                           bytes).
 517:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 518:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 519:../Generated_Code/UTIL1.c **** ** ===================================================================
 520:../Generated_Code/UTIL1.c **** */
 521:../Generated_Code/UTIL1.c **** /*!
 522:../Generated_Code/UTIL1.c ****   \brief appends a 8bit unsigned number to a string. Always terminates the result string.
 523:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 524:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 525:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 526:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 527:../Generated_Code/UTIL1.c ****   \param[in] val The 8bit unsigned number to add
 528:../Generated_Code/UTIL1.c ****   */
 529:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum8u(byte *dst, size_t dstSize, byte val)
 530:../Generated_Code/UTIL1.c **** {
 531:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("256")]; /* maximum buffer size we need */
 532:../Generated_Code/UTIL1.c **** 
 533:../Generated_Code/UTIL1.c ****   UTIL1_Num8uToStr(buf, sizeof(buf), val);
 534:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 535:../Generated_Code/UTIL1.c **** }
 536:../Generated_Code/UTIL1.c **** 
 537:../Generated_Code/UTIL1.c **** /*
 538:../Generated_Code/UTIL1.c **** ** ===================================================================
 539:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum8s (component Utility)
 540:../Generated_Code/UTIL1.c **** **     Description :
 541:../Generated_Code/UTIL1.c **** **         Appends a 8bit signed value to a string buffer.
 542:../Generated_Code/UTIL1.c **** **     Parameters  :
 543:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 544:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 545:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 546:../Generated_Code/UTIL1.c **** **                           bytes).
 547:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 548:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 549:../Generated_Code/UTIL1.c **** ** ===================================================================
 550:../Generated_Code/UTIL1.c **** */
 551:../Generated_Code/UTIL1.c **** /*!
 552:../Generated_Code/UTIL1.c ****   \brief appends a 8bit signed number to a string. Always terminates the result string.
 553:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 554:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 555:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 556:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 557:../Generated_Code/UTIL1.c ****   \param[in] val The 8bit signed number to add
 558:../Generated_Code/UTIL1.c ****   */
 559:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum8s(byte *dst, size_t dstSize, signed char val)
 560:../Generated_Code/UTIL1.c **** {
 561:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("-128")]; /* maximum buffer size we need */
 562:../Generated_Code/UTIL1.c **** 
 563:../Generated_Code/UTIL1.c ****   UTIL1_Num8sToStr(buf, sizeof(buf), val);
 564:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 565:../Generated_Code/UTIL1.c **** }
 566:../Generated_Code/UTIL1.c **** 
 567:../Generated_Code/UTIL1.c **** /*
 568:../Generated_Code/UTIL1.c **** ** ===================================================================
 569:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum16u (component Utility)
 570:../Generated_Code/UTIL1.c **** **     Description :
 571:../Generated_Code/UTIL1.c **** **         Appends a 16bit unsigned value to a string buffer.
 572:../Generated_Code/UTIL1.c **** **     Parameters  :
 573:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 574:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 575:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 576:../Generated_Code/UTIL1.c **** **                           bytes).
 577:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 578:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 579:../Generated_Code/UTIL1.c **** ** ===================================================================
 580:../Generated_Code/UTIL1.c **** */
 581:../Generated_Code/UTIL1.c **** /*!
 582:../Generated_Code/UTIL1.c ****   \brief appends a 16bit unsigned number to a string. Always terminates the result string.
 583:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 584:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 585:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 586:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 587:../Generated_Code/UTIL1.c ****   \param[in] val The 16bit unsigned number to add
 588:../Generated_Code/UTIL1.c ****   */
 589:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum16u(byte *dst, size_t dstSize, word val)
 590:../Generated_Code/UTIL1.c **** {
 591:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("32768")]; /* maximum buffer size we need */
 592:../Generated_Code/UTIL1.c **** 
 593:../Generated_Code/UTIL1.c ****   UTIL1_Num16uToStr(buf, sizeof(buf), val);
 594:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 595:../Generated_Code/UTIL1.c **** }
 596:../Generated_Code/UTIL1.c **** 
 597:../Generated_Code/UTIL1.c **** /*
 598:../Generated_Code/UTIL1.c **** ** ===================================================================
 599:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum16s (component Utility)
 600:../Generated_Code/UTIL1.c **** **     Description :
 601:../Generated_Code/UTIL1.c **** **         Appends a 16bit signed value to a string buffer.
 602:../Generated_Code/UTIL1.c **** **     Parameters  :
 603:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 604:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 605:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 606:../Generated_Code/UTIL1.c **** **                           bytes).
 607:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 608:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 609:../Generated_Code/UTIL1.c **** ** ===================================================================
 610:../Generated_Code/UTIL1.c **** */
 611:../Generated_Code/UTIL1.c **** /*!
 612:../Generated_Code/UTIL1.c ****   \brief appends a 16bit signed number to a string. Always terminates the result string.
 613:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 614:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 615:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 616:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 617:../Generated_Code/UTIL1.c ****   \param[in] val The 16bit signed number to add
 618:../Generated_Code/UTIL1.c ****   */
 619:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum16s(byte *dst, size_t dstSize, int16_t val)
 620:../Generated_Code/UTIL1.c **** {
 621:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("-32768")]; /* maximum buffer size we need */
 622:../Generated_Code/UTIL1.c **** 
 623:../Generated_Code/UTIL1.c ****   UTIL1_Num16sToStr(buf, sizeof(buf), val);
 624:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 625:../Generated_Code/UTIL1.c **** }
 626:../Generated_Code/UTIL1.c **** 
 627:../Generated_Code/UTIL1.c **** /*
 628:../Generated_Code/UTIL1.c **** ** ===================================================================
 629:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum16uFormatted (component Utility)
 630:../Generated_Code/UTIL1.c **** **     Description :
 631:../Generated_Code/UTIL1.c **** **         Appends a 16bit unsigned value to a string buffer in a
 632:../Generated_Code/UTIL1.c **** **         formatted way.
 633:../Generated_Code/UTIL1.c **** **     Parameters  :
 634:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 635:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 636:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 637:../Generated_Code/UTIL1.c **** **                           bytes).
 638:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 639:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 640:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 641:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 642:../Generated_Code/UTIL1.c **** ** ===================================================================
 643:../Generated_Code/UTIL1.c **** */
 644:../Generated_Code/UTIL1.c **** /*!
 645:../Generated_Code/UTIL1.c ****   \brief appends a 16bit unsigned number to a string, in a formatted way (like printf with "%0d".
 646:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 647:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 648:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 649:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 650:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 651:../Generated_Code/UTIL1.c ****   \param[in] val The 16bit unsigned number to add
 652:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character
 653:../Generated_Code/UTIL1.c ****   \param[in] nofFill Number of fill characters
 654:../Generated_Code/UTIL1.c ****   */
 655:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum16uFormatted(byte *dst, size_t dstSize, word val, char fill, byte nofFill)
 656:../Generated_Code/UTIL1.c **** {
 657:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("32768")]; /* maximum buffer size we need */
 658:../Generated_Code/UTIL1.c **** 
 659:../Generated_Code/UTIL1.c ****   UTIL1_Num16uToStrFormatted(buf, dstSize, val, fill, nofFill);
 660:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 661:../Generated_Code/UTIL1.c **** }
 662:../Generated_Code/UTIL1.c **** 
 663:../Generated_Code/UTIL1.c **** /*
 664:../Generated_Code/UTIL1.c **** ** ===================================================================
 665:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum16sFormatted (component Utility)
 666:../Generated_Code/UTIL1.c **** **     Description :
 667:../Generated_Code/UTIL1.c **** **         Appends a 16bit signed value to a string buffer in a
 668:../Generated_Code/UTIL1.c **** **         formatted way.
 669:../Generated_Code/UTIL1.c **** **     Parameters  :
 670:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 671:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 672:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 673:../Generated_Code/UTIL1.c **** **                           bytes).
 674:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 675:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 676:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 677:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 678:../Generated_Code/UTIL1.c **** ** ===================================================================
 679:../Generated_Code/UTIL1.c **** */
 680:../Generated_Code/UTIL1.c **** /*!
 681:../Generated_Code/UTIL1.c ****   \brief appends a 16bit signed number to a string, in a formatted way (like printf with "%0d".
 682:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 683:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 684:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 685:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 686:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 687:../Generated_Code/UTIL1.c ****   \param[in] val The 16bit signed number to add
 688:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character
 689:../Generated_Code/UTIL1.c ****   \param[in] nofFill Number of fill characters
 690:../Generated_Code/UTIL1.c ****   */
 691:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum16sFormatted(byte *dst, size_t dstSize, int16_t val, char fill, byte nofFill)
 692:../Generated_Code/UTIL1.c **** {
 693:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("-32768")]; /* maximum buffer size we need */
 694:../Generated_Code/UTIL1.c **** 
 695:../Generated_Code/UTIL1.c ****   UTIL1_Num16sToStrFormatted(buf, dstSize, val, fill, nofFill);
 696:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 697:../Generated_Code/UTIL1.c **** }
 698:../Generated_Code/UTIL1.c **** 
 699:../Generated_Code/UTIL1.c **** /*
 700:../Generated_Code/UTIL1.c **** ** ===================================================================
 701:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum32uFormatted (component Utility)
 702:../Generated_Code/UTIL1.c **** **     Description :
 703:../Generated_Code/UTIL1.c **** **         Appends a 32bit unsigned value to a string buffer in a
 704:../Generated_Code/UTIL1.c **** **         formatted way.
 705:../Generated_Code/UTIL1.c **** **     Parameters  :
 706:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 707:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 708:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 709:../Generated_Code/UTIL1.c **** **                           bytes).
 710:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 711:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 712:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 713:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 714:../Generated_Code/UTIL1.c **** ** ===================================================================
 715:../Generated_Code/UTIL1.c **** */
 716:../Generated_Code/UTIL1.c **** /*!
 717:../Generated_Code/UTIL1.c ****   \brief appends a 32bit unsigned number to a string, in a formatted way (like printf with "%0d".
 718:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 719:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 720:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 721:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 722:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 723:../Generated_Code/UTIL1.c ****   \param[in] val The 32bit unsigned number to add
 724:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character
 725:../Generated_Code/UTIL1.c ****   \param[in] nofFill Number of fill characters
 726:../Generated_Code/UTIL1.c ****   */
 727:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum32uFormatted(byte *dst, size_t dstSize, dword val, char fill, byte nofFill)
 728:../Generated_Code/UTIL1.c **** {
 729:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("4294967295")]; /* maximum buffer size we need */
 730:../Generated_Code/UTIL1.c **** 
 731:../Generated_Code/UTIL1.c ****   UTIL1_Num32uToStrFormatted(buf, dstSize, val, fill, nofFill);
 732:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 733:../Generated_Code/UTIL1.c **** }
 734:../Generated_Code/UTIL1.c **** 
 735:../Generated_Code/UTIL1.c **** /*
 736:../Generated_Code/UTIL1.c **** ** ===================================================================
 737:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum32sFormatted (component Utility)
 738:../Generated_Code/UTIL1.c **** **     Description :
 739:../Generated_Code/UTIL1.c **** **         Appends a 32bit signed value to a string buffer in a
 740:../Generated_Code/UTIL1.c **** **         formatted way.
 741:../Generated_Code/UTIL1.c **** **     Parameters  :
 742:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 743:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 744:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 745:../Generated_Code/UTIL1.c **** **                           bytes).
 746:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 747:../Generated_Code/UTIL1.c **** **         fill            - Fill character
 748:../Generated_Code/UTIL1.c **** **         nofFill         - Number of fill characters
 749:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 750:../Generated_Code/UTIL1.c **** ** ===================================================================
 751:../Generated_Code/UTIL1.c **** */
 752:../Generated_Code/UTIL1.c **** /*!
 753:../Generated_Code/UTIL1.c ****   \brief appends a 32bit signed number to a string, in a formatted way (like printf with "%0d".
 754:../Generated_Code/UTIL1.c ****      Always terminates the result string.
 755:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 756:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 757:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 758:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 759:../Generated_Code/UTIL1.c ****   \param[in] val The 32bit signed number to add
 760:../Generated_Code/UTIL1.c ****   \param[in] fill Fill character
 761:../Generated_Code/UTIL1.c ****   \param[in] nofFill Number of fill characters
 762:../Generated_Code/UTIL1.c ****   */
 763:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum32sFormatted(byte *dst, size_t dstSize, long val, char fill, byte nofFill)
 764:../Generated_Code/UTIL1.c **** {
 765:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("-4294967295")]; /* maximum buffer size we need */
 766:../Generated_Code/UTIL1.c **** 
 767:../Generated_Code/UTIL1.c ****   UTIL1_Num32sToStrFormatted(buf, dstSize, val, fill, nofFill);
 768:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 769:../Generated_Code/UTIL1.c **** }
 770:../Generated_Code/UTIL1.c **** 
 771:../Generated_Code/UTIL1.c **** /*
 772:../Generated_Code/UTIL1.c **** ** ===================================================================
 773:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum8Hex (component Utility)
 774:../Generated_Code/UTIL1.c **** **     Description :
 775:../Generated_Code/UTIL1.c **** **         Appends a 8bit unsigned value to a buffer as hex number
 776:../Generated_Code/UTIL1.c **** **         (without a 0x prefix).
 777:../Generated_Code/UTIL1.c **** **     Parameters  :
 778:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 779:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 780:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 781:../Generated_Code/UTIL1.c **** **                           bytes).
 782:../Generated_Code/UTIL1.c **** **         num             - Value to convert.
 783:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 784:../Generated_Code/UTIL1.c **** ** ===================================================================
 785:../Generated_Code/UTIL1.c **** */
 786:../Generated_Code/UTIL1.c **** /*!
 787:../Generated_Code/UTIL1.c ****   \brief Adds a 8bit number as hex value to a string.
 788:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 789:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 790:../Generated_Code/UTIL1.c ****   \param[in] num The 8bit number to add
 791:../Generated_Code/UTIL1.c ****   */
 792:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum8Hex(byte *dst, size_t dstSize, byte num)
 793:../Generated_Code/UTIL1.c **** {
 794:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("FF")]; /* maximum buffer size we need */
 795:../Generated_Code/UTIL1.c ****   unsigned char hex;
 796:../Generated_Code/UTIL1.c **** 
 797:../Generated_Code/UTIL1.c ****   buf[2] = '\0';
 798:../Generated_Code/UTIL1.c ****   hex = (char)(num & 0x0F);
 799:../Generated_Code/UTIL1.c ****   buf[1] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 800:../Generated_Code/UTIL1.c ****   hex = (char)((num>>4) & 0x0F);
 801:../Generated_Code/UTIL1.c ****   buf[0] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 802:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 803:../Generated_Code/UTIL1.c **** }
 804:../Generated_Code/UTIL1.c **** 
 805:../Generated_Code/UTIL1.c **** /*
 806:../Generated_Code/UTIL1.c **** ** ===================================================================
 807:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum16Hex (component Utility)
 808:../Generated_Code/UTIL1.c **** **     Description :
 809:../Generated_Code/UTIL1.c **** **         Appends a 16bit unsigned value to a buffer as hex number
 810:../Generated_Code/UTIL1.c **** **         (without a 0x prefix).
 811:../Generated_Code/UTIL1.c **** **     Parameters  :
 812:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 813:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 814:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 815:../Generated_Code/UTIL1.c **** **                           bytes).
 816:../Generated_Code/UTIL1.c **** **         num             - Value to convert.
 817:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 818:../Generated_Code/UTIL1.c **** ** ===================================================================
 819:../Generated_Code/UTIL1.c **** */
 820:../Generated_Code/UTIL1.c **** /*!
 821:../Generated_Code/UTIL1.c ****   \brief Adds a 16bit number as hex value to a string.
 822:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 823:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 824:../Generated_Code/UTIL1.c ****   \param[in] num The 16bit number to add
 825:../Generated_Code/UTIL1.c ****   */
 826:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum16Hex(byte *dst, size_t dstSize, word num)
 827:../Generated_Code/UTIL1.c **** {
 828:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("FFFF")]; /* maximum buffer size we need */
 829:../Generated_Code/UTIL1.c ****   unsigned char hex;
 830:../Generated_Code/UTIL1.c ****   int8_t i;
 831:../Generated_Code/UTIL1.c **** 
 832:../Generated_Code/UTIL1.c ****   buf[4] = '\0';
 833:../Generated_Code/UTIL1.c ****   i = 3;
 834:../Generated_Code/UTIL1.c ****   do {
 835:../Generated_Code/UTIL1.c ****     hex = (char)(num & 0x0F);
 836:../Generated_Code/UTIL1.c ****     buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 837:../Generated_Code/UTIL1.c ****     num >>= 4;                          /* next nibble */
 838:../Generated_Code/UTIL1.c ****     i--;
 839:../Generated_Code/UTIL1.c ****   } while (i>=0);
 840:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 841:../Generated_Code/UTIL1.c **** }
 842:../Generated_Code/UTIL1.c **** 
 843:../Generated_Code/UTIL1.c **** /*
 844:../Generated_Code/UTIL1.c **** ** ===================================================================
 845:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum24Hex (component Utility)
 846:../Generated_Code/UTIL1.c **** **     Description :
 847:../Generated_Code/UTIL1.c **** **         Appends a 32bit unsigned value to a buffer as hex number
 848:../Generated_Code/UTIL1.c **** **         (without a 0x prefix). Only 24bits are used.
 849:../Generated_Code/UTIL1.c **** **     Parameters  :
 850:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 851:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 852:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 853:../Generated_Code/UTIL1.c **** **                           bytes).
 854:../Generated_Code/UTIL1.c **** **         num             - Value to convert.
 855:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 856:../Generated_Code/UTIL1.c **** ** ===================================================================
 857:../Generated_Code/UTIL1.c **** */
 858:../Generated_Code/UTIL1.c **** /*!
 859:../Generated_Code/UTIL1.c ****   \brief Adds a 24bit number as hex value to a string.
 860:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 861:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 862:../Generated_Code/UTIL1.c ****   \param[in] num The 24bit number to add
 863:../Generated_Code/UTIL1.c ****   */
 864:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum24Hex(byte *dst, size_t dstSize, dword num)
 865:../Generated_Code/UTIL1.c **** {
 866:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("FFFFFF")]; /* maximum buffer size we need */
 867:../Generated_Code/UTIL1.c ****   unsigned char hex;
 868:../Generated_Code/UTIL1.c ****   int8_t i;
 869:../Generated_Code/UTIL1.c **** 
 870:../Generated_Code/UTIL1.c ****   buf[6] = '\0';
 871:../Generated_Code/UTIL1.c ****   i = 5;
 872:../Generated_Code/UTIL1.c ****   do {
 873:../Generated_Code/UTIL1.c ****     hex = (char)(num & 0x0F);
 874:../Generated_Code/UTIL1.c ****     buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 875:../Generated_Code/UTIL1.c ****     num >>= 4;                          /* next nibble */
 876:../Generated_Code/UTIL1.c ****     i--;
 877:../Generated_Code/UTIL1.c ****   } while (i>=0);
 878:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 879:../Generated_Code/UTIL1.c **** }
 880:../Generated_Code/UTIL1.c **** 
 881:../Generated_Code/UTIL1.c **** /*
 882:../Generated_Code/UTIL1.c **** ** ===================================================================
 883:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum32Hex (component Utility)
 884:../Generated_Code/UTIL1.c **** **     Description :
 885:../Generated_Code/UTIL1.c **** **         Appends a 16bit unsigned value to a buffer as hex number
 886:../Generated_Code/UTIL1.c **** **         (without a 0x prefix).
 887:../Generated_Code/UTIL1.c **** **     Parameters  :
 888:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 889:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 890:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 891:../Generated_Code/UTIL1.c **** **                           bytes).
 892:../Generated_Code/UTIL1.c **** **         num             - Value to convert.
 893:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 894:../Generated_Code/UTIL1.c **** ** ===================================================================
 895:../Generated_Code/UTIL1.c **** */
 896:../Generated_Code/UTIL1.c **** /*!
 897:../Generated_Code/UTIL1.c ****   \brief Adds a 32bit number as hex value to a string.
 898:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 899:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 900:../Generated_Code/UTIL1.c ****   \param[in] num The 32bit number to add
 901:../Generated_Code/UTIL1.c ****   */
 902:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum32Hex(byte *dst, size_t dstSize, dword num)
 903:../Generated_Code/UTIL1.c **** {
 904:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("FFFFFFFF")]; /* maximum buffer size we need */
 905:../Generated_Code/UTIL1.c ****   unsigned char hex;
 906:../Generated_Code/UTIL1.c ****   int8_t i;
 907:../Generated_Code/UTIL1.c **** 
 908:../Generated_Code/UTIL1.c ****   buf[8] = '\0';
 909:../Generated_Code/UTIL1.c ****   i = 7;
 910:../Generated_Code/UTIL1.c ****   do {
 911:../Generated_Code/UTIL1.c ****     hex = (char)(num & 0x0F);
 912:../Generated_Code/UTIL1.c ****     buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 913:../Generated_Code/UTIL1.c ****     num >>= 4;                          /* next nibble */
 914:../Generated_Code/UTIL1.c ****     i--;
 915:../Generated_Code/UTIL1.c ****   } while (i>=0);
 916:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 917:../Generated_Code/UTIL1.c **** }
 918:../Generated_Code/UTIL1.c **** 
 919:../Generated_Code/UTIL1.c **** /*
 920:../Generated_Code/UTIL1.c **** ** ===================================================================
 921:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum32s (component Utility)
 922:../Generated_Code/UTIL1.c **** **     Description :
 923:../Generated_Code/UTIL1.c **** **         Appends a 32bit signed value to a string buffer.
 924:../Generated_Code/UTIL1.c **** **     Parameters  :
 925:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 926:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 927:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 928:../Generated_Code/UTIL1.c **** **                           bytes).
 929:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 930:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 931:../Generated_Code/UTIL1.c **** ** ===================================================================
 932:../Generated_Code/UTIL1.c **** */
 933:../Generated_Code/UTIL1.c **** /*!
 934:../Generated_Code/UTIL1.c ****   \brief appends a 32bit (long) number to a string. Always terminates the result string.
 935:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 936:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 937:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 938:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 939:../Generated_Code/UTIL1.c ****   \param[in] val The 32bit number to add
 940:../Generated_Code/UTIL1.c ****   */
 941:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum32s(byte *dst, size_t dstSize, long val)
 942:../Generated_Code/UTIL1.c **** {
 943:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("-4294967295")]; /* maximum buffer size we need */
 944:../Generated_Code/UTIL1.c **** 
 945:../Generated_Code/UTIL1.c ****   UTIL1_Num32sToStr(buf, sizeof(buf), val);
 946:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 947:../Generated_Code/UTIL1.c **** }
 948:../Generated_Code/UTIL1.c **** 
 949:../Generated_Code/UTIL1.c **** /*
 950:../Generated_Code/UTIL1.c **** ** ===================================================================
 951:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcatNum32u (component Utility)
 952:../Generated_Code/UTIL1.c **** **     Description :
 953:../Generated_Code/UTIL1.c **** **         Appends a 32bit signed value to a string buffer.
 954:../Generated_Code/UTIL1.c **** **     Parameters  :
 955:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 956:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 957:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 958:../Generated_Code/UTIL1.c **** **                           bytes).
 959:../Generated_Code/UTIL1.c **** **         val             - Value to convert.
 960:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 961:../Generated_Code/UTIL1.c **** ** ===================================================================
 962:../Generated_Code/UTIL1.c **** */
 963:../Generated_Code/UTIL1.c **** /*!
 964:../Generated_Code/UTIL1.c ****   \brief appends a 32bit (unsigned long) number to a string. Always terminates the result string.
 965:../Generated_Code/UTIL1.c ****      Note: count is the size of dst INCLUDING zero byte.
 966:../Generated_Code/UTIL1.c ****      Precondition: src, dst != NULL
 967:../Generated_Code/UTIL1.c ****   \param[in,out] dst Start of buffer, where to append the number string
 968:../Generated_Code/UTIL1.c ****   \param[in] dstSize The size of the buffer, including the zero byte
 969:../Generated_Code/UTIL1.c ****   \param[in] val The 32bit unsigned number to add
 970:../Generated_Code/UTIL1.c ****   */
 971:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum32u(byte *dst, size_t dstSize, dword val)
 972:../Generated_Code/UTIL1.c **** {
 973:../Generated_Code/UTIL1.c ****   unsigned char buf[sizeof("4294967295")]; /* maximum buffer size we need */
 974:../Generated_Code/UTIL1.c **** 
 975:../Generated_Code/UTIL1.c ****   UTIL1_Num32uToStr(buf, sizeof(buf), val);
 976:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 977:../Generated_Code/UTIL1.c **** }
 978:../Generated_Code/UTIL1.c **** 
 979:../Generated_Code/UTIL1.c **** /*
 980:../Generated_Code/UTIL1.c **** ** ===================================================================
 981:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num32sToStr (component Utility)
 982:../Generated_Code/UTIL1.c **** **     Description :
 983:../Generated_Code/UTIL1.c **** **         Converts a signed 32bit value into a string.
 984:../Generated_Code/UTIL1.c **** **     Parameters  :
 985:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
 986:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
 987:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
 988:../Generated_Code/UTIL1.c **** **                           bytes).
 989:../Generated_Code/UTIL1.c **** **         val             - Value to be converted.
 990:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
 991:../Generated_Code/UTIL1.c **** ** ===================================================================
 992:../Generated_Code/UTIL1.c **** */
 993:../Generated_Code/UTIL1.c **** /*!
 994:../Generated_Code/UTIL1.c ****   \brief Converts a 32bit number to a string.
 995:../Generated_Code/UTIL1.c ****   \param[in,out] dst String buffer to store the number.
 996:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer in bytes.
 997:../Generated_Code/UTIL1.c ****   \param[in] val 32bit signed number to convert.
 998:../Generated_Code/UTIL1.c ****  */
 999:../Generated_Code/UTIL1.c **** void UTIL1_Num32sToStr(byte *dst, size_t dstSize, long val)
1000:../Generated_Code/UTIL1.c **** {
1001:../Generated_Code/UTIL1.c ****   unsigned char *ptr =  ((unsigned char *)dst);
1002:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
1003:../Generated_Code/UTIL1.c ****   unsigned char tmp;
1004:../Generated_Code/UTIL1.c ****   unsigned char sign = (unsigned char)(val < 0);
1005:../Generated_Code/UTIL1.c **** 
1006:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
1007:../Generated_Code/UTIL1.c ****   if (sign){
1008:../Generated_Code/UTIL1.c ****     val *= -1;
1009:../Generated_Code/UTIL1.c ****   }
1010:../Generated_Code/UTIL1.c ****   if (val == 0 && dstSize > 0){
1011:../Generated_Code/UTIL1.c ****     ptr[i++] = '0';
1012:../Generated_Code/UTIL1.c ****     dstSize--;
1013:../Generated_Code/UTIL1.c ****   }
1014:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
1015:../Generated_Code/UTIL1.c ****     ptr[i++] = (unsigned char)((val % 10) + '0');
1016:../Generated_Code/UTIL1.c ****     dstSize--;
1017:../Generated_Code/UTIL1.c ****     val /= 10;
1018:../Generated_Code/UTIL1.c ****   }
1019:../Generated_Code/UTIL1.c ****   if (sign && dstSize > 0){
1020:../Generated_Code/UTIL1.c ****     ptr[i++] = '-';
1021:../Generated_Code/UTIL1.c ****     dstSize--;
1022:../Generated_Code/UTIL1.c ****   }
1023:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
1024:../Generated_Code/UTIL1.c ****     tmp = ptr[j];
1025:../Generated_Code/UTIL1.c ****     ptr[j] = ptr[(i-j)-1];
1026:../Generated_Code/UTIL1.c ****     ptr[(i-j)-1] = tmp;
1027:../Generated_Code/UTIL1.c ****   }
1028:../Generated_Code/UTIL1.c ****   ptr[i] = '\0';
1029:../Generated_Code/UTIL1.c **** }
1030:../Generated_Code/UTIL1.c **** 
1031:../Generated_Code/UTIL1.c **** /*
1032:../Generated_Code/UTIL1.c **** ** ===================================================================
1033:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_Num32uToStr (component Utility)
1034:../Generated_Code/UTIL1.c **** **     Description :
1035:../Generated_Code/UTIL1.c **** **         Converts an unsigned 32bit value into a string.
1036:../Generated_Code/UTIL1.c **** **     Parameters  :
1037:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1038:../Generated_Code/UTIL1.c **** **       * dst             - Pointer to destination string
1039:../Generated_Code/UTIL1.c **** **         dstSize         - Size of the destination buffer (in
1040:../Generated_Code/UTIL1.c **** **                           bytes).
1041:../Generated_Code/UTIL1.c **** **         val             - Value to be converted.
1042:../Generated_Code/UTIL1.c **** **     Returns     : Nothing
1043:../Generated_Code/UTIL1.c **** ** ===================================================================
1044:../Generated_Code/UTIL1.c **** */
1045:../Generated_Code/UTIL1.c **** /*!
1046:../Generated_Code/UTIL1.c ****   \brief Converts a 32bit signed number to a string.
1047:../Generated_Code/UTIL1.c ****   \param[in,out] dst String buffer to store the number.
1048:../Generated_Code/UTIL1.c ****   \param[in] dstSize Size of the destination buffer in bytes.
1049:../Generated_Code/UTIL1.c ****   \param[in] val 32bit unsigned number to convert.
1050:../Generated_Code/UTIL1.c ****  */
1051:../Generated_Code/UTIL1.c **** void UTIL1_Num32uToStr(byte *dst, size_t dstSize, dword val)
1052:../Generated_Code/UTIL1.c **** {
1053:../Generated_Code/UTIL1.c ****   unsigned char *ptr = ((unsigned char *)dst);
1054:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
1055:../Generated_Code/UTIL1.c ****   unsigned char tmp;
1056:../Generated_Code/UTIL1.c **** 
1057:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
1058:../Generated_Code/UTIL1.c ****   if (val == 0 && dstSize > 0){
1059:../Generated_Code/UTIL1.c ****     ptr[i++] = '0';
1060:../Generated_Code/UTIL1.c ****     dstSize--;
1061:../Generated_Code/UTIL1.c ****   }
1062:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
1063:../Generated_Code/UTIL1.c ****     ptr[i++] = (unsigned char)((val % 10) + '0');
1064:../Generated_Code/UTIL1.c ****     dstSize--;
1065:../Generated_Code/UTIL1.c ****     val /= 10;
1066:../Generated_Code/UTIL1.c ****   }
1067:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
1068:../Generated_Code/UTIL1.c ****     tmp = ptr[j];
1069:../Generated_Code/UTIL1.c ****     ptr[j] = ptr[(i-j)-1];
1070:../Generated_Code/UTIL1.c ****     ptr[(i-j)-1] = tmp;
1071:../Generated_Code/UTIL1.c ****   }
1072:../Generated_Code/UTIL1.c ****   ptr[i] = '\0';
1073:../Generated_Code/UTIL1.c **** }
1074:../Generated_Code/UTIL1.c **** 
1075:../Generated_Code/UTIL1.c **** /*
1076:../Generated_Code/UTIL1.c **** ** ===================================================================
1077:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_IsLeapYear (component Utility)
1078:../Generated_Code/UTIL1.c **** **     Description :
1079:../Generated_Code/UTIL1.c **** **         Returns true if a given year is a leap year
1080:../Generated_Code/UTIL1.c **** **     Parameters  :
1081:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1082:../Generated_Code/UTIL1.c **** **         year            - Year, in the YYYY format.
1083:../Generated_Code/UTIL1.c **** **     Returns     :
1084:../Generated_Code/UTIL1.c **** **         ---             - If the year is a leap year or not.
1085:../Generated_Code/UTIL1.c **** ** ===================================================================
1086:../Generated_Code/UTIL1.c **** */
1087:../Generated_Code/UTIL1.c **** bool UTIL1_IsLeapYear(word year)
1088:../Generated_Code/UTIL1.c **** {
1089:../Generated_Code/UTIL1.c ****   return ((((year%4)==0) && (year%100)!=0) || (year%400)==0);
1090:../Generated_Code/UTIL1.c **** }
1091:../Generated_Code/UTIL1.c **** 
1092:../Generated_Code/UTIL1.c **** /*
1093:../Generated_Code/UTIL1.c **** ** ===================================================================
1094:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_WeekDay (component Utility)
1095:../Generated_Code/UTIL1.c **** **     Description :
1096:../Generated_Code/UTIL1.c **** **         Returns the weekday for a given date >= 1.Jan.1900
1097:../Generated_Code/UTIL1.c **** **     Parameters  :
1098:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1099:../Generated_Code/UTIL1.c **** **         year            - year in YYYY format
1100:../Generated_Code/UTIL1.c **** **         month           - month of the year (1: January, 2:
1101:../Generated_Code/UTIL1.c **** **                           February, etc)
1102:../Generated_Code/UTIL1.c **** **         day             - day of the moth (starting with 1)
1103:../Generated_Code/UTIL1.c **** **     Returns     :
1104:../Generated_Code/UTIL1.c **** **         ---             - Returns the weekday, 0 for Sunday, 1 for
1105:../Generated_Code/UTIL1.c **** **                           Monday, 2 for Tuesday, etc.
1106:../Generated_Code/UTIL1.c **** ** ===================================================================
1107:../Generated_Code/UTIL1.c **** */
1108:../Generated_Code/UTIL1.c **** byte UTIL1_WeekDay(word year, byte month, byte day)
1109:../Generated_Code/UTIL1.c **** {
1110:../Generated_Code/UTIL1.c ****   /* see http://klausler.com/new-dayofweek.html */
1111:../Generated_Code/UTIL1.c ****   static const byte skew[12] = {0,3,3,6,1,4,6,2,5,0,3,5};
1112:../Generated_Code/UTIL1.c ****   word sum;
1113:../Generated_Code/UTIL1.c **** 
1114:../Generated_Code/UTIL1.c ****   sum = (word)(year-1900);
1115:../Generated_Code/UTIL1.c ****   sum += sum/4;
1116:../Generated_Code/UTIL1.c ****   sum %= 7;
1117:../Generated_Code/UTIL1.c ****   if (UTIL1_IsLeapYear(year) && (month==1 || month==2)) {
1118:../Generated_Code/UTIL1.c ****     sum--;
1119:../Generated_Code/UTIL1.c ****   }
1120:../Generated_Code/UTIL1.c ****   sum += day;
1121:../Generated_Code/UTIL1.c ****   sum %= 7;
1122:../Generated_Code/UTIL1.c ****   sum += skew[month-1];
1123:../Generated_Code/UTIL1.c ****   sum %= 7;
1124:../Generated_Code/UTIL1.c ****   return (byte)sum; /* 0: Sunday, 1: Monday, 2: Tuesday, 3: Wednesday, ... */
1125:../Generated_Code/UTIL1.c **** }
1126:../Generated_Code/UTIL1.c **** 
1127:../Generated_Code/UTIL1.c **** /*
1128:../Generated_Code/UTIL1.c **** ** ===================================================================
1129:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ReadEscapedName (component Utility)
1130:../Generated_Code/UTIL1.c **** **     Description :
1131:../Generated_Code/UTIL1.c **** **         Scans an escaped name from a string. This is useful e.g. for
1132:../Generated_Code/UTIL1.c **** **         double quoted file names.
1133:../Generated_Code/UTIL1.c **** **     Parameters  :
1134:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1135:../Generated_Code/UTIL1.c **** **       * filename        - the name to be copied. Names may
1136:../Generated_Code/UTIL1.c **** **                           be in quoted format
1137:../Generated_Code/UTIL1.c **** **       * destname        - the destination of the copy.
1138:../Generated_Code/UTIL1.c **** **                           Names are not in quoted format. destname
1139:../Generated_Code/UTIL1.c **** **                           may be NULL to get the other return values
1140:../Generated_Code/UTIL1.c **** **                           only
1141:../Generated_Code/UTIL1.c **** **         maxlen          - length allocated for destname
1142:../Generated_Code/UTIL1.c **** **       * lenRead         - length read in filename to copy
1143:../Generated_Code/UTIL1.c **** **                           the whole name. Note that filenames maybe
1144:../Generated_Code/UTIL1.c **** **                           space terminated, so *lenRead <
1145:../Generated_Code/UTIL1.c **** **                           strlen(filename)
1146:../Generated_Code/UTIL1.c **** **         lenWritten      - the size written in destname.
1147:../Generated_Code/UTIL1.c **** **                           In case of overflows in destname,
1148:../Generated_Code/UTIL1.c **** **                           lenWritten is still increased but destname
1149:../Generated_Code/UTIL1.c **** **                           no longer written. The have the string
1150:../Generated_Code/UTIL1.c **** **                           length in these cases use strlen(destname)
1151:../Generated_Code/UTIL1.c **** **         terminators     - additional characters
1152:../Generated_Code/UTIL1.c **** **                           where a name should terminate. May be NULL
1153:../Generated_Code/UTIL1.c **** **     Returns     :
1154:../Generated_Code/UTIL1.c **** **         ---             - Error code
1155:../Generated_Code/UTIL1.c **** ** ===================================================================
1156:../Generated_Code/UTIL1.c **** */
1157:../Generated_Code/UTIL1.c **** byte UTIL1_ReadEscapedName(const unsigned char *filename, byte *destname, size_t maxlen, size_t *le
1158:../Generated_Code/UTIL1.c **** {
1159:../Generated_Code/UTIL1.c ****   size_t lenCopied = 0, lenOverread = 0;
1160:../Generated_Code/UTIL1.c ****   bool quoteMode = FALSE;  /* quoteMode means the name is surrounded by ". In this mode, only a sec
1161:../Generated_Code/UTIL1.c ****                               terminates the string. In !quoteMode a space or a '\0' may also termi
1162:../Generated_Code/UTIL1.c ****   bool res = ERR_OK;
1163:../Generated_Code/UTIL1.c ****   #define IS_SPACE(ch) ((ch)==' '||(ch)=='\t'||(ch)=='\n'||(ch)=='\v'||(ch)=='\f'||(ch)=='\r')
1164:../Generated_Code/UTIL1.c **** 
1165:../Generated_Code/UTIL1.c ****   if (filename==NULL || (destname!=NULL && maxlen<=0)) {
1166:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
1167:../Generated_Code/UTIL1.c ****   }
1168:../Generated_Code/UTIL1.c ****   if (filename[0] == '"') { /* translated mode */
1169:../Generated_Code/UTIL1.c ****     filename++; /* overread '"' */
1170:../Generated_Code/UTIL1.c ****     lenOverread++;
1171:../Generated_Code/UTIL1.c ****     quoteMode=TRUE;
1172:../Generated_Code/UTIL1.c ****   }
1173:../Generated_Code/UTIL1.c ****   if (terminators == NULL) {
1174:../Generated_Code/UTIL1.c ****     terminators = "";
1175:../Generated_Code/UTIL1.c ****   }
1176:../Generated_Code/UTIL1.c ****   for (;;) {
1177:../Generated_Code/UTIL1.c ****     if (quoteMode) {
1178:../Generated_Code/UTIL1.c ****       if (filename[0] == '"') {
1179:../Generated_Code/UTIL1.c ****         filename++; /* overread '"' */
1180:../Generated_Code/UTIL1.c ****         lenOverread++;
1181:../Generated_Code/UTIL1.c ****         if (filename[0] != '"') { /* quoteMode is terminated by a single quote. A double quote is t
1182:../Generated_Code/UTIL1.c ****           break; /* successfully finished with this name */
1183:../Generated_Code/UTIL1.c ****         } /* else we copy the second quote " */
1184:../Generated_Code/UTIL1.c ****       }
1185:../Generated_Code/UTIL1.c ****       if (filename[0] == '\0') { /* unexpected 0. stop */
1186:../Generated_Code/UTIL1.c ****         res = ERR_FAILED;
1187:../Generated_Code/UTIL1.c ****         break; /* error case: no terminating double quote (") was found */
1188:../Generated_Code/UTIL1.c ****       }
1189:../Generated_Code/UTIL1.c ****     } else { /* copy mode */
1190:../Generated_Code/UTIL1.c ****       if (IS_SPACE(filename[0]) || filename[0] == '\0' || strchr(terminators, filename[0]) != NULL)
1191:../Generated_Code/UTIL1.c ****         break;
1192:../Generated_Code/UTIL1.c ****       }
1193:../Generated_Code/UTIL1.c ****     }
1194:../Generated_Code/UTIL1.c ****     if (destname != NULL) {
1195:../Generated_Code/UTIL1.c ****       if (lenCopied + 1 < maxlen) {
1196:../Generated_Code/UTIL1.c ****         destname[0] = filename[0];
1197:../Generated_Code/UTIL1.c ****         destname++;
1198:../Generated_Code/UTIL1.c ****       } else {
1199:../Generated_Code/UTIL1.c ****         destname[0] = '\0'; /* terminate string */
1200:../Generated_Code/UTIL1.c ****         destname = NULL; /* avoid it to overwrite not allocated space */
1201:../Generated_Code/UTIL1.c ****       }
1202:../Generated_Code/UTIL1.c ****     }
1203:../Generated_Code/UTIL1.c ****     lenCopied++;
1204:../Generated_Code/UTIL1.c ****     filename++;
1205:../Generated_Code/UTIL1.c ****   }
1206:../Generated_Code/UTIL1.c ****   if (destname != NULL) {
1207:../Generated_Code/UTIL1.c ****     destname[0] = '\0';
1208:../Generated_Code/UTIL1.c ****   }
1209:../Generated_Code/UTIL1.c ****   if (lenRead != NULL) {
1210:../Generated_Code/UTIL1.c ****     *lenRead = lenCopied+lenOverread;
1211:../Generated_Code/UTIL1.c ****   }
1212:../Generated_Code/UTIL1.c ****   if (lenWritten != NULL) {
1213:../Generated_Code/UTIL1.c ****     *lenWritten = lenCopied + 1; /* additionally a zero byte written */
1214:../Generated_Code/UTIL1.c ****   }
1215:../Generated_Code/UTIL1.c ****   return res;
1216:../Generated_Code/UTIL1.c **** }
1217:../Generated_Code/UTIL1.c **** 
1218:../Generated_Code/UTIL1.c **** /*
1219:../Generated_Code/UTIL1.c **** ** ===================================================================
1220:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_xatoi (component Utility)
1221:../Generated_Code/UTIL1.c **** **     Description :
1222:../Generated_Code/UTIL1.c **** **         Custom atoi() (ascii to int) implementation by Elm Chan
1223:../Generated_Code/UTIL1.c **** **     Parameters  :
1224:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1225:../Generated_Code/UTIL1.c **** **       * str             - Pointer to string to scan. Returns until
1226:../Generated_Code/UTIL1.c **** **                           where it has scanned.
1227:../Generated_Code/UTIL1.c **** **       * res             - Pointer to where to store the result
1228:../Generated_Code/UTIL1.c **** **     Returns     :
1229:../Generated_Code/UTIL1.c **** **         ---             - Error code
1230:../Generated_Code/UTIL1.c **** ** ===================================================================
1231:../Generated_Code/UTIL1.c **** */
1232:../Generated_Code/UTIL1.c **** /*------------------------------------------------------------------------/
1233:../Generated_Code/UTIL1.c **** /  Universal string handler for user console interface
1234:../Generated_Code/UTIL1.c **** /-------------------------------------------------------------------------/
1235:../Generated_Code/UTIL1.c **** /
1236:../Generated_Code/UTIL1.c **** /  Copyright (C) 2010, ChaN, all right reserved.
1237:../Generated_Code/UTIL1.c **** /
1238:../Generated_Code/UTIL1.c **** / * This software is a free software and there is NO WARRANTY.
1239:../Generated_Code/UTIL1.c **** / * No restriction on use. You can use, modify and redistribute it for
1240:../Generated_Code/UTIL1.c **** /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
1241:../Generated_Code/UTIL1.c **** / * Redistributions of source code must retain the above copyright notice.
1242:../Generated_Code/UTIL1.c **** /
1243:../Generated_Code/UTIL1.c **** /-------------------------------------------------------------------------*/
1244:../Generated_Code/UTIL1.c **** #ifdef __HC12__
1245:../Generated_Code/UTIL1.c ****   #pragma MESSAGE DISABLE C12056  /* message about SP debug info */
1246:../Generated_Code/UTIL1.c **** #endif
1247:../Generated_Code/UTIL1.c **** byte UTIL1_xatoi(const unsigned char **str, long *res)
1248:../Generated_Code/UTIL1.c **** {
1249:../Generated_Code/UTIL1.c **** /* 123 -5   0x3ff 0b1111 0377 3.25  w "
1250:../Generated_Code/UTIL1.c ****       ^                               1st call returns 123 and next ptr
1251:../Generated_Code/UTIL1.c ****          ^                            2nd call returns -5 and next ptr
1252:../Generated_Code/UTIL1.c ****                  ^                    3rd call returns 1023 and next ptr
1253:../Generated_Code/UTIL1.c ****                         ^             4th call returns 15 and next ptr
1254:../Generated_Code/UTIL1.c ****                              ^        5th call returns 255 and next ptr
1255:../Generated_Code/UTIL1.c ****                                ^      6th call returns 3 and next ptr, caller needs to read '.'
1256:../Generated_Code/UTIL1.c ****                                  ^    7th call returns 25 and next ptr
1257:../Generated_Code/UTIL1.c ****                                     ^ 8th call fails and returns ERR_FAILED
1258:../Generated_Code/UTIL1.c **** */
1259:../Generated_Code/UTIL1.c ****   unsigned long val;
1260:../Generated_Code/UTIL1.c ****   unsigned char c, r, s = 0;
1261:../Generated_Code/UTIL1.c **** 
1262:../Generated_Code/UTIL1.c ****   *res = 0;
1263:../Generated_Code/UTIL1.c ****   while (**str==' ') {
1264:../Generated_Code/UTIL1.c ****     (*str)++;                          /* Skip leading spaces */
1265:../Generated_Code/UTIL1.c ****   }
1266:../Generated_Code/UTIL1.c ****   c = **str;
1267:../Generated_Code/UTIL1.c ****   if (c == '-') {                      /* negative? */
1268:../Generated_Code/UTIL1.c ****     s = 1;
1269:../Generated_Code/UTIL1.c ****     c = *(++(*str));
1270:../Generated_Code/UTIL1.c ****   }
1271:../Generated_Code/UTIL1.c ****   if (c == '0') {
1272:../Generated_Code/UTIL1.c ****     c = *(++(*str));
1273:../Generated_Code/UTIL1.c ****     switch (c) {
1274:../Generated_Code/UTIL1.c ****       case 'x':                        /* hexadecimal */
1275:../Generated_Code/UTIL1.c ****         r = 16; c = *(++(*str));
1276:../Generated_Code/UTIL1.c ****         break;
1277:../Generated_Code/UTIL1.c ****       case 'b':                        /* binary */
1278:../Generated_Code/UTIL1.c ****         r = 2; c = *(++(*str));
1279:../Generated_Code/UTIL1.c ****         break;
1280:../Generated_Code/UTIL1.c ****       default:
1281:../Generated_Code/UTIL1.c ****         if (c <= ' ' || c == '.') {
1282:../Generated_Code/UTIL1.c ****           return ERR_OK;               /* single zero */
1283:../Generated_Code/UTIL1.c ****         }
1284:../Generated_Code/UTIL1.c ****         if (c < '0' || c > '9') {
1285:../Generated_Code/UTIL1.c ****           return ERR_FAILED;           /* invalid char */
1286:../Generated_Code/UTIL1.c ****         }
1287:../Generated_Code/UTIL1.c ****         r = 8;                         /* octal */
1288:../Generated_Code/UTIL1.c ****         break;
1289:../Generated_Code/UTIL1.c ****     } /* switch */
1290:../Generated_Code/UTIL1.c ****   } else {
1291:../Generated_Code/UTIL1.c ****     if (c < '0' || c > '9') {
1292:../Generated_Code/UTIL1.c ****       return ERR_FAILED;               /* EOL or invalid char */
1293:../Generated_Code/UTIL1.c ****     }
1294:../Generated_Code/UTIL1.c ****     r = 10;                            /* decimal */
1295:../Generated_Code/UTIL1.c ****   }
1296:../Generated_Code/UTIL1.c ****   val = 0;
1297:../Generated_Code/UTIL1.c ****   while (c > ' ' && c != '.') {
1298:../Generated_Code/UTIL1.c ****     if (c >= 'a') c -= 0x20;
1299:../Generated_Code/UTIL1.c ****     c -= '0';
1300:../Generated_Code/UTIL1.c ****     if (c >= 17) {
1301:../Generated_Code/UTIL1.c ****       c -= 7;
1302:../Generated_Code/UTIL1.c ****       if (c <= 9) return ERR_FAILED;   /* invalid char */
1303:../Generated_Code/UTIL1.c ****     }
1304:../Generated_Code/UTIL1.c ****     if (c >= r) return ERR_FAILED;     /* invalid char for current radix */
1305:../Generated_Code/UTIL1.c ****     val = val * r + c;
1306:../Generated_Code/UTIL1.c ****     c = *(++(*str));
1307:../Generated_Code/UTIL1.c ****   } /* while */
1308:../Generated_Code/UTIL1.c ****   if (s) val = 0 - val;                /* apply sign if needed */
1309:../Generated_Code/UTIL1.c ****   *res = (long)val;
1310:../Generated_Code/UTIL1.c ****   return ERR_OK;
1311:../Generated_Code/UTIL1.c **** }
1312:../Generated_Code/UTIL1.c **** #ifdef __HC12__
1313:../Generated_Code/UTIL1.c ****   #pragma MESSAGE DEFAULT C12056  /* message about SP debug info */
1314:../Generated_Code/UTIL1.c **** #endif
1315:../Generated_Code/UTIL1.c **** 
1316:../Generated_Code/UTIL1.c **** /*
1317:../Generated_Code/UTIL1.c **** ** ===================================================================
1318:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanDate (component Utility)
1319:../Generated_Code/UTIL1.c **** **     Description :
1320:../Generated_Code/UTIL1.c **** **         Scans a date in the format "dd.mm.yyyy" or "dd-mm-yyyy". For
1321:../Generated_Code/UTIL1.c **** **         yy it will expand it to 20yy.
1322:../Generated_Code/UTIL1.c **** **     Parameters  :
1323:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1324:../Generated_Code/UTIL1.c **** **       * str             - Pointer to the string to be scanned. The
1325:../Generated_Code/UTIL1.c **** **                           function advances the pointer.
1326:../Generated_Code/UTIL1.c **** **       * day             - Pointer to where to store the day value
1327:../Generated_Code/UTIL1.c **** **       * month           - Pointer to where to store the month
1328:../Generated_Code/UTIL1.c **** **                           value
1329:../Generated_Code/UTIL1.c **** **       * year            - Pointer to where to store the year value
1330:../Generated_Code/UTIL1.c **** **     Returns     :
1331:../Generated_Code/UTIL1.c **** **         ---             - Error code
1332:../Generated_Code/UTIL1.c **** ** ===================================================================
1333:../Generated_Code/UTIL1.c **** */
1334:../Generated_Code/UTIL1.c **** byte UTIL1_ScanDate(const unsigned char **str, byte *day, byte *month, word *year)
1335:../Generated_Code/UTIL1.c **** {
1336:../Generated_Code/UTIL1.c ****   /* precondition: string points to starting of date, e.g. "01.01.10" or "12.5.2010", and date is i
1337:../Generated_Code/UTIL1.c ****   const unsigned char *p;
1338:../Generated_Code/UTIL1.c **** 
1339:../Generated_Code/UTIL1.c ****   p = *str;
1340:../Generated_Code/UTIL1.c ****   while(*p==' ') {
1341:../Generated_Code/UTIL1.c ****     p++; /* skip leading spaces */
1342:../Generated_Code/UTIL1.c ****   }
1343:../Generated_Code/UTIL1.c ****   if (   UTIL1_ScanDecimal8uNumber(&p, day)==ERR_OK
1344:../Generated_Code/UTIL1.c ****       && *day > 0 && *day <= 31
1345:../Generated_Code/UTIL1.c ****       && (*p=='.' || *p=='-')
1346:../Generated_Code/UTIL1.c ****      )
1347:../Generated_Code/UTIL1.c ****   {
1348:../Generated_Code/UTIL1.c ****     p++;
1349:../Generated_Code/UTIL1.c ****     if (   UTIL1_ScanDecimal8uNumber(&p, month)==ERR_OK
1350:../Generated_Code/UTIL1.c ****         && *month > 0 && *month <= 12
1351:../Generated_Code/UTIL1.c ****         && (*p=='.' || *p=='-')
1352:../Generated_Code/UTIL1.c ****        )
1353:../Generated_Code/UTIL1.c ****     {
1354:../Generated_Code/UTIL1.c ****       p++;
1355:../Generated_Code/UTIL1.c ****       if (   UTIL1_ScanDecimal16uNumber(&p, year)==ERR_OK
1356:../Generated_Code/UTIL1.c ****           && *year > 0 && *year <= 3000 /* hopefully this is enough :-) */
1357:../Generated_Code/UTIL1.c ****          )
1358:../Generated_Code/UTIL1.c ****       {
1359:../Generated_Code/UTIL1.c ****         if (*year < 100) {
1360:../Generated_Code/UTIL1.c ****           *year += 2000; /* transform '10' into '2010' */
1361:../Generated_Code/UTIL1.c ****         }
1362:../Generated_Code/UTIL1.c ****         *str = p; /* advance pointer for caller */
1363:../Generated_Code/UTIL1.c ****         return ERR_OK;
1364:../Generated_Code/UTIL1.c ****       }
1365:../Generated_Code/UTIL1.c ****     }
1366:../Generated_Code/UTIL1.c ****   }
1367:../Generated_Code/UTIL1.c ****   *day = 0;
1368:../Generated_Code/UTIL1.c ****   *month = 0;
1369:../Generated_Code/UTIL1.c ****   *year = 0;
1370:../Generated_Code/UTIL1.c ****   return ERR_FAILED; /* wrong format */
1371:../Generated_Code/UTIL1.c **** }
1372:../Generated_Code/UTIL1.c **** 
1373:../Generated_Code/UTIL1.c **** /*
1374:../Generated_Code/UTIL1.c **** ** ===================================================================
1375:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanTime (component Utility)
1376:../Generated_Code/UTIL1.c **** **     Description :
1377:../Generated_Code/UTIL1.c **** **         Scans a time string in the format "hh:mm:ss,hh" with the
1378:../Generated_Code/UTIL1.c **** **         part for the ",hh" is optional.
1379:../Generated_Code/UTIL1.c **** **     Parameters  :
1380:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1381:../Generated_Code/UTIL1.c **** **         str             - Pointer to the string to be scanned. The
1382:../Generated_Code/UTIL1.c **** **                           function advances the pointer.
1383:../Generated_Code/UTIL1.c **** **       * hour            - Pointer to where to store the hour value
1384:../Generated_Code/UTIL1.c **** **       * minute          - Pointer to where to store the minute
1385:../Generated_Code/UTIL1.c **** **                           value
1386:../Generated_Code/UTIL1.c **** **       * second          - Pointer to where to store the second
1387:../Generated_Code/UTIL1.c **** **                           value
1388:../Generated_Code/UTIL1.c **** **       * hSecond         - Pointer to scans the hundreds of
1389:../Generated_Code/UTIL1.c **** **                           second part. If not present in string, zero
1390:../Generated_Code/UTIL1.c **** **                           is stored
1391:../Generated_Code/UTIL1.c **** **     Returns     :
1392:../Generated_Code/UTIL1.c **** **         ---             - Error code
1393:../Generated_Code/UTIL1.c **** ** ===================================================================
1394:../Generated_Code/UTIL1.c **** */
1395:../Generated_Code/UTIL1.c **** byte UTIL1_ScanTime(const unsigned char **str, byte *hour, byte *minute, byte *second, byte *hSecon
1396:../Generated_Code/UTIL1.c **** {
1397:../Generated_Code/UTIL1.c ****   /* precondition: string points to starting of time string, e.g. "03:15:05" or "03:15:05,3" or "03
1398:../Generated_Code/UTIL1.c ****   const unsigned char *p;
1399:../Generated_Code/UTIL1.c ****   #define SCAN_IS_DIGIT(ch) ((ch)>='0'&&(ch)<='9')
1400:../Generated_Code/UTIL1.c **** 
1401:../Generated_Code/UTIL1.c ****   *hour = 0;
1402:../Generated_Code/UTIL1.c ****   *minute = 0;
1403:../Generated_Code/UTIL1.c ****   *second = 0;
1404:../Generated_Code/UTIL1.c ****   *hSecond = 0;
1405:../Generated_Code/UTIL1.c ****   p = *str;
1406:../Generated_Code/UTIL1.c ****   while(*p==' ') {
1407:../Generated_Code/UTIL1.c ****     p++; /* skip leading spaces */
1408:../Generated_Code/UTIL1.c ****   }
1409:../Generated_Code/UTIL1.c ****   if (   UTIL1_ScanDecimal8uNumber(&p, hour)==ERR_OK
1410:../Generated_Code/UTIL1.c ****       && *hour <= 24
1411:../Generated_Code/UTIL1.c ****       && *p==':'
1412:../Generated_Code/UTIL1.c ****      )
1413:../Generated_Code/UTIL1.c ****   {
1414:../Generated_Code/UTIL1.c ****     p++; /* skip ':' */
1415:../Generated_Code/UTIL1.c ****     if (   UTIL1_ScanDecimal8uNumber(&p, minute)==ERR_OK
1416:../Generated_Code/UTIL1.c ****         && *minute <= 60
1417:../Generated_Code/UTIL1.c ****         && *p==':'
1418:../Generated_Code/UTIL1.c ****        )
1419:../Generated_Code/UTIL1.c ****     {
1420:../Generated_Code/UTIL1.c ****       p++; /* skip ':' */
1421:../Generated_Code/UTIL1.c ****       if (   UTIL1_ScanDecimal8uNumber(&p, second)==ERR_OK
1422:../Generated_Code/UTIL1.c ****           && *second <= 60
1423:../Generated_Code/UTIL1.c ****          )
1424:../Generated_Code/UTIL1.c ****       {
1425:../Generated_Code/UTIL1.c ****         if (*p==',') { /* we do have either ",z" or ",hh" */
1426:../Generated_Code/UTIL1.c ****           p++; /* skip ',' */
1427:../Generated_Code/UTIL1.c ****           if (SCAN_IS_DIGIT(*p)) {
1428:../Generated_Code/UTIL1.c ****             if (SCAN_IS_DIGIT(*(p+1))) { /* ,hh format */
1429:../Generated_Code/UTIL1.c ****               *hSecond = (uint8_t)((*p-'0')*10 + *(p+1)-'0');
1430:../Generated_Code/UTIL1.c ****               p++; p++;
1431:../Generated_Code/UTIL1.c ****               return ERR_OK;
1432:../Generated_Code/UTIL1.c ****             } else { /* ,z format */
1433:../Generated_Code/UTIL1.c ****               *hSecond = (uint8_t)((*p-'0')*10);
1434:../Generated_Code/UTIL1.c ****               p++;
1435:../Generated_Code/UTIL1.c ****               *str = p; /* advance pointer for caller */
1436:../Generated_Code/UTIL1.c ****               return ERR_OK;
1437:../Generated_Code/UTIL1.c ****             }
1438:../Generated_Code/UTIL1.c ****           } else {
1439:../Generated_Code/UTIL1.c ****             return ERR_FAILED; /* illegal format, not a number, e.g. ",x" */
1440:../Generated_Code/UTIL1.c ****           }
1441:../Generated_Code/UTIL1.c ****         }
1442:../Generated_Code/UTIL1.c ****         return ERR_OK;
1443:../Generated_Code/UTIL1.c ****       }
1444:../Generated_Code/UTIL1.c ****     }
1445:../Generated_Code/UTIL1.c ****   }
1446:../Generated_Code/UTIL1.c ****   return ERR_FAILED; /* wrong format */
1447:../Generated_Code/UTIL1.c **** }
1448:../Generated_Code/UTIL1.c **** 
1449:../Generated_Code/UTIL1.c **** /*
1450:../Generated_Code/UTIL1.c **** ** ===================================================================
1451:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanDecimal16uNumber (component Utility)
1452:../Generated_Code/UTIL1.c **** **     Description :
1453:../Generated_Code/UTIL1.c **** **         Scans a decimal 16bit unsigned number
1454:../Generated_Code/UTIL1.c **** **     Parameters  :
1455:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1456:../Generated_Code/UTIL1.c **** **         str             - String to scan, starting with 0x. It
1457:../Generated_Code/UTIL1.c **** **                           returns as well until where it has scanned
1458:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1459:../Generated_Code/UTIL1.c **** **     Returns     :
1460:../Generated_Code/UTIL1.c **** **         ---             - Error code
1461:../Generated_Code/UTIL1.c **** ** ===================================================================
1462:../Generated_Code/UTIL1.c **** */
1463:../Generated_Code/UTIL1.c **** byte UTIL1_ScanDecimal16uNumber(const unsigned char **str, word *val)
1464:../Generated_Code/UTIL1.c **** {
1465:../Generated_Code/UTIL1.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1466:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = 5+1; /* maximum number of digits to avoid overflow */
1467:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
1468:../Generated_Code/UTIL1.c **** 
1469:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
1470:../Generated_Code/UTIL1.c ****     p++;
1471:../Generated_Code/UTIL1.c ****   }
1472:../Generated_Code/UTIL1.c ****   *val = 0;
1473:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
1474:../Generated_Code/UTIL1.c ****     *val = (uint16_t)((*val)*10 + *p-'0');
1475:../Generated_Code/UTIL1.c ****     nofDigits--;
1476:../Generated_Code/UTIL1.c ****     p++;
1477:../Generated_Code/UTIL1.c ****   } /* while */
1478:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
1479:../Generated_Code/UTIL1.c ****     return ERR_OVERFLOW;
1480:../Generated_Code/UTIL1.c ****   }
1481:../Generated_Code/UTIL1.c ****   *str = p;
1482:../Generated_Code/UTIL1.c ****   return ERR_OK;
1483:../Generated_Code/UTIL1.c **** }
1484:../Generated_Code/UTIL1.c **** 
1485:../Generated_Code/UTIL1.c **** /*
1486:../Generated_Code/UTIL1.c **** ** ===================================================================
1487:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanDecimal8uNumber (component Utility)
1488:../Generated_Code/UTIL1.c **** **     Description :
1489:../Generated_Code/UTIL1.c **** **         Scans a decimal 16bit unsigned number
1490:../Generated_Code/UTIL1.c **** **     Parameters  :
1491:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1492:../Generated_Code/UTIL1.c **** **         str             - String to scan, starting with 0x. It
1493:../Generated_Code/UTIL1.c **** **                           returns as well until where it has scanned
1494:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1495:../Generated_Code/UTIL1.c **** **     Returns     :
1496:../Generated_Code/UTIL1.c **** **         ---             - Error code
1497:../Generated_Code/UTIL1.c **** ** ===================================================================
1498:../Generated_Code/UTIL1.c **** */
1499:../Generated_Code/UTIL1.c **** byte UTIL1_ScanDecimal8uNumber(const unsigned char **str, byte *val)
1500:../Generated_Code/UTIL1.c **** {
1501:../Generated_Code/UTIL1.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1502:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = 3+1; /* maximum number of digits to avoid overflow */
1503:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
1504:../Generated_Code/UTIL1.c **** 
1505:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
1506:../Generated_Code/UTIL1.c ****     p++;
1507:../Generated_Code/UTIL1.c ****   }
1508:../Generated_Code/UTIL1.c ****   *val = 0;
1509:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
1510:../Generated_Code/UTIL1.c ****     *val = (uint8_t)((*val)*10 + *p-'0');
1511:../Generated_Code/UTIL1.c ****     nofDigits--;
1512:../Generated_Code/UTIL1.c ****     p++;
1513:../Generated_Code/UTIL1.c ****   } /* while */
1514:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
1515:../Generated_Code/UTIL1.c ****     return ERR_OVERFLOW;
1516:../Generated_Code/UTIL1.c ****   }
1517:../Generated_Code/UTIL1.c ****   *str = p;
1518:../Generated_Code/UTIL1.c ****   return ERR_OK;
1519:../Generated_Code/UTIL1.c **** }
1520:../Generated_Code/UTIL1.c **** 
1521:../Generated_Code/UTIL1.c **** /*
1522:../Generated_Code/UTIL1.c **** ** ===================================================================
1523:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanDecimal32uNumber (component Utility)
1524:../Generated_Code/UTIL1.c **** **     Description :
1525:../Generated_Code/UTIL1.c **** **         Scans a decimal 32bit unsigned number
1526:../Generated_Code/UTIL1.c **** **     Parameters  :
1527:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1528:../Generated_Code/UTIL1.c **** **         str             - string to scan. It returns as well until
1529:../Generated_Code/UTIL1.c **** **                           where it has scanned
1530:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1531:../Generated_Code/UTIL1.c **** **     Returns     :
1532:../Generated_Code/UTIL1.c **** **         ---             - Error code
1533:../Generated_Code/UTIL1.c **** ** ===================================================================
1534:../Generated_Code/UTIL1.c **** */
1535:../Generated_Code/UTIL1.c **** byte UTIL1_ScanDecimal32uNumber(const unsigned char **str, dword *val)
1536:../Generated_Code/UTIL1.c **** {
1537:../Generated_Code/UTIL1.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1538:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = 10+1; /* maximum number of digits to avoid overflow */
1539:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
1540:../Generated_Code/UTIL1.c **** 
1541:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
1542:../Generated_Code/UTIL1.c ****     p++;
1543:../Generated_Code/UTIL1.c ****   }
1544:../Generated_Code/UTIL1.c ****   *val = 0;
1545:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
1546:../Generated_Code/UTIL1.c ****     *val = (uint32_t)((*val)*10 + *p-'0');
1547:../Generated_Code/UTIL1.c ****     nofDigits--;
1548:../Generated_Code/UTIL1.c ****     p++;
1549:../Generated_Code/UTIL1.c ****   } /* while */
1550:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
1551:../Generated_Code/UTIL1.c ****     return ERR_OVERFLOW;
1552:../Generated_Code/UTIL1.c ****   }
1553:../Generated_Code/UTIL1.c ****   *str = p;
1554:../Generated_Code/UTIL1.c ****   return ERR_OK;
1555:../Generated_Code/UTIL1.c **** }
1556:../Generated_Code/UTIL1.c **** 
1557:../Generated_Code/UTIL1.c **** /*
1558:../Generated_Code/UTIL1.c **** ** ===================================================================
1559:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strcmp (component Utility)
1560:../Generated_Code/UTIL1.c **** **     Description :
1561:../Generated_Code/UTIL1.c **** **         Wrapper to the standard strcmp() routine
1562:../Generated_Code/UTIL1.c **** **     Parameters  :
1563:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1564:../Generated_Code/UTIL1.c **** **       * str1            - Pointer to string
1565:../Generated_Code/UTIL1.c **** **       * str2            - Pointer to string
1566:../Generated_Code/UTIL1.c **** **     Returns     :
1567:../Generated_Code/UTIL1.c **** **         ---             - Returns zero if the two strings are the
1568:../Generated_Code/UTIL1.c **** **                           same
1569:../Generated_Code/UTIL1.c **** ** ===================================================================
1570:../Generated_Code/UTIL1.c **** */
1571:../Generated_Code/UTIL1.c **** /***
1572:../Generated_Code/UTIL1.c **** int16_t UTIL1_strcmp(const char *, const char *)
1573:../Generated_Code/UTIL1.c **** {
1574:../Generated_Code/UTIL1.c ****   Method is implemented as macro in the header file as wrapper to the standard strcmp() function
1575:../Generated_Code/UTIL1.c **** }
1576:../Generated_Code/UTIL1.c **** */
1577:../Generated_Code/UTIL1.c **** 
1578:../Generated_Code/UTIL1.c **** /*
1579:../Generated_Code/UTIL1.c **** ** ===================================================================
1580:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strncmp (component Utility)
1581:../Generated_Code/UTIL1.c **** **     Description :
1582:../Generated_Code/UTIL1.c **** **         Wrapper to the standard strncmp() routine
1583:../Generated_Code/UTIL1.c **** **     Parameters  :
1584:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1585:../Generated_Code/UTIL1.c **** **       * str1            - Pointer to string
1586:../Generated_Code/UTIL1.c **** **       * str2            - Pointer to string
1587:../Generated_Code/UTIL1.c **** **         size            - 
1588:../Generated_Code/UTIL1.c **** **     Returns     :
1589:../Generated_Code/UTIL1.c **** **         ---             - Returns zero if the two strings are the
1590:../Generated_Code/UTIL1.c **** **                           same
1591:../Generated_Code/UTIL1.c **** ** ===================================================================
1592:../Generated_Code/UTIL1.c **** */
1593:../Generated_Code/UTIL1.c **** /***
1594:../Generated_Code/UTIL1.c **** int16_t UTIL1_strncmp(const char *, const char *, size_t size)
1595:../Generated_Code/UTIL1.c **** {
1596:../Generated_Code/UTIL1.c ****   /Method is implemented as macro in the header file as wrapper to the standard strncmp() function
1597:../Generated_Code/UTIL1.c **** }
1598:../Generated_Code/UTIL1.c **** */
1599:../Generated_Code/UTIL1.c **** 
1600:../Generated_Code/UTIL1.c **** /*
1601:../Generated_Code/UTIL1.c **** ** ===================================================================
1602:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strlen (component Utility)
1603:../Generated_Code/UTIL1.c **** **     Description :
1604:../Generated_Code/UTIL1.c **** **         Wrapper to the standard strlen() function.
1605:../Generated_Code/UTIL1.c **** **     Parameters  :
1606:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1607:../Generated_Code/UTIL1.c **** **         str             - 
1608:../Generated_Code/UTIL1.c **** **     Returns     :
1609:../Generated_Code/UTIL1.c **** **         ---             - size of strinig
1610:../Generated_Code/UTIL1.c **** ** ===================================================================
1611:../Generated_Code/UTIL1.c **** */
1612:../Generated_Code/UTIL1.c **** /***
1613:../Generated_Code/UTIL1.c **** word UTIL1_strlen(const char *)
1614:../Generated_Code/UTIL1.c **** {
1615:../Generated_Code/UTIL1.c ****   Method is implemented as macro in the header file as wrapper to the standard strlen() function
1616:../Generated_Code/UTIL1.c **** }
1617:../Generated_Code/UTIL1.c **** */
1618:../Generated_Code/UTIL1.c **** 
1619:../Generated_Code/UTIL1.c **** static byte PreScanHexNumber(const unsigned char **str)
1620:../Generated_Code/UTIL1.c **** {
 126              		.loc 1 1620 0
 127              		.cfi_startproc
 128              	.LVL5:
 129 0000 00B5     		push	{lr}
 130              	.LCFI1:
 131              		.cfi_def_cfa_offset 4
 132              		.cfi_offset 14, -4
1621:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 133              		.loc 1 1621 0
 134 0002 0368     		ldr	r3, [r0]
 135              	.LVL6:
 136              	.L13:
1622:../Generated_Code/UTIL1.c **** 
1623:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 137              		.loc 1 1623 0
 138 0004 1978     		ldrb	r1, [r3]
 139 0006 2029     		cmp	r1, #32
 140 0008 01D1     		bne	.L18
 141              	.L14:
1624:../Generated_Code/UTIL1.c ****     p++; /* skip space */
 142              		.loc 1 1624 0
 143 000a 0133     		add	r3, r3, #1
 144              	.LVL7:
 145 000c FAE7     		b	.L13
 146              	.L18:
1625:../Generated_Code/UTIL1.c ****   }
1626:../Generated_Code/UTIL1.c ****   if (*p!='0') { /* must start with 0x */
1627:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 147              		.loc 1 1627 0
 148 000e 1B22     		mov	r2, #27
1626:../Generated_Code/UTIL1.c ****   if (*p!='0') { /* must start with 0x */
 149              		.loc 1 1626 0
 150 0010 3029     		cmp	r1, #48
 151 0012 05D1     		bne	.L15
 152              	.LVL8:
1628:../Generated_Code/UTIL1.c ****   }
1629:../Generated_Code/UTIL1.c ****   p++; /* skip '0' */
1630:../Generated_Code/UTIL1.c ****   if (*p!='x') { /* must start with 0x */
 153              		.loc 1 1630 0
 154 0014 5978     		ldrb	r1, [r3, #1]
 155 0016 7829     		cmp	r1, #120
 156 0018 02D1     		bne	.L15
 157              	.LVL9:
1631:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
1632:../Generated_Code/UTIL1.c ****   }
1633:../Generated_Code/UTIL1.c ****   p++; /* skip 'x' */
 158              		.loc 1 1633 0
 159 001a 0233     		add	r3, r3, #2
 160              	.LVL10:
1634:../Generated_Code/UTIL1.c ****   *str = p;
 161              		.loc 1 1634 0
 162 001c 0360     		str	r3, [r0]
1635:../Generated_Code/UTIL1.c ****   return ERR_OK;
 163              		.loc 1 1635 0
 164 001e 0022     		mov	r2, #0
 165              	.LVL11:
 166              	.L15:
1636:../Generated_Code/UTIL1.c **** }
 167              		.loc 1 1636 0
 168 0020 101C     		mov	r0, r2
 169              	.LVL12:
 170              		@ sp needed for prologue
 171 0022 00BD     		pop	{pc}
 172              		.cfi_endproc
 173              	.LFE37:
 175              		.section	.text.HexToDec,"ax",%progbits
 176              		.align	1
 177              		.code	16
 178              		.thumb_func
 180              	HexToDec:
 181              	.LFB38:
1637:../Generated_Code/UTIL1.c **** 
1638:../Generated_Code/UTIL1.c **** static byte HexToDec(const unsigned char **p, unsigned char *val) {
 182              		.loc 1 1638 0
 183              		.cfi_startproc
 184              	.LVL13:
 185 0000 10B5     		push	{r4, lr}
 186              	.LCFI2:
 187              		.cfi_def_cfa_offset 8
 188              		.cfi_offset 4, -8
 189              		.cfi_offset 14, -4
 190              		.loc 1 1638 0
 191 0002 031C     		mov	r3, r0
1639:../Generated_Code/UTIL1.c ****   /* convert a hexadecimal character into a decimal value */
1640:../Generated_Code/UTIL1.c ****   unsigned char ch = **p;
 192              		.loc 1 1640 0
 193 0004 0068     		ldr	r0, [r0]
 194              	.LVL14:
 195 0006 0278     		ldrb	r2, [r0]
 196              	.LVL15:
1641:../Generated_Code/UTIL1.c **** 
1642:../Generated_Code/UTIL1.c ****   if (ch>='0' && ch<='9') {
 197              		.loc 1 1642 0
 198 0008 141C     		mov	r4, r2
 199 000a 303C     		sub	r4, r4, #48
 200 000c E0B2     		uxtb	r0, r4
 201              	.LVL16:
 202 000e 0928     		cmp	r0, #9
 203 0010 01D8     		bhi	.L20
1643:../Generated_Code/UTIL1.c ****     *val = (unsigned char)(ch-'0');
 204              		.loc 1 1643 0
 205 0012 0870     		strb	r0, [r1]
 206 0014 0CE0     		b	.L24
 207              	.L20:
1644:../Generated_Code/UTIL1.c ****     (*p)++;
1645:../Generated_Code/UTIL1.c ****     return ERR_OK;
1646:../Generated_Code/UTIL1.c ****   } else if (ch>='a' && ch<='f') {
 208              		.loc 1 1646 0
 209 0016 141C     		mov	r4, r2
 210 0018 613C     		sub	r4, r4, #97
 211 001a 052C     		cmp	r4, #5
 212 001c 01D8     		bhi	.L22
1647:../Generated_Code/UTIL1.c ****     *val = (unsigned char)(ch-'a'+10);
 213              		.loc 1 1647 0
 214 001e 573A     		sub	r2, r2, #87
 215 0020 05E0     		b	.L25
 216              	.L22:
1648:../Generated_Code/UTIL1.c ****     (*p)++;
1649:../Generated_Code/UTIL1.c ****     return ERR_OK;
1650:../Generated_Code/UTIL1.c ****   } else if (ch>='A' && ch<='F') {
 217              		.loc 1 1650 0
 218 0022 141C     		mov	r4, r2
 219 0024 413C     		sub	r4, r4, #65
1651:../Generated_Code/UTIL1.c ****     *val = (unsigned char)(ch-'A'+10);
1652:../Generated_Code/UTIL1.c ****     (*p)++;
1653:../Generated_Code/UTIL1.c ****     return ERR_OK;
1654:../Generated_Code/UTIL1.c ****   }
1655:../Generated_Code/UTIL1.c ****   return ERR_FAILED;
 220              		.loc 1 1655 0
 221 0026 1B20     		mov	r0, #27
1650:../Generated_Code/UTIL1.c ****   } else if (ch>='A' && ch<='F') {
 222              		.loc 1 1650 0
 223 0028 052C     		cmp	r4, #5
 224 002a 05D8     		bhi	.L21
1651:../Generated_Code/UTIL1.c ****     *val = (unsigned char)(ch-'A'+10);
 225              		.loc 1 1651 0
 226 002c 373A     		sub	r2, r2, #55
 227              	.L25:
 228 002e 0A70     		strb	r2, [r1]
 229              	.L24:
1652:../Generated_Code/UTIL1.c ****     (*p)++;
 230              		.loc 1 1652 0
 231 0030 1968     		ldr	r1, [r3]
 232              	.LVL17:
1653:../Generated_Code/UTIL1.c ****     return ERR_OK;
 233              		.loc 1 1653 0
 234 0032 0020     		mov	r0, #0
1652:../Generated_Code/UTIL1.c ****     (*p)++;
 235              		.loc 1 1652 0
 236 0034 0131     		add	r1, r1, #1
 237 0036 1960     		str	r1, [r3]
 238              	.L21:
1656:../Generated_Code/UTIL1.c **** }
 239              		.loc 1 1656 0
 240              		@ sp needed for prologue
 241 0038 10BD     		pop	{r4, pc}
 242              		.cfi_endproc
 243              	.LFE38:
 245              		.section	.text.UTIL1_strcpy,"ax",%progbits
 246              		.align	1
 247              		.global	UTIL1_strcpy
 248              		.code	16
 249              		.thumb_func
 251              	UTIL1_strcpy:
 252              	.LFB0:
 114:../Generated_Code/UTIL1.c **** {
 253              		.loc 1 114 0
 254              		.cfi_startproc
 255              	.LVL18:
 256 0000 00B5     		push	{lr}
 257              	.LCFI3:
 258              		.cfi_def_cfa_offset 4
 259              		.cfi_offset 14, -4
 260              	.LVL19:
 261              	.L32:
 118:../Generated_Code/UTIL1.c ****     dstSize--;
 262              		.loc 1 118 0
 263 0002 0139     		sub	r1, r1, #1
 264              	.LVL20:
 116:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *src != '\0') {
 265              		.loc 1 116 0
 266 0004 0029     		cmp	r1, #0
 267 0006 02D1     		bne	.L28
 268              	.L30:
 120:../Generated_Code/UTIL1.c ****   *dst = '\0';
 269              		.loc 1 120 0
 270 0008 0021     		mov	r1, #0
 271              	.LVL21:
 272 000a 0170     		strb	r1, [r0]
 121:../Generated_Code/UTIL1.c **** }
 273              		.loc 1 121 0
 274              		@ sp needed for prologue
 275 000c 00BD     		pop	{pc}
 276              	.LVL22:
 277              	.L28:
 116:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *src != '\0') {
 278              		.loc 1 116 0
 279 000e 1378     		ldrb	r3, [r2]
 280 0010 002B     		cmp	r3, #0
 281 0012 F9D0     		beq	.L30
 282              	.L29:
 117:../Generated_Code/UTIL1.c ****     *dst++ = *src++;
 283              		.loc 1 117 0
 284 0014 0370     		strb	r3, [r0]
 285 0016 0132     		add	r2, r2, #1
 286              	.LVL23:
 287 0018 0130     		add	r0, r0, #1
 288              	.LVL24:
 289 001a F2E7     		b	.L32
 290              		.cfi_endproc
 291              	.LFE0:
 293              		.section	.text.UTIL1_strcat,"ax",%progbits
 294              		.align	1
 295              		.global	UTIL1_strcat
 296              		.code	16
 297              		.thumb_func
 299              	UTIL1_strcat:
 300              	.LFB1:
 147:../Generated_Code/UTIL1.c **** {
 301              		.loc 1 147 0
 302              		.cfi_startproc
 303              	.LVL25:
 304 0000 00B5     		push	{lr}
 305              	.LCFI4:
 306              		.cfi_def_cfa_offset 4
 307              		.cfi_offset 14, -4
 308              	.LVL26:
 309              	.L43:
 152:../Generated_Code/UTIL1.c ****     dstSize--;
 310              		.loc 1 152 0
 311 0002 0139     		sub	r1, r1, #1
 312              	.LVL27:
 150:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *dst != '\0') {
 313              		.loc 1 150 0
 314 0004 0029     		cmp	r1, #0
 315 0006 01D1     		bne	.L35
 316              	.L38:
 146:../Generated_Code/UTIL1.c **** void UTIL1_strcat(byte *dst, size_t dstSize, const unsigned char *src)
 317              		.loc 1 146 0
 318 0008 4118     		add	r1, r0, r1
 319              	.LVL28:
 320 000a 0AE0     		b	.L36
 321              	.LVL29:
 322              	.L35:
 150:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *dst != '\0') {
 323              		.loc 1 150 0
 324 000c 0378     		ldrb	r3, [r0]
 325 000e 002B     		cmp	r3, #0
 326 0010 FAD0     		beq	.L38
 327              	.L37:
 151:../Generated_Code/UTIL1.c ****     dst++;
 328              		.loc 1 151 0
 329 0012 0130     		add	r0, r0, #1
 330              	.LVL30:
 331 0014 F5E7     		b	.L43
 332              	.LVL31:
 333              	.L39:
 155:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *src != '\0') {
 334              		.loc 1 155 0
 335 0016 1378     		ldrb	r3, [r2]
 336 0018 002B     		cmp	r3, #0
 337 001a 04D0     		beq	.L41
 338              	.L40:
 156:../Generated_Code/UTIL1.c ****     *dst++ = *src++;
 339              		.loc 1 156 0
 340 001c 0370     		strb	r3, [r0]
 341 001e 0132     		add	r2, r2, #1
 342              	.LVL32:
 343 0020 0130     		add	r0, r0, #1
 344              	.LVL33:
 345              	.L36:
 155:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *src != '\0') {
 346              		.loc 1 155 0
 347 0022 8842     		cmp	r0, r1
 348 0024 F7D1     		bne	.L39
 349              	.L41:
 160:../Generated_Code/UTIL1.c ****   *dst = '\0';
 350              		.loc 1 160 0
 351 0026 0021     		mov	r1, #0
 352 0028 0170     		strb	r1, [r0]
 161:../Generated_Code/UTIL1.c **** }
 353              		.loc 1 161 0
 354              		@ sp needed for prologue
 355 002a 00BD     		pop	{pc}
 356              		.cfi_endproc
 357              	.LFE1:
 359              		.section	.text.UTIL1_chcat,"ax",%progbits
 360              		.align	1
 361              		.global	UTIL1_chcat
 362              		.code	16
 363              		.thumb_func
 365              	UTIL1_chcat:
 366              	.LFB2:
 179:../Generated_Code/UTIL1.c **** {
 367              		.loc 1 179 0
 368              		.cfi_startproc
 369              	.LVL34:
 370 0000 10B5     		push	{r4, lr}
 371              	.LCFI5:
 372              		.cfi_def_cfa_offset 8
 373              		.cfi_offset 4, -8
 374              		.cfi_offset 14, -4
 375              	.LVL35:
 376              	.L54:
 184:../Generated_Code/UTIL1.c ****     dstSize--;
 377              		.loc 1 184 0
 378 0002 0139     		sub	r1, r1, #1
 379              	.LVL36:
 182:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *dst != '\0') {
 380              		.loc 1 182 0
 381 0004 0029     		cmp	r1, #0
 382 0006 07D0     		beq	.L46
 182:../Generated_Code/UTIL1.c ****   while (dstSize > 0 && *dst != '\0') {
 383              		.loc 1 182 0 is_stmt 0
 384 0008 0478     		ldrb	r4, [r0]
 385 000a 431C     		add	r3, r0, #1
 386 000c 002C     		cmp	r4, #0
 387 000e 01D0     		beq	.L55
 388              	.L47:
 183:../Generated_Code/UTIL1.c ****     dst++;
 389              		.loc 1 183 0 is_stmt 1
 390 0010 181C     		mov	r0, r3
 391              	.LVL37:
 392 0012 F6E7     		b	.L54
 393              	.LVL38:
 394              	.L55:
 188:../Generated_Code/UTIL1.c ****     *dst++ = ch;
 395              		.loc 1 188 0
 396 0014 0270     		strb	r2, [r0]
 397 0016 181C     		mov	r0, r3
 398              	.LVL39:
 399              	.L46:
 191:../Generated_Code/UTIL1.c ****   *dst = '\0';
 400              		.loc 1 191 0
 401 0018 0021     		mov	r1, #0
 402              	.LVL40:
 403 001a 0170     		strb	r1, [r0]
 192:../Generated_Code/UTIL1.c **** }
 404              		.loc 1 192 0
 405              		@ sp needed for prologue
 406 001c 10BD     		pop	{r4, pc}
 407              		.cfi_endproc
 408              	.LFE2:
 410              		.global	__aeabi_uidivmod
 411              		.global	__aeabi_uidiv
 412              		.section	.text.UTIL1_Num16uToStr,"ax",%progbits
 413              		.align	1
 414              		.global	UTIL1_Num16uToStr
 415              		.code	16
 416              		.thumb_func
 418              	UTIL1_Num16uToStr:
 419              	.LFB5:
 265:../Generated_Code/UTIL1.c **** {
 420              		.loc 1 265 0
 421              		.cfi_startproc
 422              	.LVL41:
 423 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 424              	.LCFI6:
 425              		.cfi_def_cfa_offset 32
 426              		.cfi_offset 0, -32
 427              		.cfi_offset 1, -28
 428              		.cfi_offset 2, -24
 429              		.cfi_offset 4, -20
 430              		.cfi_offset 5, -16
 431              		.cfi_offset 6, -12
 432              		.cfi_offset 7, -8
 433              		.cfi_offset 14, -4
 265:../Generated_Code/UTIL1.c **** {
 434              		.loc 1 265 0
 435 0002 151C     		mov	r5, r2
 267:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 436              		.loc 1 267 0
 437 0004 0022     		mov	r2, #0
 438              	.LVL42:
 265:../Generated_Code/UTIL1.c **** {
 439              		.loc 1 265 0
 440 0006 041C     		mov	r4, r0
 270:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 441              		.loc 1 270 0
 442 0008 4F1E     		sub	r7, r1, #1
 443              	.LVL43:
 267:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 444              		.loc 1 267 0
 445 000a 0192     		str	r2, [sp, #4]
 271:../Generated_Code/UTIL1.c ****   if (val == 0 && dstSize > 0){
 446              		.loc 1 271 0
 447 000c 9542     		cmp	r5, r2
 448 000e 07D1     		bne	.L57
 267:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 449              		.loc 1 267 0
 450 0010 0195     		str	r5, [sp, #4]
 271:../Generated_Code/UTIL1.c ****   if (val == 0 && dstSize > 0){
 451              		.loc 1 271 0
 452 0012 9742     		cmp	r7, r2
 453 0014 04D0     		beq	.L57
 272:../Generated_Code/UTIL1.c ****     ptr[i++] = '0';
 454              		.loc 1 272 0
 455 0016 3023     		mov	r3, #48
 456 0018 0370     		strb	r3, [r0]
 457              	.LVL44:
 458 001a 0120     		mov	r0, #1
 459              	.LVL45:
 273:../Generated_Code/UTIL1.c ****     dstSize--;
 460              		.loc 1 273 0
 461 001c 8F1E     		sub	r7, r1, #2
 462              	.LVL46:
 272:../Generated_Code/UTIL1.c ****     ptr[i++] = '0';
 463              		.loc 1 272 0
 464 001e 0190     		str	r0, [sp, #4]
 465              	.LVL47:
 466              	.L57:
 267:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 467              		.loc 1 267 0
 468 0020 3E1C     		mov	r6, r7
 469              	.LVL48:
 470              	.L58:
 264:../Generated_Code/UTIL1.c **** void UTIL1_Num16uToStr(byte *dst, size_t dstSize, word val)
 471              		.loc 1 264 0
 472 0022 0199     		ldr	r1, [sp, #4]
 473 0024 CA19     		add	r2, r1, r7
 474 0026 931B     		sub	r3, r2, r6
 475 0028 D8B2     		uxtb	r0, r3
 476 002a 0090     		str	r0, [sp]
 477              	.LVL49:
 275:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 478              		.loc 1 275 0
 479 002c 002D     		cmp	r5, #0
 480 002e 06D1     		bne	.L59
 481              	.L62:
 280:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 482              		.loc 1 280 0
 483 0030 009D     		ldr	r5, [sp]
 484              	.LVL50:
 264:../Generated_Code/UTIL1.c **** void UTIL1_Num16uToStr(byte *dst, size_t dstSize, word val)
 485              		.loc 1 264 0
 486 0032 231C     		mov	r3, r4
 487 0034 2E1C     		mov	r6, r5
 488              	.LVL51:
 489 0036 013E     		sub	r6, r6, #1
 280:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 490              		.loc 1 280 0
 491 0038 6908     		lsr	r1, r5, #1
 264:../Generated_Code/UTIL1.c **** void UTIL1_Num16uToStr(byte *dst, size_t dstSize, word val)
 492              		.loc 1 264 0
 493 003a A619     		add	r6, r4, r6
 494 003c 0FE0     		b	.L60
 495              	.LVL52:
 496              	.L59:
 275:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 497              		.loc 1 275 0
 498 003e 002E     		cmp	r6, #0
 499 0040 F6D0     		beq	.L62
 500              	.L61:
 276:../Generated_Code/UTIL1.c ****     ptr[i++] = (unsigned char)((val % 10) + '0');
 501              		.loc 1 276 0
 502 0042 281C     		mov	r0, r5
 503 0044 0A21     		mov	r1, #10
 504 0046 FFF7FEFF 		bl	__aeabi_uidivmod
 505              	.LVL53:
 506 004a 0098     		ldr	r0, [sp]
 507 004c 3031     		add	r1, r1, #48
 508 004e 2154     		strb	r1, [r4, r0]
 509              	.LVL54:
 278:../Generated_Code/UTIL1.c ****     val /= 10;
 510              		.loc 1 278 0
 511 0050 281C     		mov	r0, r5
 512              	.LVL55:
 513 0052 0A21     		mov	r1, #10
 514 0054 FFF7FEFF 		bl	__aeabi_uidiv
 515              	.LVL56:
 277:../Generated_Code/UTIL1.c ****     dstSize--;
 516              		.loc 1 277 0
 517 0058 013E     		sub	r6, r6, #1
 518              	.LVL57:
 278:../Generated_Code/UTIL1.c ****     val /= 10;
 519              		.loc 1 278 0
 520 005a 85B2     		uxth	r5, r0
 521              	.LVL58:
 522 005c E1E7     		b	.L58
 523              	.LVL59:
 524              	.L60:
 280:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 525              		.loc 1 280 0
 526 005e 1F1B     		sub	r7, r3, r4
 527 0060 F8B2     		uxtb	r0, r7
 528 0062 8842     		cmp	r0, r1
 529 0064 06D2     		bcs	.L67
 530              	.L63:
 281:../Generated_Code/UTIL1.c ****     tmp = ptr[j];
 531              		.loc 1 281 0
 532 0066 1F78     		ldrb	r7, [r3]
 533              	.LVL60:
 282:../Generated_Code/UTIL1.c ****     ptr[j] = ptr[(i-j)-1];
 534              		.loc 1 282 0
 535 0068 3578     		ldrb	r5, [r6]
 536 006a 1D70     		strb	r5, [r3]
 283:../Generated_Code/UTIL1.c ****     ptr[(i-j)-1] = tmp;
 537              		.loc 1 283 0
 538 006c 3770     		strb	r7, [r6]
 539 006e 0133     		add	r3, r3, #1
 540              	.LVL61:
 541 0070 013E     		sub	r6, r6, #1
 542 0072 F4E7     		b	.L60
 543              	.LVL62:
 544              	.L67:
 285:../Generated_Code/UTIL1.c ****   ptr[i] = '\0';
 545              		.loc 1 285 0
 546 0074 009A     		ldr	r2, [sp]
 547 0076 0021     		mov	r1, #0
 548 0078 A154     		strb	r1, [r4, r2]
 286:../Generated_Code/UTIL1.c **** }
 549              		.loc 1 286 0
 550              		@ sp needed for prologue
 551              	.LVL63:
 552 007a F7BD     		pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 553              		.cfi_endproc
 554              	.LFE5:
 556              		.section	.text.UTIL1_Num8uToStr,"ax",%progbits
 557              		.align	1
 558              		.global	UTIL1_Num8uToStr
 559              		.code	16
 560              		.thumb_func
 562              	UTIL1_Num8uToStr:
 563              	.LFB3:
 215:../Generated_Code/UTIL1.c **** {
 564              		.loc 1 215 0
 565              		.cfi_startproc
 566              	.LVL64:
 567 0000 08B5     		push	{r3, lr}
 568              	.LCFI7:
 569              		.cfi_def_cfa_offset 8
 570              		.cfi_offset 3, -8
 571              		.cfi_offset 14, -4
 216:../Generated_Code/UTIL1.c ****   UTIL1_Num16uToStr(dst, dstSize, (uint16_t)val);
 572              		.loc 1 216 0
 573 0002 FFF7FEFF 		bl	UTIL1_Num16uToStr
 574              	.LVL65:
 217:../Generated_Code/UTIL1.c **** }
 575              		.loc 1 217 0
 576              		@ sp needed for prologue
 577 0006 08BD     		pop	{r3, pc}
 578              		.cfi_endproc
 579              	.LFE3:
 581              		.global	__aeabi_idivmod
 582              		.global	__aeabi_idiv
 583              		.section	.text.UTIL1_Num16sToStr,"ax",%progbits
 584              		.align	1
 585              		.global	UTIL1_Num16sToStr
 586              		.code	16
 587              		.thumb_func
 589              	UTIL1_Num16sToStr:
 590              	.LFB6:
 309:../Generated_Code/UTIL1.c **** {
 591              		.loc 1 309 0
 592              		.cfi_startproc
 593              	.LVL66:
 594 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 595              	.LCFI8:
 596              		.cfi_def_cfa_offset 20
 597              		.cfi_offset 4, -20
 598              		.cfi_offset 5, -16
 599              		.cfi_offset 6, -12
 600              		.cfi_offset 7, -8
 601              		.cfi_offset 14, -4
 313:../Generated_Code/UTIL1.c ****   unsigned char sign = (unsigned char)(val < 0);
 602              		.loc 1 313 0
 603 0002 D30F     		lsr	r3, r2, #31
 309:../Generated_Code/UTIL1.c **** {
 604              		.loc 1 309 0
 605 0004 85B0     		sub	sp, sp, #20
 606              	.LCFI9:
 607              		.cfi_def_cfa_offset 40
 309:../Generated_Code/UTIL1.c **** {
 608              		.loc 1 309 0
 609 0006 061C     		mov	r6, r0
 610              	.LVL67:
 611 0008 141C     		mov	r4, r2
 313:../Generated_Code/UTIL1.c ****   unsigned char sign = (unsigned char)(val < 0);
 612              		.loc 1 313 0
 613 000a 0393     		str	r3, [sp, #12]
 614              	.LVL68:
 315:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 615              		.loc 1 315 0
 616 000c 4F1E     		sub	r7, r1, #1
 617              	.LVL69:
 316:../Generated_Code/UTIL1.c ****   if (sign){
 618              		.loc 1 316 0
 619 000e 002B     		cmp	r3, #0
 620 0010 01D0     		beq	.L70
 317:../Generated_Code/UTIL1.c ****     val *= -1;
 621              		.loc 1 317 0
 622 0012 5442     		neg	r4, r2
 623 0014 24B2     		sxth	r4, r4
 624              	.LVL70:
 625              	.L70:
 311:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 626              		.loc 1 311 0
 627 0016 0020     		mov	r0, #0
 628              	.LVL71:
 629 0018 0290     		str	r0, [sp, #8]
 319:../Generated_Code/UTIL1.c ****   if (val == 0 && dstSize > 0){
 630              		.loc 1 319 0
 631 001a 8442     		cmp	r4, r0
 632 001c 07D1     		bne	.L71
 311:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 633              		.loc 1 311 0
 634 001e 0294     		str	r4, [sp, #8]
 319:../Generated_Code/UTIL1.c ****   if (val == 0 && dstSize > 0){
 635              		.loc 1 319 0
 636 0020 8742     		cmp	r7, r0
 637 0022 04D0     		beq	.L71
 320:../Generated_Code/UTIL1.c ****     ptr[i++] = '0';
 638              		.loc 1 320 0
 639 0024 3021     		mov	r1, #48
 640 0026 0122     		mov	r2, #1
 641              	.LVL72:
 642 0028 3170     		strb	r1, [r6]
 643              	.LVL73:
 321:../Generated_Code/UTIL1.c ****     dstSize--;
 644              		.loc 1 321 0
 645 002a 013F     		sub	r7, r7, #1
 646              	.LVL74:
 320:../Generated_Code/UTIL1.c ****     ptr[i++] = '0';
 647              		.loc 1 320 0
 648 002c 0292     		str	r2, [sp, #8]
 649              	.LVL75:
 650              	.L71:
 311:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 651              		.loc 1 311 0
 652 002e 0197     		str	r7, [sp, #4]
 653              	.LVL76:
 654              	.L72:
 308:../Generated_Code/UTIL1.c **** void UTIL1_Num16sToStr(byte *dst, size_t dstSize, int16_t val)
 655              		.loc 1 308 0
 656 0030 029D     		ldr	r5, [sp, #8]
 657 0032 019B     		ldr	r3, [sp, #4]
 658 0034 E819     		add	r0, r5, r7
 659 0036 C11A     		sub	r1, r0, r3
 660 0038 CDB2     		uxtb	r5, r1
 661              	.LVL77:
 323:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 662              		.loc 1 323 0
 663 003a 002C     		cmp	r4, #0
 664 003c 10DD     		ble	.L73
 323:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 665              		.loc 1 323 0 is_stmt 0
 666 003e 002B     		cmp	r3, #0
 667 0040 18D0     		beq	.L75
 668              	.L74:
 324:../Generated_Code/UTIL1.c ****     ptr[i++] = (unsigned char)((val % 10) + '0');
 669              		.loc 1 324 0 is_stmt 1
 670 0042 201C     		mov	r0, r4
 671 0044 0A21     		mov	r1, #10
 672              	.LVL78:
 673 0046 FFF7FEFF 		bl	__aeabi_idivmod
 674              	.LVL79:
 675 004a 3031     		add	r1, r1, #48
 676 004c 7155     		strb	r1, [r6, r5]
 677              	.LVL80:
 325:../Generated_Code/UTIL1.c ****     dstSize--;
 678              		.loc 1 325 0
 679 004e 0199     		ldr	r1, [sp, #4]
 326:../Generated_Code/UTIL1.c ****     val /= 10;
 680              		.loc 1 326 0
 681 0050 201C     		mov	r0, r4
 325:../Generated_Code/UTIL1.c ****     dstSize--;
 682              		.loc 1 325 0
 683 0052 0139     		sub	r1, r1, #1
 684 0054 0191     		str	r1, [sp, #4]
 685              	.LVL81:
 326:../Generated_Code/UTIL1.c ****     val /= 10;
 686              		.loc 1 326 0
 687 0056 0A21     		mov	r1, #10
 688              	.LVL82:
 689 0058 FFF7FEFF 		bl	__aeabi_idiv
 690              	.LVL83:
 691 005c 04B2     		sxth	r4, r0
 692              	.LVL84:
 693 005e E7E7     		b	.L72
 694              	.LVL85:
 695              	.L73:
 328:../Generated_Code/UTIL1.c ****   if (sign && dstSize > 0){
 696              		.loc 1 328 0
 697 0060 039F     		ldr	r7, [sp, #12]
 698 0062 002F     		cmp	r7, #0
 699 0064 06D0     		beq	.L75
 328:../Generated_Code/UTIL1.c ****   if (sign && dstSize > 0){
 700              		.loc 1 328 0 is_stmt 0
 701 0066 019C     		ldr	r4, [sp, #4]
 702              	.LVL86:
 703 0068 002C     		cmp	r4, #0
 704 006a 03D0     		beq	.L75
 329:../Generated_Code/UTIL1.c ****     ptr[i++] = '-';
 705              		.loc 1 329 0 is_stmt 1
 706 006c 2D22     		mov	r2, #45
 707 006e 7255     		strb	r2, [r6, r5]
 708 0070 0135     		add	r5, r5, #1
 709 0072 EDB2     		uxtb	r5, r5
 710              	.LVL87:
 711              	.L75:
 308:../Generated_Code/UTIL1.c **** void UTIL1_Num16sToStr(byte *dst, size_t dstSize, int16_t val)
 712              		.loc 1 308 0
 713 0074 681E     		sub	r0, r5, #1
 332:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 714              		.loc 1 332 0
 715 0076 6908     		lsr	r1, r5, #1
 308:../Generated_Code/UTIL1.c **** void UTIL1_Num16sToStr(byte *dst, size_t dstSize, int16_t val)
 716              		.loc 1 308 0
 717 0078 3218     		add	r2, r6, r0
 332:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 718              		.loc 1 332 0
 719 007a 331C     		mov	r3, r6
 720              	.LVL88:
 721              	.L76:
 332:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 722              		.loc 1 332 0 is_stmt 0
 723 007c 9F1B     		sub	r7, r3, r6
 724 007e FCB2     		uxtb	r4, r7
 725 0080 8C42     		cmp	r4, r1
 726 0082 06D2     		bcs	.L90
 727              	.L77:
 333:../Generated_Code/UTIL1.c ****     tmp = ptr[j];
 728              		.loc 1 333 0 is_stmt 1
 729 0084 1878     		ldrb	r0, [r3]
 730              	.LVL89:
 334:../Generated_Code/UTIL1.c ****     ptr[j] = ptr[(i-j)-1];
 731              		.loc 1 334 0
 732 0086 1778     		ldrb	r7, [r2]
 733 0088 1F70     		strb	r7, [r3]
 335:../Generated_Code/UTIL1.c ****     ptr[(i-j)-1] = tmp;
 734              		.loc 1 335 0
 735 008a 1070     		strb	r0, [r2]
 736 008c 0133     		add	r3, r3, #1
 737              	.LVL90:
 738 008e 013A     		sub	r2, r2, #1
 739 0090 F4E7     		b	.L76
 740              	.LVL91:
 741              	.L90:
 337:../Generated_Code/UTIL1.c ****   ptr[i] = '\0';
 742              		.loc 1 337 0
 743 0092 0023     		mov	r3, #0
 744 0094 7355     		strb	r3, [r6, r5]
 338:../Generated_Code/UTIL1.c **** }
 745              		.loc 1 338 0
 746 0096 05B0     		add	sp, sp, #20
 747              		@ sp needed for prologue
 748              	.LVL92:
 749              	.LVL93:
 750 0098 F0BD     		pop	{r4, r5, r6, r7, pc}
 751              		.cfi_endproc
 752              	.LFE6:
 754              		.section	.text.UTIL1_Num8sToStr,"ax",%progbits
 755              		.align	1
 756              		.global	UTIL1_Num8sToStr
 757              		.code	16
 758              		.thumb_func
 760              	UTIL1_Num8sToStr:
 761              	.LFB4:
 240:../Generated_Code/UTIL1.c **** {
 762              		.loc 1 240 0
 763              		.cfi_startproc
 764              	.LVL94:
 765 0000 08B5     		push	{r3, lr}
 766              	.LCFI10:
 767              		.cfi_def_cfa_offset 8
 768              		.cfi_offset 3, -8
 769              		.cfi_offset 14, -4
 241:../Generated_Code/UTIL1.c ****   UTIL1_Num16sToStr(dst, dstSize, (int16_t)val);
 770              		.loc 1 241 0
 771 0002 FFF7FEFF 		bl	UTIL1_Num16sToStr
 772              	.LVL95:
 242:../Generated_Code/UTIL1.c **** }
 773              		.loc 1 242 0
 774              		@ sp needed for prologue
 775 0006 08BD     		pop	{r3, pc}
 776              		.cfi_endproc
 777              	.LFE4:
 779              		.section	.text.UTIL1_Num16sToStrFormatted,"ax",%progbits
 780              		.align	1
 781              		.global	UTIL1_Num16sToStrFormatted
 782              		.code	16
 783              		.thumb_func
 785              	UTIL1_Num16sToStrFormatted:
 786              	.LFB8:
 403:../Generated_Code/UTIL1.c **** {
 787              		.loc 1 403 0
 788              		.cfi_startproc
 789              	.LVL96:
 790 0000 70B5     		push	{r4, r5, r6, lr}
 791              	.LCFI11:
 792              		.cfi_def_cfa_offset 16
 793              		.cfi_offset 4, -16
 794              		.cfi_offset 5, -12
 795              		.cfi_offset 6, -8
 796              		.cfi_offset 14, -4
 403:../Generated_Code/UTIL1.c **** {
 797              		.loc 1 403 0
 798 0002 1E1C     		mov	r6, r3
 799 0004 04AB     		add	r3, sp, #16
 800              	.LVL97:
 801 0006 1D78     		ldrb	r5, [r3]
 802 0008 041C     		mov	r4, r0
 404:../Generated_Code/UTIL1.c ****   UTIL1_Num16sToStr(dst, dstSize, val);
 803              		.loc 1 404 0
 804 000a FFF7FEFF 		bl	UTIL1_Num16sToStr
 805              	.LVL98:
 405:../Generated_Code/UTIL1.c ****   ShiftRightAndFill(dst, fill, nofFill);
 806              		.loc 1 405 0
 807 000e 311C     		mov	r1, r6
 808 0010 2A1C     		mov	r2, r5
 809 0012 201C     		mov	r0, r4
 810 0014 FFF7FEFF 		bl	ShiftRightAndFill
 811              	.LVL99:
 406:../Generated_Code/UTIL1.c **** }
 812              		.loc 1 406 0
 813              		@ sp needed for prologue
 814              	.LVL100:
 815 0018 70BD     		pop	{r4, r5, r6, pc}
 816              		.cfi_endproc
 817              	.LFE8:
 819              		.section	.text.UTIL1_Num16uToStrFormatted,"ax",%progbits
 820              		.align	1
 821              		.global	UTIL1_Num16uToStrFormatted
 822              		.code	16
 823              		.thumb_func
 825              	UTIL1_Num16uToStrFormatted:
 826              	.LFB9:
 436:../Generated_Code/UTIL1.c **** {
 827              		.loc 1 436 0
 828              		.cfi_startproc
 829              	.LVL101:
 830 0000 70B5     		push	{r4, r5, r6, lr}
 831              	.LCFI12:
 832              		.cfi_def_cfa_offset 16
 833              		.cfi_offset 4, -16
 834              		.cfi_offset 5, -12
 835              		.cfi_offset 6, -8
 836              		.cfi_offset 14, -4
 436:../Generated_Code/UTIL1.c **** {
 837              		.loc 1 436 0
 838 0002 1E1C     		mov	r6, r3
 839 0004 04AB     		add	r3, sp, #16
 840              	.LVL102:
 841 0006 1D78     		ldrb	r5, [r3]
 842 0008 041C     		mov	r4, r0
 437:../Generated_Code/UTIL1.c ****   UTIL1_Num16uToStr(dst, dstSize, val);
 843              		.loc 1 437 0
 844 000a FFF7FEFF 		bl	UTIL1_Num16uToStr
 845              	.LVL103:
 438:../Generated_Code/UTIL1.c ****   ShiftRightAndFill(dst, fill, nofFill);
 846              		.loc 1 438 0
 847 000e 311C     		mov	r1, r6
 848 0010 2A1C     		mov	r2, r5
 849 0012 201C     		mov	r0, r4
 850 0014 FFF7FEFF 		bl	ShiftRightAndFill
 851              	.LVL104:
 439:../Generated_Code/UTIL1.c **** }
 852              		.loc 1 439 0
 853              		@ sp needed for prologue
 854              	.LVL105:
 855 0018 70BD     		pop	{r4, r5, r6, pc}
 856              		.cfi_endproc
 857              	.LFE9:
 859              		.section	.text.UTIL1_strcatNum8u,"ax",%progbits
 860              		.align	1
 861              		.global	UTIL1_strcatNum8u
 862              		.code	16
 863              		.thumb_func
 865              	UTIL1_strcatNum8u:
 866              	.LFB12:
 530:../Generated_Code/UTIL1.c **** {
 867              		.loc 1 530 0
 868              		.cfi_startproc
 869              	.LVL106:
 870 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 871              	.LCFI13:
 872              		.cfi_def_cfa_offset 24
 873              		.cfi_offset 0, -24
 874              		.cfi_offset 1, -20
 875              		.cfi_offset 2, -16
 876              		.cfi_offset 4, -12
 877              		.cfi_offset 5, -8
 878              		.cfi_offset 14, -4
 879              	.LVL107:
 530:../Generated_Code/UTIL1.c **** {
 880              		.loc 1 530 0
 881 0002 051C     		mov	r5, r0
 882 0004 0C1C     		mov	r4, r1
 883              	.LBB6:
 884              	.LBB7:
 216:../Generated_Code/UTIL1.c ****   UTIL1_Num16uToStr(dst, dstSize, (uint16_t)val);
 885              		.loc 1 216 0
 886 0006 01A8     		add	r0, sp, #4
 887              	.LVL108:
 888 0008 0421     		mov	r1, #4
 889              	.LVL109:
 890 000a FFF7FEFF 		bl	UTIL1_Num16uToStr
 891              	.LVL110:
 892              	.LBE7:
 893              	.LBE6:
 534:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 894              		.loc 1 534 0
 895 000e 281C     		mov	r0, r5
 896 0010 211C     		mov	r1, r4
 897 0012 01AA     		add	r2, sp, #4
 898              	.LVL111:
 899 0014 FFF7FEFF 		bl	UTIL1_strcat
 900              	.LVL112:
 535:../Generated_Code/UTIL1.c **** }
 901              		.loc 1 535 0
 902              		@ sp needed for prologue
 903              	.LVL113:
 904              	.LVL114:
 905 0018 37BD     		pop	{r0, r1, r2, r4, r5, pc}
 906              		.cfi_endproc
 907              	.LFE12:
 909              		.section	.text.UTIL1_strcatNum8s,"ax",%progbits
 910              		.align	1
 911              		.global	UTIL1_strcatNum8s
 912              		.code	16
 913              		.thumb_func
 915              	UTIL1_strcatNum8s:
 916              	.LFB13:
 560:../Generated_Code/UTIL1.c **** {
 917              		.loc 1 560 0
 918              		.cfi_startproc
 919              	.LVL115:
 920 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 921              	.LCFI14:
 922              		.cfi_def_cfa_offset 24
 923              		.cfi_offset 0, -24
 924              		.cfi_offset 1, -20
 925              		.cfi_offset 2, -16
 926              		.cfi_offset 4, -12
 927              		.cfi_offset 5, -8
 928              		.cfi_offset 14, -4
 929              	.LVL116:
 560:../Generated_Code/UTIL1.c **** {
 930              		.loc 1 560 0
 931 0002 051C     		mov	r5, r0
 932 0004 0C1C     		mov	r4, r1
 933              	.LBB8:
 934              	.LBB9:
 241:../Generated_Code/UTIL1.c ****   UTIL1_Num16sToStr(dst, dstSize, (int16_t)val);
 935              		.loc 1 241 0
 936 0006 6846     		mov	r0, sp
 937              	.LVL117:
 938 0008 0521     		mov	r1, #5
 939              	.LVL118:
 940 000a FFF7FEFF 		bl	UTIL1_Num16sToStr
 941              	.LVL119:
 942              	.LBE9:
 943              	.LBE8:
 564:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 944              		.loc 1 564 0
 945 000e 281C     		mov	r0, r5
 946 0010 211C     		mov	r1, r4
 947 0012 6A46     		mov	r2, sp
 948              	.LVL120:
 949 0014 FFF7FEFF 		bl	UTIL1_strcat
 950              	.LVL121:
 565:../Generated_Code/UTIL1.c **** }
 951              		.loc 1 565 0
 952              		@ sp needed for prologue
 953              	.LVL122:
 954              	.LVL123:
 955 0018 37BD     		pop	{r0, r1, r2, r4, r5, pc}
 956              		.cfi_endproc
 957              	.LFE13:
 959              		.section	.text.UTIL1_strcatNum16u,"ax",%progbits
 960              		.align	1
 961              		.global	UTIL1_strcatNum16u
 962              		.code	16
 963              		.thumb_func
 965              	UTIL1_strcatNum16u:
 966              	.LFB14:
 590:../Generated_Code/UTIL1.c **** {
 967              		.loc 1 590 0
 968              		.cfi_startproc
 969              	.LVL124:
 970 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 971              	.LCFI15:
 972              		.cfi_def_cfa_offset 24
 973              		.cfi_offset 0, -24
 974              		.cfi_offset 1, -20
 975              		.cfi_offset 2, -16
 976              		.cfi_offset 4, -12
 977              		.cfi_offset 5, -8
 978              		.cfi_offset 14, -4
 590:../Generated_Code/UTIL1.c **** {
 979              		.loc 1 590 0
 980 0002 051C     		mov	r5, r0
 981 0004 0C1C     		mov	r4, r1
 593:../Generated_Code/UTIL1.c ****   UTIL1_Num16uToStr(buf, sizeof(buf), val);
 982              		.loc 1 593 0
 983 0006 6846     		mov	r0, sp
 984              	.LVL125:
 985 0008 0621     		mov	r1, #6
 986              	.LVL126:
 987 000a FFF7FEFF 		bl	UTIL1_Num16uToStr
 988              	.LVL127:
 594:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 989              		.loc 1 594 0
 990 000e 281C     		mov	r0, r5
 991 0010 211C     		mov	r1, r4
 992 0012 6A46     		mov	r2, sp
 993 0014 FFF7FEFF 		bl	UTIL1_strcat
 994              	.LVL128:
 595:../Generated_Code/UTIL1.c **** }
 995              		.loc 1 595 0
 996              		@ sp needed for prologue
 997              	.LVL129:
 998              	.LVL130:
 999 0018 37BD     		pop	{r0, r1, r2, r4, r5, pc}
 1000              		.cfi_endproc
 1001              	.LFE14:
 1003              		.section	.text.UTIL1_strcatNum16s,"ax",%progbits
 1004              		.align	1
 1005              		.global	UTIL1_strcatNum16s
 1006              		.code	16
 1007              		.thumb_func
 1009              	UTIL1_strcatNum16s:
 1010              	.LFB15:
 620:../Generated_Code/UTIL1.c **** {
 1011              		.loc 1 620 0
 1012              		.cfi_startproc
 1013              	.LVL131:
 1014 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 1015              	.LCFI16:
 1016              		.cfi_def_cfa_offset 24
 1017              		.cfi_offset 0, -24
 1018              		.cfi_offset 1, -20
 1019              		.cfi_offset 2, -16
 1020              		.cfi_offset 4, -12
 1021              		.cfi_offset 5, -8
 1022              		.cfi_offset 14, -4
 620:../Generated_Code/UTIL1.c **** {
 1023              		.loc 1 620 0
 1024 0002 051C     		mov	r5, r0
 1025 0004 0C1C     		mov	r4, r1
 623:../Generated_Code/UTIL1.c ****   UTIL1_Num16sToStr(buf, sizeof(buf), val);
 1026              		.loc 1 623 0
 1027 0006 6846     		mov	r0, sp
 1028              	.LVL132:
 1029 0008 0721     		mov	r1, #7
 1030              	.LVL133:
 1031 000a FFF7FEFF 		bl	UTIL1_Num16sToStr
 1032              	.LVL134:
 624:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1033              		.loc 1 624 0
 1034 000e 281C     		mov	r0, r5
 1035 0010 211C     		mov	r1, r4
 1036 0012 6A46     		mov	r2, sp
 1037 0014 FFF7FEFF 		bl	UTIL1_strcat
 1038              	.LVL135:
 625:../Generated_Code/UTIL1.c **** }
 1039              		.loc 1 625 0
 1040              		@ sp needed for prologue
 1041              	.LVL136:
 1042              	.LVL137:
 1043 0018 37BD     		pop	{r0, r1, r2, r4, r5, pc}
 1044              		.cfi_endproc
 1045              	.LFE15:
 1047              		.section	.text.UTIL1_strcatNum16uFormatted,"ax",%progbits
 1048              		.align	1
 1049              		.global	UTIL1_strcatNum16uFormatted
 1050              		.code	16
 1051              		.thumb_func
 1053              	UTIL1_strcatNum16uFormatted:
 1054              	.LFB16:
 656:../Generated_Code/UTIL1.c **** {
 1055              		.loc 1 656 0
 1056              		.cfi_startproc
 1057              	.LVL138:
 1058 0000 30B5     		push	{r4, r5, lr}
 1059              	.LCFI17:
 1060              		.cfi_def_cfa_offset 12
 1061              		.cfi_offset 4, -12
 1062              		.cfi_offset 5, -8
 1063              		.cfi_offset 14, -4
 1064 0002 85B0     		sub	sp, sp, #20
 1065              	.LCFI18:
 1066              		.cfi_def_cfa_offset 32
 656:../Generated_Code/UTIL1.c **** {
 1067              		.loc 1 656 0
 1068 0004 0C1C     		mov	r4, r1
 1069 0006 08A9     		add	r1, sp, #32
 1070              	.LVL139:
 1071 0008 051C     		mov	r5, r0
 1072 000a 0878     		ldrb	r0, [r1]
 1073              	.LVL140:
 659:../Generated_Code/UTIL1.c ****   UTIL1_Num16uToStrFormatted(buf, dstSize, val, fill, nofFill);
 1074              		.loc 1 659 0
 1075 000c 211C     		mov	r1, r4
 1076 000e 0090     		str	r0, [sp]
 1077 0010 02A8     		add	r0, sp, #8
 1078 0012 FFF7FEFF 		bl	UTIL1_Num16uToStrFormatted
 1079              	.LVL141:
 660:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1080              		.loc 1 660 0
 1081 0016 281C     		mov	r0, r5
 1082 0018 211C     		mov	r1, r4
 1083 001a 02AA     		add	r2, sp, #8
 1084 001c FFF7FEFF 		bl	UTIL1_strcat
 1085              	.LVL142:
 661:../Generated_Code/UTIL1.c **** }
 1086              		.loc 1 661 0
 1087 0020 05B0     		add	sp, sp, #20
 1088              		@ sp needed for prologue
 1089              	.LVL143:
 1090              	.LVL144:
 1091 0022 30BD     		pop	{r4, r5, pc}
 1092              		.cfi_endproc
 1093              	.LFE16:
 1095              		.section	.text.UTIL1_strcatNum16sFormatted,"ax",%progbits
 1096              		.align	1
 1097              		.global	UTIL1_strcatNum16sFormatted
 1098              		.code	16
 1099              		.thumb_func
 1101              	UTIL1_strcatNum16sFormatted:
 1102              	.LFB17:
 692:../Generated_Code/UTIL1.c **** {
 1103              		.loc 1 692 0
 1104              		.cfi_startproc
 1105              	.LVL145:
 1106 0000 30B5     		push	{r4, r5, lr}
 1107              	.LCFI19:
 1108              		.cfi_def_cfa_offset 12
 1109              		.cfi_offset 4, -12
 1110              		.cfi_offset 5, -8
 1111              		.cfi_offset 14, -4
 1112 0002 85B0     		sub	sp, sp, #20
 1113              	.LCFI20:
 1114              		.cfi_def_cfa_offset 32
 692:../Generated_Code/UTIL1.c **** {
 1115              		.loc 1 692 0
 1116 0004 0C1C     		mov	r4, r1
 1117 0006 08A9     		add	r1, sp, #32
 1118              	.LVL146:
 1119 0008 051C     		mov	r5, r0
 1120 000a 0878     		ldrb	r0, [r1]
 1121              	.LVL147:
 695:../Generated_Code/UTIL1.c ****   UTIL1_Num16sToStrFormatted(buf, dstSize, val, fill, nofFill);
 1122              		.loc 1 695 0
 1123 000c 211C     		mov	r1, r4
 1124 000e 0090     		str	r0, [sp]
 1125 0010 02A8     		add	r0, sp, #8
 1126 0012 FFF7FEFF 		bl	UTIL1_Num16sToStrFormatted
 1127              	.LVL148:
 696:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1128              		.loc 1 696 0
 1129 0016 281C     		mov	r0, r5
 1130 0018 211C     		mov	r1, r4
 1131 001a 02AA     		add	r2, sp, #8
 1132 001c FFF7FEFF 		bl	UTIL1_strcat
 1133              	.LVL149:
 697:../Generated_Code/UTIL1.c **** }
 1134              		.loc 1 697 0
 1135 0020 05B0     		add	sp, sp, #20
 1136              		@ sp needed for prologue
 1137              	.LVL150:
 1138              	.LVL151:
 1139 0022 30BD     		pop	{r4, r5, pc}
 1140              		.cfi_endproc
 1141              	.LFE17:
 1143              		.section	.text.UTIL1_strcatNum8Hex,"ax",%progbits
 1144              		.align	1
 1145              		.global	UTIL1_strcatNum8Hex
 1146              		.code	16
 1147              		.thumb_func
 1149              	UTIL1_strcatNum8Hex:
 1150              	.LFB20:
 793:../Generated_Code/UTIL1.c **** {
 1151              		.loc 1 793 0
 1152              		.cfi_startproc
 1153              	.LVL152:
 1154 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 1155              	.LCFI21:
 1156              		.cfi_def_cfa_offset 24
 1157              		.cfi_offset 0, -24
 1158              		.cfi_offset 1, -20
 1159              		.cfi_offset 2, -16
 1160              		.cfi_offset 4, -12
 1161              		.cfi_offset 5, -8
 1162              		.cfi_offset 14, -4
 797:../Generated_Code/UTIL1.c ****   buf[2] = '\0';
 1163              		.loc 1 797 0
 1164 0002 0024     		mov	r4, #0
 1165 0004 01AB     		add	r3, sp, #4
 1166 0006 9C70     		strb	r4, [r3, #2]
 798:../Generated_Code/UTIL1.c ****   hex = (char)(num & 0x0F);
 1167              		.loc 1 798 0
 1168 0008 0F24     		mov	r4, #15
 1169 000a 1440     		and	r4, r2
 1170              	.LVL153:
 799:../Generated_Code/UTIL1.c ****   buf[1] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1171              		.loc 1 799 0
 1172 000c 3725     		mov	r5, #55
 1173 000e 092C     		cmp	r4, #9
 1174 0010 00D8     		bhi	.L101
 1175 0012 3025     		mov	r5, #48
 1176              	.L101:
 799:../Generated_Code/UTIL1.c ****   buf[1] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1177              		.loc 1 799 0 is_stmt 0
 1178 0014 2C19     		add	r4, r5, r4
 1179              	.LVL154:
 1180 0016 5C70     		strb	r4, [r3, #1]
 800:../Generated_Code/UTIL1.c ****   hex = (char)((num>>4) & 0x0F);
 1181              		.loc 1 800 0 is_stmt 1
 1182 0018 1209     		lsr	r2, r2, #4
 1183              	.LVL155:
 801:../Generated_Code/UTIL1.c ****   buf[0] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1184              		.loc 1 801 0
 1185 001a 3725     		mov	r5, #55
 1186 001c 092A     		cmp	r2, #9
 1187 001e 00D8     		bhi	.L102
 801:../Generated_Code/UTIL1.c ****   buf[0] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1188              		.loc 1 801 0 is_stmt 0
 1189 0020 3025     		mov	r5, #48
 1190              	.L102:
 801:../Generated_Code/UTIL1.c ****   buf[0] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1191              		.loc 1 801 0
 1192 0022 AC18     		add	r4, r5, r2
 802:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1193              		.loc 1 802 0 is_stmt 1
 1194 0024 1A1C     		mov	r2, r3
 1195              	.LVL156:
 801:../Generated_Code/UTIL1.c ****   buf[0] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1196              		.loc 1 801 0
 1197 0026 1C70     		strb	r4, [r3]
 803:../Generated_Code/UTIL1.c **** }
 1198              		.loc 1 803 0
 1199              		@ sp needed for prologue
 802:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1200              		.loc 1 802 0
 1201 0028 FFF7FEFF 		bl	UTIL1_strcat
 1202              	.LVL157:
 803:../Generated_Code/UTIL1.c **** }
 1203              		.loc 1 803 0
 1204 002c 37BD     		pop	{r0, r1, r2, r4, r5, pc}
 1205              		.cfi_endproc
 1206              	.LFE20:
 1208              		.section	.text.UTIL1_strcatNum16Hex,"ax",%progbits
 1209              		.align	1
 1210              		.global	UTIL1_strcatNum16Hex
 1211              		.code	16
 1212              		.thumb_func
 1214              	UTIL1_strcatNum16Hex:
 1215              	.LFB21:
 827:../Generated_Code/UTIL1.c **** {
 1216              		.loc 1 827 0
 1217              		.cfi_startproc
 1218              	.LVL158:
 1219 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 1220              	.LCFI22:
 1221              		.cfi_def_cfa_offset 32
 1222              		.cfi_offset 0, -32
 1223              		.cfi_offset 1, -28
 1224              		.cfi_offset 2, -24
 1225              		.cfi_offset 4, -20
 1226              		.cfi_offset 5, -16
 1227              		.cfi_offset 6, -12
 1228              		.cfi_offset 7, -8
 1229              		.cfi_offset 14, -4
 832:../Generated_Code/UTIL1.c ****   buf[4] = '\0';
 1230              		.loc 1 832 0
 1231 0002 0023     		mov	r3, #0
 1232 0004 6C46     		mov	r4, sp
 1233 0006 2371     		strb	r3, [r4, #4]
 1234              	.LVL159:
 1235              	.L107:
 835:../Generated_Code/UTIL1.c ****     hex = (char)(num & 0x0F);
 1236              		.loc 1 835 0
 1237 0008 0F24     		mov	r4, #15
 1238 000a 1440     		and	r4, r2
 1239              	.LVL160:
 836:../Generated_Code/UTIL1.c ****     buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1240              		.loc 1 836 0
 1241 000c 3725     		mov	r5, #55
 1242 000e 092C     		cmp	r4, #9
 1243 0010 00D8     		bhi	.L106
 1244 0012 3025     		mov	r5, #48
 1245              	.L106:
 826:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum16Hex(byte *dst, size_t dstSize, word num)
 1246              		.loc 1 826 0
 1247 0014 00AF     		add	r7, sp, #0
 1248 0016 FE18     		add	r6, r7, r3
 836:../Generated_Code/UTIL1.c ****     buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1249              		.loc 1 836 0
 1250 0018 2C19     		add	r4, r5, r4
 1251 001a 013B     		sub	r3, r3, #1
 1252 001c F470     		strb	r4, [r6, #3]
 837:../Generated_Code/UTIL1.c ****     num >>= 4;                          /* next nibble */
 1253              		.loc 1 837 0
 1254 001e 1209     		lsr	r2, r2, #4
 1255              	.LVL161:
 839:../Generated_Code/UTIL1.c ****   } while (i>=0);
 1256              		.loc 1 839 0
 1257 0020 1C1D     		add	r4, r3, #4
 1258 0022 F1D1     		bne	.L107
 840:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1259              		.loc 1 840 0
 1260 0024 6A46     		mov	r2, sp
 1261              	.LVL162:
 1262 0026 FFF7FEFF 		bl	UTIL1_strcat
 1263              	.LVL163:
 841:../Generated_Code/UTIL1.c **** }
 1264              		.loc 1 841 0
 1265              		@ sp needed for prologue
 1266 002a F7BD     		pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 1267              		.cfi_endproc
 1268              	.LFE21:
 1270              		.section	.text.UTIL1_strcatNum24Hex,"ax",%progbits
 1271              		.align	1
 1272              		.global	UTIL1_strcatNum24Hex
 1273              		.code	16
 1274              		.thumb_func
 1276              	UTIL1_strcatNum24Hex:
 1277              	.LFB22:
 865:../Generated_Code/UTIL1.c **** {
 1278              		.loc 1 865 0
 1279              		.cfi_startproc
 1280              	.LVL164:
 1281 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 1282              	.LCFI23:
 1283              		.cfi_def_cfa_offset 32
 1284              		.cfi_offset 0, -32
 1285              		.cfi_offset 1, -28
 1286              		.cfi_offset 2, -24
 1287              		.cfi_offset 4, -20
 1288              		.cfi_offset 5, -16
 1289              		.cfi_offset 6, -12
 1290              		.cfi_offset 7, -8
 1291              		.cfi_offset 14, -4
 870:../Generated_Code/UTIL1.c ****   buf[6] = '\0';
 1292              		.loc 1 870 0
 1293 0002 0023     		mov	r3, #0
 1294 0004 6C46     		mov	r4, sp
 1295 0006 A371     		strb	r3, [r4, #6]
 1296              	.LVL165:
 1297              	.L112:
 873:../Generated_Code/UTIL1.c ****     hex = (char)(num & 0x0F);
 1298              		.loc 1 873 0
 1299 0008 0F24     		mov	r4, #15
 1300 000a 1440     		and	r4, r2
 1301              	.LVL166:
 874:../Generated_Code/UTIL1.c ****     buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1302              		.loc 1 874 0
 1303 000c 3725     		mov	r5, #55
 1304 000e 092C     		cmp	r4, #9
 1305 0010 00D8     		bhi	.L111
 1306 0012 3025     		mov	r5, #48
 1307              	.L111:
 864:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum24Hex(byte *dst, size_t dstSize, dword num)
 1308              		.loc 1 864 0
 1309 0014 00AF     		add	r7, sp, #0
 1310 0016 FE18     		add	r6, r7, r3
 874:../Generated_Code/UTIL1.c ****     buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1311              		.loc 1 874 0
 1312 0018 2C19     		add	r4, r5, r4
 1313              	.LVL167:
 1314 001a 013B     		sub	r3, r3, #1
 1315 001c 7471     		strb	r4, [r6, #5]
 875:../Generated_Code/UTIL1.c ****     num >>= 4;                          /* next nibble */
 1316              		.loc 1 875 0
 1317 001e 1209     		lsr	r2, r2, #4
 1318              	.LVL168:
 877:../Generated_Code/UTIL1.c ****   } while (i>=0);
 1319              		.loc 1 877 0
 1320 0020 9C1D     		add	r4, r3, #6
 1321 0022 F1D1     		bne	.L112
 878:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1322              		.loc 1 878 0
 1323 0024 6A46     		mov	r2, sp
 1324              	.LVL169:
 1325 0026 FFF7FEFF 		bl	UTIL1_strcat
 1326              	.LVL170:
 879:../Generated_Code/UTIL1.c **** }
 1327              		.loc 1 879 0
 1328              		@ sp needed for prologue
 1329 002a F7BD     		pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 1330              		.cfi_endproc
 1331              	.LFE22:
 1333              		.section	.text.UTIL1_strcatNum32Hex,"ax",%progbits
 1334              		.align	1
 1335              		.global	UTIL1_strcatNum32Hex
 1336              		.code	16
 1337              		.thumb_func
 1339              	UTIL1_strcatNum32Hex:
 1340              	.LFB23:
 903:../Generated_Code/UTIL1.c **** {
 1341              		.loc 1 903 0
 1342              		.cfi_startproc
 1343              	.LVL171:
 1344 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1345              	.LCFI24:
 1346              		.cfi_def_cfa_offset 20
 1347              		.cfi_offset 4, -20
 1348              		.cfi_offset 5, -16
 1349              		.cfi_offset 6, -12
 1350              		.cfi_offset 7, -8
 1351              		.cfi_offset 14, -4
 1352 0002 85B0     		sub	sp, sp, #20
 1353              	.LCFI25:
 1354              		.cfi_def_cfa_offset 40
 903:../Generated_Code/UTIL1.c **** {
 1355              		.loc 1 903 0
 1356 0004 141C     		mov	r4, r2
 908:../Generated_Code/UTIL1.c ****   buf[8] = '\0';
 1357              		.loc 1 908 0
 1358 0006 0023     		mov	r3, #0
 1359 0008 01AA     		add	r2, sp, #4
 1360              	.LVL172:
 1361 000a 1372     		strb	r3, [r2, #8]
 1362              	.LVL173:
 1363              	.L117:
 911:../Generated_Code/UTIL1.c ****     hex = (char)(num & 0x0F);
 1364              		.loc 1 911 0
 1365 000c 0F25     		mov	r5, #15
 1366 000e 2540     		and	r5, r4
 1367              	.LVL174:
 912:../Generated_Code/UTIL1.c ****     buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1368              		.loc 1 912 0
 1369 0010 3726     		mov	r6, #55
 1370 0012 092D     		cmp	r5, #9
 1371 0014 00D8     		bhi	.L116
 1372 0016 3026     		mov	r6, #48
 1373              	.L116:
 902:../Generated_Code/UTIL1.c **** void UTIL1_strcatNum32Hex(byte *dst, size_t dstSize, dword num)
 1374              		.loc 1 902 0
 1375 0018 D718     		add	r7, r2, r3
 1376 001a 013B     		sub	r3, r3, #1
 912:../Generated_Code/UTIL1.c ****     buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1377              		.loc 1 912 0
 1378 001c 7519     		add	r5, r6, r5
 1379              	.LVL175:
 915:../Generated_Code/UTIL1.c ****   } while (i>=0);
 1380              		.loc 1 915 0
 1381 001e 1E1C     		mov	r6, r3
 912:../Generated_Code/UTIL1.c ****     buf[i] = (char)(hex + ((hex <= 9) ? '0' : ('A'-10)));
 1382              		.loc 1 912 0
 1383 0020 FD71     		strb	r5, [r7, #7]
 913:../Generated_Code/UTIL1.c ****     num >>= 4;                          /* next nibble */
 1384              		.loc 1 913 0
 1385 0022 2409     		lsr	r4, r4, #4
 1386              	.LVL176:
 915:../Generated_Code/UTIL1.c ****   } while (i>=0);
 1387              		.loc 1 915 0
 1388 0024 0836     		add	r6, r6, #8
 1389 0026 F1D1     		bne	.L117
 916:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1390              		.loc 1 916 0
 1391 0028 FFF7FEFF 		bl	UTIL1_strcat
 1392              	.LVL177:
 917:../Generated_Code/UTIL1.c **** }
 1393              		.loc 1 917 0
 1394 002c 05B0     		add	sp, sp, #20
 1395              		@ sp needed for prologue
 1396              	.LVL178:
 1397 002e F0BD     		pop	{r4, r5, r6, r7, pc}
 1398              		.cfi_endproc
 1399              	.LFE23:
 1401              		.section	.text.UTIL1_Num32sToStr,"ax",%progbits
 1402              		.align	1
 1403              		.global	UTIL1_Num32sToStr
 1404              		.code	16
 1405              		.thumb_func
 1407              	UTIL1_Num32sToStr:
 1408              	.LFB26:
1000:../Generated_Code/UTIL1.c **** {
 1409              		.loc 1 1000 0
 1410              		.cfi_startproc
 1411              	.LVL179:
 1412 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1413              	.LCFI26:
 1414              		.cfi_def_cfa_offset 20
 1415              		.cfi_offset 4, -20
 1416              		.cfi_offset 5, -16
 1417              		.cfi_offset 6, -12
 1418              		.cfi_offset 7, -8
 1419              		.cfi_offset 14, -4
1004:../Generated_Code/UTIL1.c ****   unsigned char sign = (unsigned char)(val < 0);
 1420              		.loc 1 1004 0
 1421 0002 D30F     		lsr	r3, r2, #31
1000:../Generated_Code/UTIL1.c **** {
 1422              		.loc 1 1000 0
 1423 0004 85B0     		sub	sp, sp, #20
 1424              	.LCFI27:
 1425              		.cfi_def_cfa_offset 40
1000:../Generated_Code/UTIL1.c **** {
 1426              		.loc 1 1000 0
 1427 0006 061C     		mov	r6, r0
 1428              	.LVL180:
 1429 0008 141C     		mov	r4, r2
1004:../Generated_Code/UTIL1.c ****   unsigned char sign = (unsigned char)(val < 0);
 1430              		.loc 1 1004 0
 1431 000a 0393     		str	r3, [sp, #12]
 1432              	.LVL181:
1006:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 1433              		.loc 1 1006 0
 1434 000c 4F1E     		sub	r7, r1, #1
 1435              	.LVL182:
1007:../Generated_Code/UTIL1.c ****   if (sign){
 1436              		.loc 1 1007 0
 1437 000e 002B     		cmp	r3, #0
 1438 0010 00D0     		beq	.L121
1008:../Generated_Code/UTIL1.c ****     val *= -1;
 1439              		.loc 1 1008 0
 1440 0012 5442     		neg	r4, r2
 1441              	.LVL183:
 1442              	.L121:
1002:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 1443              		.loc 1 1002 0
 1444 0014 0020     		mov	r0, #0
 1445              	.LVL184:
 1446 0016 0290     		str	r0, [sp, #8]
1010:../Generated_Code/UTIL1.c ****   if (val == 0 && dstSize > 0){
 1447              		.loc 1 1010 0
 1448 0018 8442     		cmp	r4, r0
 1449 001a 07D1     		bne	.L122
1002:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 1450              		.loc 1 1002 0
 1451 001c 0294     		str	r4, [sp, #8]
1010:../Generated_Code/UTIL1.c ****   if (val == 0 && dstSize > 0){
 1452              		.loc 1 1010 0
 1453 001e 8742     		cmp	r7, r0
 1454 0020 04D0     		beq	.L122
1011:../Generated_Code/UTIL1.c ****     ptr[i++] = '0';
 1455              		.loc 1 1011 0
 1456 0022 3021     		mov	r1, #48
 1457 0024 0122     		mov	r2, #1
 1458 0026 3170     		strb	r1, [r6]
 1459              	.LVL185:
1012:../Generated_Code/UTIL1.c ****     dstSize--;
 1460              		.loc 1 1012 0
 1461 0028 013F     		sub	r7, r7, #1
 1462              	.LVL186:
1011:../Generated_Code/UTIL1.c ****     ptr[i++] = '0';
 1463              		.loc 1 1011 0
 1464 002a 0292     		str	r2, [sp, #8]
 1465              	.LVL187:
 1466              	.L122:
1002:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 1467              		.loc 1 1002 0
 1468 002c 0197     		str	r7, [sp, #4]
 1469              	.LVL188:
 1470              	.L123:
 999:../Generated_Code/UTIL1.c **** void UTIL1_Num32sToStr(byte *dst, size_t dstSize, long val)
 1471              		.loc 1 999 0
 1472 002e 029D     		ldr	r5, [sp, #8]
 1473 0030 019B     		ldr	r3, [sp, #4]
 1474 0032 E819     		add	r0, r5, r7
 1475 0034 C11A     		sub	r1, r0, r3
 1476 0036 CDB2     		uxtb	r5, r1
 1477              	.LVL189:
1014:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 1478              		.loc 1 1014 0
 1479 0038 002C     		cmp	r4, #0
 1480 003a 10DD     		ble	.L124
1014:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 1481              		.loc 1 1014 0 is_stmt 0
 1482 003c 002B     		cmp	r3, #0
 1483 003e 18D0     		beq	.L126
 1484              	.L125:
1015:../Generated_Code/UTIL1.c ****     ptr[i++] = (unsigned char)((val % 10) + '0');
 1485              		.loc 1 1015 0 is_stmt 1
 1486 0040 201C     		mov	r0, r4
 1487 0042 0A21     		mov	r1, #10
 1488              	.LVL190:
 1489 0044 FFF7FEFF 		bl	__aeabi_idivmod
 1490              	.LVL191:
 1491 0048 3031     		add	r1, r1, #48
 1492 004a 7155     		strb	r1, [r6, r5]
 1493              	.LVL192:
1016:../Generated_Code/UTIL1.c ****     dstSize--;
 1494              		.loc 1 1016 0
 1495 004c 0199     		ldr	r1, [sp, #4]
1017:../Generated_Code/UTIL1.c ****     val /= 10;
 1496              		.loc 1 1017 0
 1497 004e 201C     		mov	r0, r4
1016:../Generated_Code/UTIL1.c ****     dstSize--;
 1498              		.loc 1 1016 0
 1499 0050 0139     		sub	r1, r1, #1
 1500 0052 0191     		str	r1, [sp, #4]
 1501              	.LVL193:
1017:../Generated_Code/UTIL1.c ****     val /= 10;
 1502              		.loc 1 1017 0
 1503 0054 0A21     		mov	r1, #10
 1504              	.LVL194:
 1505 0056 FFF7FEFF 		bl	__aeabi_idiv
 1506              	.LVL195:
 1507 005a 041C     		mov	r4, r0
 1508              	.LVL196:
 1509 005c E7E7     		b	.L123
 1510              	.LVL197:
 1511              	.L124:
1019:../Generated_Code/UTIL1.c ****   if (sign && dstSize > 0){
 1512              		.loc 1 1019 0
 1513 005e 039C     		ldr	r4, [sp, #12]
 1514              	.LVL198:
 1515 0060 002C     		cmp	r4, #0
 1516 0062 06D0     		beq	.L126
1019:../Generated_Code/UTIL1.c ****   if (sign && dstSize > 0){
 1517              		.loc 1 1019 0 is_stmt 0
 1518 0064 019F     		ldr	r7, [sp, #4]
 1519 0066 002F     		cmp	r7, #0
 1520 0068 03D0     		beq	.L126
1020:../Generated_Code/UTIL1.c ****     ptr[i++] = '-';
 1521              		.loc 1 1020 0 is_stmt 1
 1522 006a 2D22     		mov	r2, #45
 1523 006c 7255     		strb	r2, [r6, r5]
 1524 006e 0135     		add	r5, r5, #1
 1525 0070 EDB2     		uxtb	r5, r5
 1526              	.LVL199:
 1527              	.L126:
 999:../Generated_Code/UTIL1.c **** void UTIL1_Num32sToStr(byte *dst, size_t dstSize, long val)
 1528              		.loc 1 999 0
 1529 0072 681E     		sub	r0, r5, #1
1023:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 1530              		.loc 1 1023 0
 1531 0074 6908     		lsr	r1, r5, #1
 999:../Generated_Code/UTIL1.c **** void UTIL1_Num32sToStr(byte *dst, size_t dstSize, long val)
 1532              		.loc 1 999 0
 1533 0076 3218     		add	r2, r6, r0
1023:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 1534              		.loc 1 1023 0
 1535 0078 331C     		mov	r3, r6
 1536              	.LVL200:
 1537              	.L127:
1023:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 1538              		.loc 1 1023 0 is_stmt 0
 1539 007a 9C1B     		sub	r4, r3, r6
 1540 007c E7B2     		uxtb	r7, r4
 1541 007e 8F42     		cmp	r7, r1
 1542 0080 06D2     		bcs	.L141
 1543              	.L128:
1024:../Generated_Code/UTIL1.c ****     tmp = ptr[j];
 1544              		.loc 1 1024 0 is_stmt 1
 1545 0082 1878     		ldrb	r0, [r3]
 1546              	.LVL201:
1025:../Generated_Code/UTIL1.c ****     ptr[j] = ptr[(i-j)-1];
 1547              		.loc 1 1025 0
 1548 0084 1478     		ldrb	r4, [r2]
 1549 0086 1C70     		strb	r4, [r3]
1026:../Generated_Code/UTIL1.c ****     ptr[(i-j)-1] = tmp;
 1550              		.loc 1 1026 0
 1551 0088 1070     		strb	r0, [r2]
 1552 008a 0133     		add	r3, r3, #1
 1553              	.LVL202:
 1554 008c 013A     		sub	r2, r2, #1
 1555 008e F4E7     		b	.L127
 1556              	.LVL203:
 1557              	.L141:
1028:../Generated_Code/UTIL1.c ****   ptr[i] = '\0';
 1558              		.loc 1 1028 0
 1559 0090 0023     		mov	r3, #0
 1560 0092 7355     		strb	r3, [r6, r5]
1029:../Generated_Code/UTIL1.c **** }
 1561              		.loc 1 1029 0
 1562 0094 05B0     		add	sp, sp, #20
 1563              		@ sp needed for prologue
 1564              	.LVL204:
 1565              	.LVL205:
 1566 0096 F0BD     		pop	{r4, r5, r6, r7, pc}
 1567              		.cfi_endproc
 1568              	.LFE26:
 1570              		.section	.text.UTIL1_strcatNum32s,"ax",%progbits
 1571              		.align	1
 1572              		.global	UTIL1_strcatNum32s
 1573              		.code	16
 1574              		.thumb_func
 1576              	UTIL1_strcatNum32s:
 1577              	.LFB24:
 942:../Generated_Code/UTIL1.c **** {
 1578              		.loc 1 942 0
 1579              		.cfi_startproc
 1580              	.LVL206:
 1581 0000 30B5     		push	{r4, r5, lr}
 1582              	.LCFI28:
 1583              		.cfi_def_cfa_offset 12
 1584              		.cfi_offset 4, -12
 1585              		.cfi_offset 5, -8
 1586              		.cfi_offset 14, -4
 1587 0002 85B0     		sub	sp, sp, #20
 1588              	.LCFI29:
 1589              		.cfi_def_cfa_offset 32
 942:../Generated_Code/UTIL1.c **** {
 1590              		.loc 1 942 0
 1591 0004 051C     		mov	r5, r0
 1592 0006 0C1C     		mov	r4, r1
 945:../Generated_Code/UTIL1.c ****   UTIL1_Num32sToStr(buf, sizeof(buf), val);
 1593              		.loc 1 945 0
 1594 0008 01A8     		add	r0, sp, #4
 1595              	.LVL207:
 1596 000a 0C21     		mov	r1, #12
 1597              	.LVL208:
 1598 000c FFF7FEFF 		bl	UTIL1_Num32sToStr
 1599              	.LVL209:
 946:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1600              		.loc 1 946 0
 1601 0010 281C     		mov	r0, r5
 1602 0012 211C     		mov	r1, r4
 1603 0014 01AA     		add	r2, sp, #4
 1604 0016 FFF7FEFF 		bl	UTIL1_strcat
 1605              	.LVL210:
 947:../Generated_Code/UTIL1.c **** }
 1606              		.loc 1 947 0
 1607 001a 05B0     		add	sp, sp, #20
 1608              		@ sp needed for prologue
 1609              	.LVL211:
 1610              	.LVL212:
 1611 001c 30BD     		pop	{r4, r5, pc}
 1612              		.cfi_endproc
 1613              	.LFE24:
 1615              		.section	.text.UTIL1_Num32sToStrFormatted,"ax",%progbits
 1616              		.align	1
 1617              		.global	UTIL1_Num32sToStrFormatted
 1618              		.code	16
 1619              		.thumb_func
 1621              	UTIL1_Num32sToStrFormatted:
 1622              	.LFB11:
 502:../Generated_Code/UTIL1.c **** {
 1623              		.loc 1 502 0
 1624              		.cfi_startproc
 1625              	.LVL213:
 1626 0000 70B5     		push	{r4, r5, r6, lr}
 1627              	.LCFI30:
 1628              		.cfi_def_cfa_offset 16
 1629              		.cfi_offset 4, -16
 1630              		.cfi_offset 5, -12
 1631              		.cfi_offset 6, -8
 1632              		.cfi_offset 14, -4
 502:../Generated_Code/UTIL1.c **** {
 1633              		.loc 1 502 0
 1634 0002 1E1C     		mov	r6, r3
 1635 0004 04AB     		add	r3, sp, #16
 1636              	.LVL214:
 1637 0006 1D78     		ldrb	r5, [r3]
 1638 0008 041C     		mov	r4, r0
 503:../Generated_Code/UTIL1.c ****   UTIL1_Num32sToStr(dst, dstSize, val);
 1639              		.loc 1 503 0
 1640 000a FFF7FEFF 		bl	UTIL1_Num32sToStr
 1641              	.LVL215:
 504:../Generated_Code/UTIL1.c ****   ShiftRightAndFill(dst, fill, nofFill);
 1642              		.loc 1 504 0
 1643 000e 311C     		mov	r1, r6
 1644 0010 2A1C     		mov	r2, r5
 1645 0012 201C     		mov	r0, r4
 1646 0014 FFF7FEFF 		bl	ShiftRightAndFill
 1647              	.LVL216:
 505:../Generated_Code/UTIL1.c **** }
 1648              		.loc 1 505 0
 1649              		@ sp needed for prologue
 1650              	.LVL217:
 1651 0018 70BD     		pop	{r4, r5, r6, pc}
 1652              		.cfi_endproc
 1653              	.LFE11:
 1655              		.section	.text.UTIL1_strcatNum32sFormatted,"ax",%progbits
 1656              		.align	1
 1657              		.global	UTIL1_strcatNum32sFormatted
 1658              		.code	16
 1659              		.thumb_func
 1661              	UTIL1_strcatNum32sFormatted:
 1662              	.LFB19:
 764:../Generated_Code/UTIL1.c **** {
 1663              		.loc 1 764 0
 1664              		.cfi_startproc
 1665              	.LVL218:
 1666 0000 30B5     		push	{r4, r5, lr}
 1667              	.LCFI31:
 1668              		.cfi_def_cfa_offset 12
 1669              		.cfi_offset 4, -12
 1670              		.cfi_offset 5, -8
 1671              		.cfi_offset 14, -4
 1672 0002 87B0     		sub	sp, sp, #28
 1673              	.LCFI32:
 1674              		.cfi_def_cfa_offset 40
 764:../Generated_Code/UTIL1.c **** {
 1675              		.loc 1 764 0
 1676 0004 0C1C     		mov	r4, r1
 1677 0006 0AA9     		add	r1, sp, #40
 1678              	.LVL219:
 1679 0008 051C     		mov	r5, r0
 1680 000a 0878     		ldrb	r0, [r1]
 1681              	.LVL220:
 767:../Generated_Code/UTIL1.c ****   UTIL1_Num32sToStrFormatted(buf, dstSize, val, fill, nofFill);
 1682              		.loc 1 767 0
 1683 000c 211C     		mov	r1, r4
 1684 000e 0090     		str	r0, [sp]
 1685 0010 03A8     		add	r0, sp, #12
 1686 0012 FFF7FEFF 		bl	UTIL1_Num32sToStrFormatted
 1687              	.LVL221:
 768:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1688              		.loc 1 768 0
 1689 0016 281C     		mov	r0, r5
 1690 0018 211C     		mov	r1, r4
 1691 001a 03AA     		add	r2, sp, #12
 1692 001c FFF7FEFF 		bl	UTIL1_strcat
 1693              	.LVL222:
 769:../Generated_Code/UTIL1.c **** }
 1694              		.loc 1 769 0
 1695 0020 07B0     		add	sp, sp, #28
 1696              		@ sp needed for prologue
 1697              	.LVL223:
 1698              	.LVL224:
 1699 0022 30BD     		pop	{r4, r5, pc}
 1700              		.cfi_endproc
 1701              	.LFE19:
 1703              		.section	.text.UTIL1_Num32uToStr,"ax",%progbits
 1704              		.align	1
 1705              		.global	UTIL1_Num32uToStr
 1706              		.code	16
 1707              		.thumb_func
 1709              	UTIL1_Num32uToStr:
 1710              	.LFB27:
1052:../Generated_Code/UTIL1.c **** {
 1711              		.loc 1 1052 0
 1712              		.cfi_startproc
 1713              	.LVL225:
 1714 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 1715              	.LCFI33:
 1716              		.cfi_def_cfa_offset 32
 1717              		.cfi_offset 0, -32
 1718              		.cfi_offset 1, -28
 1719              		.cfi_offset 2, -24
 1720              		.cfi_offset 4, -20
 1721              		.cfi_offset 5, -16
 1722              		.cfi_offset 6, -12
 1723              		.cfi_offset 7, -8
 1724              		.cfi_offset 14, -4
1052:../Generated_Code/UTIL1.c **** {
 1725              		.loc 1 1052 0
 1726 0002 151C     		mov	r5, r2
1054:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 1727              		.loc 1 1054 0
 1728 0004 0022     		mov	r2, #0
 1729              	.LVL226:
1052:../Generated_Code/UTIL1.c **** {
 1730              		.loc 1 1052 0
 1731 0006 041C     		mov	r4, r0
1057:../Generated_Code/UTIL1.c ****   dstSize--; /* for zero byte */
 1732              		.loc 1 1057 0
 1733 0008 4F1E     		sub	r7, r1, #1
 1734              	.LVL227:
1054:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 1735              		.loc 1 1054 0
 1736 000a 0192     		str	r2, [sp, #4]
1058:../Generated_Code/UTIL1.c ****   if (val == 0 && dstSize > 0){
 1737              		.loc 1 1058 0
 1738 000c 9542     		cmp	r5, r2
 1739 000e 07D1     		bne	.L146
1054:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 1740              		.loc 1 1054 0
 1741 0010 0195     		str	r5, [sp, #4]
1058:../Generated_Code/UTIL1.c ****   if (val == 0 && dstSize > 0){
 1742              		.loc 1 1058 0
 1743 0012 9742     		cmp	r7, r2
 1744 0014 04D0     		beq	.L146
1059:../Generated_Code/UTIL1.c ****     ptr[i++] = '0';
 1745              		.loc 1 1059 0
 1746 0016 3023     		mov	r3, #48
 1747 0018 0370     		strb	r3, [r0]
 1748              	.LVL228:
 1749 001a 0120     		mov	r0, #1
 1750              	.LVL229:
1060:../Generated_Code/UTIL1.c ****     dstSize--;
 1751              		.loc 1 1060 0
 1752 001c 8F1E     		sub	r7, r1, #2
 1753              	.LVL230:
1059:../Generated_Code/UTIL1.c ****     ptr[i++] = '0';
 1754              		.loc 1 1059 0
 1755 001e 0190     		str	r0, [sp, #4]
 1756              	.LVL231:
 1757              	.L146:
1054:../Generated_Code/UTIL1.c ****   unsigned char i=0, j;
 1758              		.loc 1 1054 0
 1759 0020 3E1C     		mov	r6, r7
 1760              	.LVL232:
 1761              	.L147:
1051:../Generated_Code/UTIL1.c **** void UTIL1_Num32uToStr(byte *dst, size_t dstSize, dword val)
 1762              		.loc 1 1051 0
 1763 0022 0199     		ldr	r1, [sp, #4]
 1764 0024 CA19     		add	r2, r1, r7
 1765 0026 931B     		sub	r3, r2, r6
 1766 0028 D8B2     		uxtb	r0, r3
 1767 002a 0090     		str	r0, [sp]
 1768              	.LVL233:
1062:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 1769              		.loc 1 1062 0
 1770 002c 002D     		cmp	r5, #0
 1771 002e 06D1     		bne	.L148
 1772              	.L151:
1067:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 1773              		.loc 1 1067 0
 1774 0030 009D     		ldr	r5, [sp]
 1775              	.LVL234:
1051:../Generated_Code/UTIL1.c **** void UTIL1_Num32uToStr(byte *dst, size_t dstSize, dword val)
 1776              		.loc 1 1051 0
 1777 0032 231C     		mov	r3, r4
 1778 0034 2E1C     		mov	r6, r5
 1779              	.LVL235:
 1780 0036 013E     		sub	r6, r6, #1
1067:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 1781              		.loc 1 1067 0
 1782 0038 6908     		lsr	r1, r5, #1
1051:../Generated_Code/UTIL1.c **** void UTIL1_Num32uToStr(byte *dst, size_t dstSize, dword val)
 1783              		.loc 1 1051 0
 1784 003a A619     		add	r6, r4, r6
 1785 003c 0FE0     		b	.L149
 1786              	.LVL236:
 1787              	.L148:
1062:../Generated_Code/UTIL1.c ****   while (val > 0 && dstSize > 0) {
 1788              		.loc 1 1062 0
 1789 003e 002E     		cmp	r6, #0
 1790 0040 F6D0     		beq	.L151
 1791              	.L150:
1063:../Generated_Code/UTIL1.c ****     ptr[i++] = (unsigned char)((val % 10) + '0');
 1792              		.loc 1 1063 0
 1793 0042 281C     		mov	r0, r5
 1794 0044 0A21     		mov	r1, #10
 1795 0046 FFF7FEFF 		bl	__aeabi_uidivmod
 1796              	.LVL237:
 1797 004a 0098     		ldr	r0, [sp]
 1798 004c 3031     		add	r1, r1, #48
 1799 004e 2154     		strb	r1, [r4, r0]
 1800              	.LVL238:
1065:../Generated_Code/UTIL1.c ****     val /= 10;
 1801              		.loc 1 1065 0
 1802 0050 281C     		mov	r0, r5
 1803              	.LVL239:
 1804 0052 0A21     		mov	r1, #10
 1805 0054 FFF7FEFF 		bl	__aeabi_uidiv
 1806              	.LVL240:
1064:../Generated_Code/UTIL1.c ****     dstSize--;
 1807              		.loc 1 1064 0
 1808 0058 013E     		sub	r6, r6, #1
 1809              	.LVL241:
1065:../Generated_Code/UTIL1.c ****     val /= 10;
 1810              		.loc 1 1065 0
 1811 005a 051C     		mov	r5, r0
 1812              	.LVL242:
 1813 005c E1E7     		b	.L147
 1814              	.LVL243:
 1815              	.L149:
1067:../Generated_Code/UTIL1.c ****   for(j=0; j<(i/2); j++) { /* swap buffer */
 1816              		.loc 1 1067 0
 1817 005e 1F1B     		sub	r7, r3, r4
 1818 0060 F8B2     		uxtb	r0, r7
 1819 0062 8842     		cmp	r0, r1
 1820 0064 06D2     		bcs	.L156
 1821              	.L152:
1068:../Generated_Code/UTIL1.c ****     tmp = ptr[j];
 1822              		.loc 1 1068 0
 1823 0066 1F78     		ldrb	r7, [r3]
 1824              	.LVL244:
1069:../Generated_Code/UTIL1.c ****     ptr[j] = ptr[(i-j)-1];
 1825              		.loc 1 1069 0
 1826 0068 3578     		ldrb	r5, [r6]
 1827 006a 1D70     		strb	r5, [r3]
1070:../Generated_Code/UTIL1.c ****     ptr[(i-j)-1] = tmp;
 1828              		.loc 1 1070 0
 1829 006c 3770     		strb	r7, [r6]
 1830 006e 0133     		add	r3, r3, #1
 1831              	.LVL245:
 1832 0070 013E     		sub	r6, r6, #1
 1833 0072 F4E7     		b	.L149
 1834              	.LVL246:
 1835              	.L156:
1072:../Generated_Code/UTIL1.c ****   ptr[i] = '\0';
 1836              		.loc 1 1072 0
 1837 0074 009A     		ldr	r2, [sp]
 1838 0076 0021     		mov	r1, #0
 1839 0078 A154     		strb	r1, [r4, r2]
1073:../Generated_Code/UTIL1.c **** }
 1840              		.loc 1 1073 0
 1841              		@ sp needed for prologue
 1842              	.LVL247:
 1843 007a F7BD     		pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 1844              		.cfi_endproc
 1845              	.LFE27:
 1847              		.section	.text.UTIL1_strcatNum32u,"ax",%progbits
 1848              		.align	1
 1849              		.global	UTIL1_strcatNum32u
 1850              		.code	16
 1851              		.thumb_func
 1853              	UTIL1_strcatNum32u:
 1854              	.LFB25:
 972:../Generated_Code/UTIL1.c **** {
 1855              		.loc 1 972 0
 1856              		.cfi_startproc
 1857              	.LVL248:
 1858 0000 30B5     		push	{r4, r5, lr}
 1859              	.LCFI34:
 1860              		.cfi_def_cfa_offset 12
 1861              		.cfi_offset 4, -12
 1862              		.cfi_offset 5, -8
 1863              		.cfi_offset 14, -4
 1864 0002 85B0     		sub	sp, sp, #20
 1865              	.LCFI35:
 1866              		.cfi_def_cfa_offset 32
 972:../Generated_Code/UTIL1.c **** {
 1867              		.loc 1 972 0
 1868 0004 051C     		mov	r5, r0
 1869 0006 0C1C     		mov	r4, r1
 975:../Generated_Code/UTIL1.c ****   UTIL1_Num32uToStr(buf, sizeof(buf), val);
 1870              		.loc 1 975 0
 1871 0008 01A8     		add	r0, sp, #4
 1872              	.LVL249:
 1873 000a 0B21     		mov	r1, #11
 1874              	.LVL250:
 1875 000c FFF7FEFF 		bl	UTIL1_Num32uToStr
 1876              	.LVL251:
 976:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1877              		.loc 1 976 0
 1878 0010 281C     		mov	r0, r5
 1879 0012 211C     		mov	r1, r4
 1880 0014 01AA     		add	r2, sp, #4
 1881 0016 FFF7FEFF 		bl	UTIL1_strcat
 1882              	.LVL252:
 977:../Generated_Code/UTIL1.c **** }
 1883              		.loc 1 977 0
 1884 001a 05B0     		add	sp, sp, #20
 1885              		@ sp needed for prologue
 1886              	.LVL253:
 1887              	.LVL254:
 1888 001c 30BD     		pop	{r4, r5, pc}
 1889              		.cfi_endproc
 1890              	.LFE25:
 1892              		.section	.text.UTIL1_Num32uToStrFormatted,"ax",%progbits
 1893              		.align	1
 1894              		.global	UTIL1_Num32uToStrFormatted
 1895              		.code	16
 1896              		.thumb_func
 1898              	UTIL1_Num32uToStrFormatted:
 1899              	.LFB10:
 469:../Generated_Code/UTIL1.c **** {
 1900              		.loc 1 469 0
 1901              		.cfi_startproc
 1902              	.LVL255:
 1903 0000 70B5     		push	{r4, r5, r6, lr}
 1904              	.LCFI36:
 1905              		.cfi_def_cfa_offset 16
 1906              		.cfi_offset 4, -16
 1907              		.cfi_offset 5, -12
 1908              		.cfi_offset 6, -8
 1909              		.cfi_offset 14, -4
 469:../Generated_Code/UTIL1.c **** {
 1910              		.loc 1 469 0
 1911 0002 1E1C     		mov	r6, r3
 1912 0004 04AB     		add	r3, sp, #16
 1913              	.LVL256:
 1914 0006 1D78     		ldrb	r5, [r3]
 1915 0008 041C     		mov	r4, r0
 470:../Generated_Code/UTIL1.c ****   UTIL1_Num32uToStr(dst, dstSize, val);
 1916              		.loc 1 470 0
 1917 000a FFF7FEFF 		bl	UTIL1_Num32uToStr
 1918              	.LVL257:
 471:../Generated_Code/UTIL1.c ****   ShiftRightAndFill(dst, fill, nofFill);
 1919              		.loc 1 471 0
 1920 000e 311C     		mov	r1, r6
 1921 0010 2A1C     		mov	r2, r5
 1922 0012 201C     		mov	r0, r4
 1923 0014 FFF7FEFF 		bl	ShiftRightAndFill
 1924              	.LVL258:
 472:../Generated_Code/UTIL1.c **** }
 1925              		.loc 1 472 0
 1926              		@ sp needed for prologue
 1927              	.LVL259:
 1928 0018 70BD     		pop	{r4, r5, r6, pc}
 1929              		.cfi_endproc
 1930              	.LFE10:
 1932              		.section	.text.UTIL1_strcatNum32uFormatted,"ax",%progbits
 1933              		.align	1
 1934              		.global	UTIL1_strcatNum32uFormatted
 1935              		.code	16
 1936              		.thumb_func
 1938              	UTIL1_strcatNum32uFormatted:
 1939              	.LFB18:
 728:../Generated_Code/UTIL1.c **** {
 1940              		.loc 1 728 0
 1941              		.cfi_startproc
 1942              	.LVL260:
 1943 0000 30B5     		push	{r4, r5, lr}
 1944              	.LCFI37:
 1945              		.cfi_def_cfa_offset 12
 1946              		.cfi_offset 4, -12
 1947              		.cfi_offset 5, -8
 1948              		.cfi_offset 14, -4
 1949 0002 87B0     		sub	sp, sp, #28
 1950              	.LCFI38:
 1951              		.cfi_def_cfa_offset 40
 728:../Generated_Code/UTIL1.c **** {
 1952              		.loc 1 728 0
 1953 0004 0C1C     		mov	r4, r1
 1954 0006 0AA9     		add	r1, sp, #40
 1955              	.LVL261:
 1956 0008 051C     		mov	r5, r0
 1957 000a 0878     		ldrb	r0, [r1]
 1958              	.LVL262:
 731:../Generated_Code/UTIL1.c ****   UTIL1_Num32uToStrFormatted(buf, dstSize, val, fill, nofFill);
 1959              		.loc 1 731 0
 1960 000c 211C     		mov	r1, r4
 1961 000e 0090     		str	r0, [sp]
 1962 0010 03A8     		add	r0, sp, #12
 1963 0012 FFF7FEFF 		bl	UTIL1_Num32uToStrFormatted
 1964              	.LVL263:
 732:../Generated_Code/UTIL1.c ****   UTIL1_strcat(dst, dstSize, buf);
 1965              		.loc 1 732 0
 1966 0016 281C     		mov	r0, r5
 1967 0018 211C     		mov	r1, r4
 1968 001a 03AA     		add	r2, sp, #12
 1969 001c FFF7FEFF 		bl	UTIL1_strcat
 1970              	.LVL264:
 733:../Generated_Code/UTIL1.c **** }
 1971              		.loc 1 733 0
 1972 0020 07B0     		add	sp, sp, #28
 1973              		@ sp needed for prologue
 1974              	.LVL265:
 1975              	.LVL266:
 1976 0022 30BD     		pop	{r4, r5, pc}
 1977              		.cfi_endproc
 1978              	.LFE18:
 1980              		.section	.text.UTIL1_IsLeapYear,"ax",%progbits
 1981              		.align	1
 1982              		.global	UTIL1_IsLeapYear
 1983              		.code	16
 1984              		.thumb_func
 1986              	UTIL1_IsLeapYear:
 1987              	.LFB28:
1088:../Generated_Code/UTIL1.c **** {
 1988              		.loc 1 1088 0
 1989              		.cfi_startproc
 1990              	.LVL267:
 1991 0000 10B5     		push	{r4, lr}
 1992              	.LCFI39:
 1993              		.cfi_def_cfa_offset 8
 1994              		.cfi_offset 4, -8
 1995              		.cfi_offset 14, -4
1088:../Generated_Code/UTIL1.c **** {
 1996              		.loc 1 1088 0
 1997 0002 041C     		mov	r4, r0
1089:../Generated_Code/UTIL1.c ****   return ((((year%4)==0) && (year%100)!=0) || (year%400)==0);
 1998              		.loc 1 1089 0
 1999 0004 8307     		lsl	r3, r0, #30
 2000 0006 06D1     		bne	.L161
1089:../Generated_Code/UTIL1.c ****   return ((((year%4)==0) && (year%100)!=0) || (year%400)==0);
 2001              		.loc 1 1089 0 is_stmt 0
 2002 0008 6421     		mov	r1, #100
 2003 000a FFF7FEFF 		bl	__aeabi_uidivmod
 2004              	.LVL268:
 2005 000e 89B2     		uxth	r1, r1
 2006 0010 0120     		mov	r0, #1
 2007 0012 0029     		cmp	r1, #0
 2008 0014 07D1     		bne	.L162
 2009              	.L161:
1089:../Generated_Code/UTIL1.c ****   return ((((year%4)==0) && (year%100)!=0) || (year%400)==0);
 2010              		.loc 1 1089 0
 2011 0016 C822     		mov	r2, #200
 2012 0018 201C     		mov	r0, r4
 2013 001a 5100     		lsl	r1, r2, #1
 2014 001c FFF7FEFF 		bl	__aeabi_uidivmod
 2015              	.LVL269:
 2016 0020 88B2     		uxth	r0, r1
 2017 0022 4342     		neg	r3, r0
 2018 0024 5841     		adc	r0, r0, r3
 2019              	.L162:
1090:../Generated_Code/UTIL1.c **** }
 2020              		.loc 1 1090 0 is_stmt 1
 2021              		@ sp needed for prologue
 2022 0026 10BD     		pop	{r4, pc}
 2023              		.cfi_endproc
 2024              	.LFE28:
 2026              		.section	.text.UTIL1_WeekDay,"ax",%progbits
 2027              		.align	1
 2028              		.global	UTIL1_WeekDay
 2029              		.code	16
 2030              		.thumb_func
 2032              	UTIL1_WeekDay:
 2033              	.LFB29:
1109:../Generated_Code/UTIL1.c **** {
 2034              		.loc 1 1109 0
 2035              		.cfi_startproc
 2036              	.LVL270:
 2037 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2038              	.LCFI40:
 2039              		.cfi_def_cfa_offset 24
 2040              		.cfi_offset 3, -24
 2041              		.cfi_offset 4, -20
 2042              		.cfi_offset 5, -16
 2043              		.cfi_offset 6, -12
 2044              		.cfi_offset 7, -8
 2045              		.cfi_offset 14, -4
1109:../Generated_Code/UTIL1.c **** {
 2046              		.loc 1 1109 0
 2047 0002 171C     		mov	r7, r2
1114:../Generated_Code/UTIL1.c ****   sum = (word)(year-1900);
 2048              		.loc 1 1114 0
 2049 0004 124A     		ldr	r2, .L169
 2050              	.LVL271:
1109:../Generated_Code/UTIL1.c **** {
 2051              		.loc 1 1109 0
 2052 0006 0D1C     		mov	r5, r1
1114:../Generated_Code/UTIL1.c ****   sum = (word)(year-1900);
 2053              		.loc 1 1114 0
 2054 0008 8318     		add	r3, r0, r2
 2055 000a 99B2     		uxth	r1, r3
 2056              	.LVL272:
1109:../Generated_Code/UTIL1.c **** {
 2057              		.loc 1 1109 0
 2058 000c 061C     		mov	r6, r0
1115:../Generated_Code/UTIL1.c ****   sum += sum/4;
 2059              		.loc 1 1115 0
 2060 000e 8808     		lsr	r0, r1, #2
 2061              	.LVL273:
 2062 0010 4418     		add	r4, r0, r1
 2063 0012 A0B2     		uxth	r0, r4
 2064              	.LVL274:
1116:../Generated_Code/UTIL1.c ****   sum %= 7;
 2065              		.loc 1 1116 0
 2066 0014 0721     		mov	r1, #7
 2067 0016 FFF7FEFF 		bl	__aeabi_uidivmod
 2068              	.LVL275:
1117:../Generated_Code/UTIL1.c ****   if (UTIL1_IsLeapYear(year) && (month==1 || month==2)) {
 2069              		.loc 1 1117 0
 2070 001a 301C     		mov	r0, r6
1116:../Generated_Code/UTIL1.c ****   sum %= 7;
 2071              		.loc 1 1116 0
 2072 001c 8CB2     		uxth	r4, r1
 2073              	.LVL276:
1117:../Generated_Code/UTIL1.c ****   if (UTIL1_IsLeapYear(year) && (month==1 || month==2)) {
 2074              		.loc 1 1117 0
 2075 001e FFF7FEFF 		bl	UTIL1_IsLeapYear
 2076              	.LVL277:
 2077 0022 0028     		cmp	r0, #0
 2078 0024 04D0     		beq	.L165
1117:../Generated_Code/UTIL1.c ****   if (UTIL1_IsLeapYear(year) && (month==1 || month==2)) {
 2079              		.loc 1 1117 0 is_stmt 0
 2080 0026 6E1E     		sub	r6, r5, #1
 2081 0028 012E     		cmp	r6, #1
 2082 002a 01D8     		bhi	.L165
1118:../Generated_Code/UTIL1.c ****     sum--;
 2083              		.loc 1 1118 0 is_stmt 1
 2084 002c 013C     		sub	r4, r4, #1
 2085              	.LVL278:
 2086 002e A4B2     		uxth	r4, r4
 2087              	.LVL279:
 2088              	.L165:
1120:../Generated_Code/UTIL1.c ****   sum += day;
 2089              		.loc 1 1120 0
 2090 0030 E719     		add	r7, r4, r7
 2091 0032 B8B2     		uxth	r0, r7
 2092              	.LVL280:
1121:../Generated_Code/UTIL1.c ****   sum %= 7;
 2093              		.loc 1 1121 0
 2094 0034 0721     		mov	r1, #7
 2095 0036 FFF7FEFF 		bl	__aeabi_uidivmod
 2096              	.LVL281:
1122:../Generated_Code/UTIL1.c ****   sum += skew[month-1];
 2097              		.loc 1 1122 0
 2098 003a 064A     		ldr	r2, .L169+4
1125:../Generated_Code/UTIL1.c **** }
 2099              		.loc 1 1125 0
 2100              		@ sp needed for prologue
1122:../Generated_Code/UTIL1.c ****   sum += skew[month-1];
 2101              		.loc 1 1122 0
 2102 003c 5519     		add	r5, r2, r5
 2103 003e 013D     		sub	r5, r5, #1
 2104 0040 2B78     		ldrb	r3, [r5]
 2105 0042 C918     		add	r1, r1, r3
 2106              	.LVL282:
 2107 0044 88B2     		uxth	r0, r1
 2108              	.LVL283:
1123:../Generated_Code/UTIL1.c ****   sum %= 7;
 2109              		.loc 1 1123 0
 2110 0046 0721     		mov	r1, #7
 2111 0048 FFF7FEFF 		bl	__aeabi_uidivmod
 2112              	.LVL284:
1124:../Generated_Code/UTIL1.c ****   return (byte)sum; /* 0: Sunday, 1: Monday, 2: Tuesday, 3: Wednesday, ... */
 2113              		.loc 1 1124 0
 2114 004c C8B2     		uxtb	r0, r1
1125:../Generated_Code/UTIL1.c **** }
 2115              		.loc 1 1125 0
 2116 004e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2117              	.L170:
 2118              		.align	2
 2119              	.L169:
 2120 0050 94F8FFFF 		.word	-1900
 2121 0054 00000000 		.word	.LANCHOR0
 2122              		.cfi_endproc
 2123              	.LFE29:
 2125              		.section	.text.UTIL1_ReadEscapedName,"ax",%progbits
 2126              		.align	1
 2127              		.global	UTIL1_ReadEscapedName
 2128              		.code	16
 2129              		.thumb_func
 2131              	UTIL1_ReadEscapedName:
 2132              	.LFB30:
1158:../Generated_Code/UTIL1.c **** {
 2133              		.loc 1 1158 0
 2134              		.cfi_startproc
 2135              	.LVL285:
 2136 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2137              	.LCFI41:
 2138              		.cfi_def_cfa_offset 20
 2139              		.cfi_offset 4, -20
 2140              		.cfi_offset 5, -16
 2141              		.cfi_offset 6, -12
 2142              		.cfi_offset 7, -8
 2143              		.cfi_offset 14, -4
 2144 0002 85B0     		sub	sp, sp, #20
 2145              	.LCFI42:
 2146              		.cfi_def_cfa_offset 40
1158:../Generated_Code/UTIL1.c **** {
 2147              		.loc 1 1158 0
 2148 0004 051C     		mov	r5, r0
 2149 0006 0E1C     		mov	r6, r1
 2150 0008 0292     		str	r2, [sp, #8]
 2151 000a 0393     		str	r3, [sp, #12]
1165:../Generated_Code/UTIL1.c ****   if (filename==NULL || (destname!=NULL && maxlen<=0)) {
 2152              		.loc 1 1165 0
 2153 000c 0028     		cmp	r0, #0
 2154 000e 5CD0     		beq	.L185
1165:../Generated_Code/UTIL1.c ****   if (filename==NULL || (destname!=NULL && maxlen<=0)) {
 2155              		.loc 1 1165 0 is_stmt 0
 2156 0010 0029     		cmp	r1, #0
 2157 0012 02D0     		beq	.L173
1166:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 2158              		.loc 1 1166 0 is_stmt 1
 2159 0014 1B20     		mov	r0, #27
 2160              	.LVL286:
1165:../Generated_Code/UTIL1.c ****   if (filename==NULL || (destname!=NULL && maxlen<=0)) {
 2161              		.loc 1 1165 0
 2162 0016 002A     		cmp	r2, #0
 2163 0018 58D0     		beq	.L172
 2164              	.L173:
1168:../Generated_Code/UTIL1.c ****   if (filename[0] == '"') { /* translated mode */
 2165              		.loc 1 1168 0
 2166 001a 2B78     		ldrb	r3, [r5]
 2167              	.LVL287:
1160:../Generated_Code/UTIL1.c ****   bool quoteMode = FALSE;  /* quoteMode means the name is surrounded by ". In this mode, only a sec
 2168              		.loc 1 1160 0
 2169 001c 0024     		mov	r4, #0
1168:../Generated_Code/UTIL1.c ****   if (filename[0] == '"') { /* translated mode */
 2170              		.loc 1 1168 0
 2171 001e 222B     		cmp	r3, #34
 2172 0020 01D1     		bne	.L215
1169:../Generated_Code/UTIL1.c ****     filename++; /* overread '"' */
 2173              		.loc 1 1169 0
 2174 0022 0135     		add	r5, r5, #1
 2175              	.LVL288:
1171:../Generated_Code/UTIL1.c ****     quoteMode=TRUE;
 2176              		.loc 1 1171 0
 2177 0024 0124     		mov	r4, #1
 2178              	.LVL289:
 2179              	.L215:
1173:../Generated_Code/UTIL1.c ****   if (terminators == NULL) {
 2180              		.loc 1 1173 0
 2181 0026 0B9A     		ldr	r2, [sp, #44]
 2182              	.LVL290:
1159:../Generated_Code/UTIL1.c ****   size_t lenCopied = 0, lenOverread = 0;
 2183              		.loc 1 1159 0
 2184 0028 0194     		str	r4, [sp, #4]
 2185              	.LVL291:
1173:../Generated_Code/UTIL1.c ****   if (terminators == NULL) {
 2186              		.loc 1 1173 0
 2187 002a 002A     		cmp	r2, #0
 2188 002c 01D1     		bne	.L175
1174:../Generated_Code/UTIL1.c ****     terminators = "";
 2189              		.loc 1 1174 0
 2190 002e 2848     		ldr	r0, .L217
 2191 0030 0B90     		str	r0, [sp, #44]
 2192              	.L175:
 2193 0032 0027     		mov	r7, #0
 2194              	.LVL292:
 2195              	.L182:
 2196 0034 2978     		ldrb	r1, [r5]
1177:../Generated_Code/UTIL1.c ****     if (quoteMode) {
 2197              		.loc 1 1177 0
 2198 0036 002C     		cmp	r4, #0
 2199 0038 0DD0     		beq	.L176
1178:../Generated_Code/UTIL1.c ****       if (filename[0] == '"') {
 2200              		.loc 1 1178 0
 2201 003a 2229     		cmp	r1, #34
 2202 003c 07D1     		bne	.L177
1180:../Generated_Code/UTIL1.c ****         lenOverread++;
 2203              		.loc 1 1180 0
 2204 003e 019B     		ldr	r3, [sp, #4]
1179:../Generated_Code/UTIL1.c ****         filename++; /* overread '"' */
 2205              		.loc 1 1179 0
 2206 0040 691C     		add	r1, r5, #1
 2207              	.LVL293:
1181:../Generated_Code/UTIL1.c ****         if (filename[0] != '"') { /* quoteMode is terminated by a single quote. A double quote is t
 2208              		.loc 1 1181 0
 2209 0042 6D78     		ldrb	r5, [r5, #1]
1180:../Generated_Code/UTIL1.c ****         lenOverread++;
 2210              		.loc 1 1180 0
 2211 0044 0133     		add	r3, r3, #1
 2212 0046 0193     		str	r3, [sp, #4]
 2213              	.LVL294:
1181:../Generated_Code/UTIL1.c ****         if (filename[0] != '"') { /* quoteMode is terminated by a single quote. A double quote is t
 2214              		.loc 1 1181 0
 2215 0048 222D     		cmp	r5, #34
 2216 004a 27D1     		bne	.L189
1179:../Generated_Code/UTIL1.c ****         filename++; /* overread '"' */
 2217              		.loc 1 1179 0
 2218 004c 0D1C     		mov	r5, r1
 2219              	.LVL295:
 2220              	.L177:
1185:../Generated_Code/UTIL1.c ****       if (filename[0] == '\0') { /* unexpected 0. stop */
 2221              		.loc 1 1185 0
 2222 004e 2A78     		ldrb	r2, [r5]
 2223 0050 002A     		cmp	r2, #0
 2224 0052 13D1     		bne	.L179
 2225 0054 24E0     		b	.L216
 2226              	.L176:
1190:../Generated_Code/UTIL1.c ****       if (IS_SPACE(filename[0]) || filename[0] == '\0' || strchr(terminators, filename[0]) != NULL)
 2227              		.loc 1 1190 0
 2228 0056 2029     		cmp	r1, #32
 2229 0058 24D0     		beq	.L198
1190:../Generated_Code/UTIL1.c ****       if (IS_SPACE(filename[0]) || filename[0] == '\0' || strchr(terminators, filename[0]) != NULL)
 2230              		.loc 1 1190 0 is_stmt 0
 2231 005a 0929     		cmp	r1, #9
 2232 005c 22D0     		beq	.L198
 2233 005e 0A29     		cmp	r1, #10
 2234 0060 20D0     		beq	.L198
1190:../Generated_Code/UTIL1.c ****       if (IS_SPACE(filename[0]) || filename[0] == '\0' || strchr(terminators, filename[0]) != NULL)
 2235              		.loc 1 1190 0
 2236 0062 0B29     		cmp	r1, #11
 2237 0064 1ED0     		beq	.L198
1190:../Generated_Code/UTIL1.c ****       if (IS_SPACE(filename[0]) || filename[0] == '\0' || strchr(terminators, filename[0]) != NULL)
 2238              		.loc 1 1190 0
 2239 0066 0C29     		cmp	r1, #12
 2240 0068 1CD0     		beq	.L198
1190:../Generated_Code/UTIL1.c ****       if (IS_SPACE(filename[0]) || filename[0] == '\0' || strchr(terminators, filename[0]) != NULL)
 2241              		.loc 1 1190 0
 2242 006a 0D29     		cmp	r1, #13
 2243 006c 1AD0     		beq	.L198
1190:../Generated_Code/UTIL1.c ****       if (IS_SPACE(filename[0]) || filename[0] == '\0' || strchr(terminators, filename[0]) != NULL)
 2244              		.loc 1 1190 0
 2245 006e 0029     		cmp	r1, #0
 2246 0070 18D0     		beq	.L198
1190:../Generated_Code/UTIL1.c ****       if (IS_SPACE(filename[0]) || filename[0] == '\0' || strchr(terminators, filename[0]) != NULL)
 2247              		.loc 1 1190 0
 2248 0072 0B98     		ldr	r0, [sp, #44]
 2249 0074 FFF7FEFF 		bl	strchr
 2250              	.LVL296:
 2251 0078 0028     		cmp	r0, #0
 2252 007a 13D1     		bne	.L198
 2253              	.L179:
1194:../Generated_Code/UTIL1.c ****     if (destname != NULL) {
 2254              		.loc 1 1194 0 is_stmt 1
 2255 007c 002E     		cmp	r6, #0
 2256 007e 0AD0     		beq	.L180
1195:../Generated_Code/UTIL1.c ****       if (lenCopied + 1 < maxlen) {
 2257              		.loc 1 1195 0
 2258 0080 0299     		ldr	r1, [sp, #8]
 2259 0082 781C     		add	r0, r7, #1
 2260 0084 8842     		cmp	r0, r1
 2261 0086 03D2     		bcs	.L181
1196:../Generated_Code/UTIL1.c ****         destname[0] = filename[0];
 2262              		.loc 1 1196 0
 2263 0088 2A78     		ldrb	r2, [r5]
 2264 008a 3270     		strb	r2, [r6]
1197:../Generated_Code/UTIL1.c ****         destname++;
 2265              		.loc 1 1197 0
 2266 008c 0136     		add	r6, r6, #1
 2267              	.LVL297:
 2268 008e 02E0     		b	.L180
 2269              	.L181:
1199:../Generated_Code/UTIL1.c ****         destname[0] = '\0'; /* terminate string */
 2270              		.loc 1 1199 0
 2271 0090 0023     		mov	r3, #0
 2272 0092 3370     		strb	r3, [r6]
 2273              	.LVL298:
1200:../Generated_Code/UTIL1.c ****         destname = NULL; /* avoid it to overwrite not allocated space */
 2274              		.loc 1 1200 0
 2275 0094 1E1C     		mov	r6, r3
 2276              	.LVL299:
 2277              	.L180:
1203:../Generated_Code/UTIL1.c ****     lenCopied++;
 2278              		.loc 1 1203 0
 2279 0096 0137     		add	r7, r7, #1
 2280              	.LVL300:
1204:../Generated_Code/UTIL1.c ****     filename++;
 2281              		.loc 1 1204 0
 2282 0098 0135     		add	r5, r5, #1
 2283              	.LVL301:
1205:../Generated_Code/UTIL1.c ****   }
 2284              		.loc 1 1205 0
 2285 009a CBE7     		b	.L182
 2286              	.LVL302:
 2287              	.L189:
1162:../Generated_Code/UTIL1.c ****   bool res = ERR_OK;
 2288              		.loc 1 1162 0
 2289 009c 0020     		mov	r0, #0
 2290 009e 02E0     		b	.L178
 2291              	.LVL303:
 2292              	.L216:
1186:../Generated_Code/UTIL1.c ****         res = ERR_FAILED;
 2293              		.loc 1 1186 0
 2294 00a0 1B20     		mov	r0, #27
 2295 00a2 00E0     		b	.L178
 2296              	.L198:
1162:../Generated_Code/UTIL1.c ****   bool res = ERR_OK;
 2297              		.loc 1 1162 0
 2298 00a4 201C     		mov	r0, r4
 2299              	.LVL304:
 2300              	.L178:
1206:../Generated_Code/UTIL1.c ****   if (destname != NULL) {
 2301              		.loc 1 1206 0
 2302 00a6 002E     		cmp	r6, #0
 2303 00a8 01D0     		beq	.L183
1207:../Generated_Code/UTIL1.c ****     destname[0] = '\0';
 2304              		.loc 1 1207 0
 2305 00aa 0024     		mov	r4, #0
 2306              	.LVL305:
 2307 00ac 3470     		strb	r4, [r6]
 2308              	.L183:
1209:../Generated_Code/UTIL1.c ****   if (lenRead != NULL) {
 2309              		.loc 1 1209 0
 2310 00ae 039D     		ldr	r5, [sp, #12]
 2311 00b0 002D     		cmp	r5, #0
 2312 00b2 03D0     		beq	.L184
1210:../Generated_Code/UTIL1.c ****     *lenRead = lenCopied+lenOverread;
 2313              		.loc 1 1210 0
 2314 00b4 0199     		ldr	r1, [sp, #4]
 2315 00b6 039E     		ldr	r6, [sp, #12]
 2316              	.LVL306:
 2317 00b8 7B18     		add	r3, r7, r1
 2318 00ba 3360     		str	r3, [r6]
 2319              	.L184:
1212:../Generated_Code/UTIL1.c ****   if (lenWritten != NULL) {
 2320              		.loc 1 1212 0
 2321 00bc 0A9A     		ldr	r2, [sp, #40]
 2322 00be 002A     		cmp	r2, #0
 2323 00c0 04D0     		beq	.L172
1213:../Generated_Code/UTIL1.c ****     *lenWritten = lenCopied + 1; /* additionally a zero byte written */
 2324              		.loc 1 1213 0
 2325 00c2 0A9C     		ldr	r4, [sp, #40]
 2326 00c4 0137     		add	r7, r7, #1
 2327              	.LVL307:
 2328 00c6 2760     		str	r7, [r4]
 2329 00c8 00E0     		b	.L172
 2330              	.LVL308:
 2331              	.L185:
1166:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 2332              		.loc 1 1166 0
 2333 00ca 1B20     		mov	r0, #27
 2334              	.LVL309:
 2335              	.L172:
1216:../Generated_Code/UTIL1.c **** }
 2336              		.loc 1 1216 0
 2337 00cc 05B0     		add	sp, sp, #20
 2338              		@ sp needed for prologue
 2339 00ce F0BD     		pop	{r4, r5, r6, r7, pc}
 2340              	.L218:
 2341              		.align	2
 2342              	.L217:
 2343 00d0 00000000 		.word	.LC3
 2344              		.cfi_endproc
 2345              	.LFE30:
 2347              		.section	.text.UTIL1_xatoi,"ax",%progbits
 2348              		.align	1
 2349              		.global	UTIL1_xatoi
 2350              		.code	16
 2351              		.thumb_func
 2353              	UTIL1_xatoi:
 2354              	.LFB31:
1248:../Generated_Code/UTIL1.c **** {
 2355              		.loc 1 1248 0
 2356              		.cfi_startproc
 2357              	.LVL310:
 2358 0000 70B5     		push	{r4, r5, r6, lr}
 2359              	.LCFI43:
 2360              		.cfi_def_cfa_offset 16
 2361              		.cfi_offset 4, -16
 2362              		.cfi_offset 5, -12
 2363              		.cfi_offset 6, -8
 2364              		.cfi_offset 14, -4
1262:../Generated_Code/UTIL1.c ****   *res = 0;
 2365              		.loc 1 1262 0
 2366 0002 0023     		mov	r3, #0
1248:../Generated_Code/UTIL1.c **** {
 2367              		.loc 1 1248 0
 2368 0004 021C     		mov	r2, r0
1262:../Generated_Code/UTIL1.c ****   *res = 0;
 2369              		.loc 1 1262 0
 2370 0006 0B60     		str	r3, [r1]
 2371              	.LVL311:
 2372              	.L220:
1263:../Generated_Code/UTIL1.c ****   while (**str==' ') {
 2373              		.loc 1 1263 0
 2374 0008 1068     		ldr	r0, [r2]
 2375 000a 0378     		ldrb	r3, [r0]
 2376 000c 202B     		cmp	r3, #32
 2377 000e 02D1     		bne	.L243
 2378              	.L221:
1264:../Generated_Code/UTIL1.c ****     (*str)++;                          /* Skip leading spaces */
 2379              		.loc 1 1264 0
 2380 0010 0130     		add	r0, r0, #1
 2381 0012 1060     		str	r0, [r2]
 2382 0014 F8E7     		b	.L220
 2383              	.L243:
 2384              	.LVL312:
1260:../Generated_Code/UTIL1.c ****   unsigned char c, r, s = 0;
 2385              		.loc 1 1260 0
 2386 0016 0026     		mov	r6, #0
1267:../Generated_Code/UTIL1.c ****   if (c == '-') {                      /* negative? */
 2387              		.loc 1 1267 0
 2388 0018 2D2B     		cmp	r3, #45
 2389 001a 03D1     		bne	.L222
 2390              	.LVL313:
1269:../Generated_Code/UTIL1.c ****     c = *(++(*str));
 2391              		.loc 1 1269 0
 2392 001c 441C     		add	r4, r0, #1
 2393 001e 1460     		str	r4, [r2]
 2394 0020 4378     		ldrb	r3, [r0, #1]
 2395              	.LVL314:
1268:../Generated_Code/UTIL1.c ****     s = 1;
 2396              		.loc 1 1268 0
 2397 0022 0126     		mov	r6, #1
 2398              	.LVL315:
 2399              	.L222:
1271:../Generated_Code/UTIL1.c ****   if (c == '0') {
 2400              		.loc 1 1271 0
 2401 0024 302B     		cmp	r3, #48
 2402 0026 1CD1     		bne	.L223
1272:../Generated_Code/UTIL1.c ****     c = *(++(*str));
 2403              		.loc 1 1272 0
 2404 0028 1068     		ldr	r0, [r2]
 2405 002a 431C     		add	r3, r0, #1
 2406              	.LVL316:
 2407 002c 1360     		str	r3, [r2]
 2408 002e 4378     		ldrb	r3, [r0, #1]
 2409              	.LVL317:
1273:../Generated_Code/UTIL1.c ****     switch (c) {
 2410              		.loc 1 1273 0
 2411 0030 622B     		cmp	r3, #98
 2412 0032 06D0     		beq	.L225
 2413 0034 782B     		cmp	r3, #120
 2414 0036 09D1     		bne	.L242
 2415              	.LVL318:
1275:../Generated_Code/UTIL1.c ****         r = 16; c = *(++(*str));
 2416              		.loc 1 1275 0
 2417 0038 851C     		add	r5, r0, #2
 2418 003a 1560     		str	r5, [r2]
 2419 003c 8378     		ldrb	r3, [r0, #2]
 2420              	.LVL319:
 2421 003e 1024     		mov	r4, #16
1276:../Generated_Code/UTIL1.c ****         break;
 2422              		.loc 1 1276 0
 2423 0040 16E0     		b	.L227
 2424              	.LVL320:
 2425              	.L225:
1278:../Generated_Code/UTIL1.c ****         r = 2; c = *(++(*str));
 2426              		.loc 1 1278 0
 2427 0042 831C     		add	r3, r0, #2
 2428 0044 1360     		str	r3, [r2]
 2429 0046 8378     		ldrb	r3, [r0, #2]
 2430 0048 0224     		mov	r4, #2
1279:../Generated_Code/UTIL1.c ****         break;
 2431              		.loc 1 1279 0
 2432 004a 11E0     		b	.L227
 2433              	.LVL321:
 2434              	.L242:
1282:../Generated_Code/UTIL1.c ****           return ERR_OK;               /* single zero */
 2435              		.loc 1 1282 0
 2436 004c 0020     		mov	r0, #0
1281:../Generated_Code/UTIL1.c ****         if (c <= ' ' || c == '.') {
 2437              		.loc 1 1281 0
 2438 004e 202B     		cmp	r3, #32
 2439 0050 2FD9     		bls	.L228
1281:../Generated_Code/UTIL1.c ****         if (c <= ' ' || c == '.') {
 2440              		.loc 1 1281 0 is_stmt 0
 2441 0052 2E2B     		cmp	r3, #46
 2442 0054 2DD0     		beq	.L228
1284:../Generated_Code/UTIL1.c ****         if (c < '0' || c > '9') {
 2443              		.loc 1 1284 0 is_stmt 1
 2444 0056 1C1C     		mov	r4, r3
 2445 0058 303C     		sub	r4, r4, #48
 2446 005a 092C     		cmp	r4, #9
 2447 005c 07D9     		bls	.L241
 2448              	.LVL322:
 2449              	.L229:
1285:../Generated_Code/UTIL1.c ****           return ERR_FAILED;           /* invalid char */
 2450              		.loc 1 1285 0
 2451 005e 1B20     		mov	r0, #27
 2452 0060 27E0     		b	.L228
 2453              	.LVL323:
 2454              	.L223:
1291:../Generated_Code/UTIL1.c ****     if (c < '0' || c > '9') {
 2455              		.loc 1 1291 0
 2456 0062 1D1C     		mov	r5, r3
 2457 0064 303D     		sub	r5, r5, #48
1294:../Generated_Code/UTIL1.c ****     r = 10;                            /* decimal */
 2458              		.loc 1 1294 0
 2459 0066 0A24     		mov	r4, #10
1291:../Generated_Code/UTIL1.c ****     if (c < '0' || c > '9') {
 2460              		.loc 1 1291 0
 2461 0068 092D     		cmp	r5, #9
 2462 006a F8D8     		bhi	.L229
 2463 006c 00E0     		b	.L227
 2464              	.LVL324:
 2465              	.L241:
1287:../Generated_Code/UTIL1.c ****         r = 8;                         /* octal */
 2466              		.loc 1 1287 0
 2467 006e 0824     		mov	r4, #8
 2468              	.LVL325:
 2469              	.L227:
1296:../Generated_Code/UTIL1.c ****   val = 0;
 2470              		.loc 1 1296 0
 2471 0070 0020     		mov	r0, #0
 2472              	.LVL326:
 2473              	.L230:
1297:../Generated_Code/UTIL1.c ****   while (c > ' ' && c != '.') {
 2474              		.loc 1 1297 0
 2475 0072 202B     		cmp	r3, #32
 2476 0074 03D8     		bhi	.L233
 2477              	.L237:
1308:../Generated_Code/UTIL1.c ****   if (s) val = 0 - val;                /* apply sign if needed */
 2478              		.loc 1 1308 0
 2479 0076 002E     		cmp	r6, #0
 2480 0078 19D0     		beq	.L235
 2481              	.L234:
1308:../Generated_Code/UTIL1.c ****   if (s) val = 0 - val;                /* apply sign if needed */
 2482              		.loc 1 1308 0 is_stmt 0
 2483 007a 4042     		neg	r0, r0
 2484              	.LVL327:
 2485 007c 17E0     		b	.L235
 2486              	.L233:
1297:../Generated_Code/UTIL1.c ****   while (c > ' ' && c != '.') {
 2487              		.loc 1 1297 0 is_stmt 1
 2488 007e 2E2B     		cmp	r3, #46
 2489 0080 F9D0     		beq	.L237
 2490              	.L236:
1298:../Generated_Code/UTIL1.c ****     if (c >= 'a') c -= 0x20;
 2491              		.loc 1 1298 0
 2492 0082 602B     		cmp	r3, #96
 2493 0084 01D9     		bls	.L231
1298:../Generated_Code/UTIL1.c ****     if (c >= 'a') c -= 0x20;
 2494              		.loc 1 1298 0 is_stmt 0
 2495 0086 203B     		sub	r3, r3, #32
 2496              	.LVL328:
 2497 0088 DBB2     		uxtb	r3, r3
 2498              	.LVL329:
 2499              	.L231:
1299:../Generated_Code/UTIL1.c ****     c -= '0';
 2500              		.loc 1 1299 0 is_stmt 1
 2501 008a 1D1C     		mov	r5, r3
 2502 008c 303D     		sub	r5, r5, #48
 2503 008e EDB2     		uxtb	r5, r5
 2504              	.LVL330:
1300:../Generated_Code/UTIL1.c ****     if (c >= 17) {
 2505              		.loc 1 1300 0
 2506 0090 102D     		cmp	r5, #16
 2507 0092 03D9     		bls	.L232
1301:../Generated_Code/UTIL1.c ****       c -= 7;
 2508              		.loc 1 1301 0
 2509 0094 373B     		sub	r3, r3, #55
 2510 0096 DDB2     		uxtb	r5, r3
 2511              	.LVL331:
1302:../Generated_Code/UTIL1.c ****       if (c <= 9) return ERR_FAILED;   /* invalid char */
 2512              		.loc 1 1302 0
 2513 0098 092D     		cmp	r5, #9
 2514 009a E0D9     		bls	.L229
 2515              	.LVL332:
 2516              	.L232:
1304:../Generated_Code/UTIL1.c ****     if (c >= r) return ERR_FAILED;     /* invalid char for current radix */
 2517              		.loc 1 1304 0
 2518 009c A542     		cmp	r5, r4
 2519 009e DED2     		bcs	.L229
1305:../Generated_Code/UTIL1.c ****     val = val * r + c;
 2520              		.loc 1 1305 0
 2521 00a0 6043     		mul	r0, r4
 2522              	.LVL333:
1306:../Generated_Code/UTIL1.c ****     c = *(++(*str));
 2523              		.loc 1 1306 0
 2524 00a2 1368     		ldr	r3, [r2]
1305:../Generated_Code/UTIL1.c ****     val = val * r + c;
 2525              		.loc 1 1305 0
 2526 00a4 2818     		add	r0, r5, r0
 2527              	.LVL334:
1306:../Generated_Code/UTIL1.c ****     c = *(++(*str));
 2528              		.loc 1 1306 0
 2529 00a6 5D1C     		add	r5, r3, #1
 2530              	.LVL335:
 2531 00a8 1560     		str	r5, [r2]
 2532 00aa 5B78     		ldrb	r3, [r3, #1]
 2533              	.LVL336:
 2534 00ac E1E7     		b	.L230
 2535              	.LVL337:
 2536              	.L235:
1309:../Generated_Code/UTIL1.c ****   *res = (long)val;
 2537              		.loc 1 1309 0
 2538 00ae 0860     		str	r0, [r1]
1310:../Generated_Code/UTIL1.c ****   return ERR_OK;
 2539              		.loc 1 1310 0
 2540 00b0 0020     		mov	r0, #0
 2541              	.LVL338:
 2542              	.L228:
1311:../Generated_Code/UTIL1.c **** }
 2543              		.loc 1 1311 0
 2544              		@ sp needed for prologue
 2545              	.LVL339:
 2546 00b2 70BD     		pop	{r4, r5, r6, pc}
 2547              		.cfi_endproc
 2548              	.LFE31:
 2550              		.section	.text.UTIL1_ScanDecimal16uNumber,"ax",%progbits
 2551              		.align	1
 2552              		.global	UTIL1_ScanDecimal16uNumber
 2553              		.code	16
 2554              		.thumb_func
 2556              	UTIL1_ScanDecimal16uNumber:
 2557              	.LFB34:
1464:../Generated_Code/UTIL1.c **** {
 2558              		.loc 1 1464 0
 2559              		.cfi_startproc
 2560              	.LVL340:
 2561 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2562              	.LCFI44:
 2563              		.cfi_def_cfa_offset 20
 2564              		.cfi_offset 4, -20
 2565              		.cfi_offset 5, -16
 2566              		.cfi_offset 6, -12
 2567              		.cfi_offset 7, -8
 2568              		.cfi_offset 14, -4
1467:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 2569              		.loc 1 1467 0
 2570 0002 0368     		ldr	r3, [r0]
 2571              	.LVL341:
 2572              	.L245:
1469:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 2573              		.loc 1 1469 0
 2574 0004 1A78     		ldrb	r2, [r3]
 2575 0006 202A     		cmp	r2, #32
 2576 0008 01D1     		bne	.L253
 2577              	.L246:
1470:../Generated_Code/UTIL1.c ****     p++;
 2578              		.loc 1 1470 0
 2579 000a 0133     		add	r3, r3, #1
 2580              	.LVL342:
 2581 000c FAE7     		b	.L245
 2582              	.L253:
1472:../Generated_Code/UTIL1.c ****   *val = 0;
 2583              		.loc 1 1472 0
 2584 000e 0024     		mov	r4, #0
1469:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 2585              		.loc 1 1469 0
 2586 0010 1E1C     		mov	r6, r3
1472:../Generated_Code/UTIL1.c ****   *val = 0;
 2587              		.loc 1 1472 0
 2588 0012 0C80     		strh	r4, [r1]
1463:../Generated_Code/UTIL1.c **** byte UTIL1_ScanDecimal16uNumber(const unsigned char **str, word *val)
 2589              		.loc 1 1463 0
 2590 0014 9D1D     		add	r5, r3, #6
 2591              	.LVL343:
 2592              	.L247:
1463:../Generated_Code/UTIL1.c **** byte UTIL1_ScanDecimal16uNumber(const unsigned char **str, word *val)
 2593              		.loc 1 1463 0 is_stmt 0
 2594 0016 B71D     		add	r7, r6, #6
 2595 0018 FA1A     		sub	r2, r7, r3
 2596 001a D4B2     		uxtb	r4, r2
1473:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 2597              		.loc 1 1473 0 is_stmt 1
 2598 001c 1A78     		ldrb	r2, [r3]
 2599 001e 171C     		mov	r7, r2
 2600 0020 303F     		sub	r7, r7, #48
 2601 0022 092F     		cmp	r7, #9
 2602 0024 0BD8     		bhi	.L248
1473:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 2603              		.loc 1 1473 0 is_stmt 0
 2604 0026 AB42     		cmp	r3, r5
 2605 0028 07D0     		beq	.L254
 2606              	.L249:
1474:../Generated_Code/UTIL1.c ****     *val = (uint16_t)((*val)*10 + *p-'0');
 2607              		.loc 1 1474 0 is_stmt 1
 2608 002a 0C88     		ldrh	r4, [r1]
 2609 002c 0A27     		mov	r7, #10
 2610 002e 7C43     		mul	r4, r7
 2611 0030 303C     		sub	r4, r4, #48
 2612 0032 1219     		add	r2, r2, r4
 2613 0034 0A80     		strh	r2, [r1]
1476:../Generated_Code/UTIL1.c ****     p++;
 2614              		.loc 1 1476 0
 2615 0036 0133     		add	r3, r3, #1
 2616              	.LVL344:
 2617 0038 EDE7     		b	.L247
 2618              	.L254:
1479:../Generated_Code/UTIL1.c ****     return ERR_OVERFLOW;
 2619              		.loc 1 1479 0
 2620 003a 0421     		mov	r1, #4
 2621              	.LVL345:
 2622 003c 04E0     		b	.L250
 2623              	.LVL346:
 2624              	.L248:
 2625 003e 0421     		mov	r1, #4
 2626              	.LVL347:
1478:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
 2627              		.loc 1 1478 0
 2628 0040 002C     		cmp	r4, #0
 2629 0042 01D0     		beq	.L250
1481:../Generated_Code/UTIL1.c ****   *str = p;
 2630              		.loc 1 1481 0
 2631 0044 0360     		str	r3, [r0]
1482:../Generated_Code/UTIL1.c ****   return ERR_OK;
 2632              		.loc 1 1482 0
 2633 0046 0021     		mov	r1, #0
 2634              	.L250:
1483:../Generated_Code/UTIL1.c **** }
 2635              		.loc 1 1483 0
 2636 0048 081C     		mov	r0, r1
 2637              	.LVL348:
 2638              		@ sp needed for prologue
 2639 004a F0BD     		pop	{r4, r5, r6, r7, pc}
 2640              		.cfi_endproc
 2641              	.LFE34:
 2643              		.section	.text.UTIL1_ScanDecimal8uNumber,"ax",%progbits
 2644              		.align	1
 2645              		.global	UTIL1_ScanDecimal8uNumber
 2646              		.code	16
 2647              		.thumb_func
 2649              	UTIL1_ScanDecimal8uNumber:
 2650              	.LFB35:
1500:../Generated_Code/UTIL1.c **** {
 2651              		.loc 1 1500 0
 2652              		.cfi_startproc
 2653              	.LVL349:
 2654 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2655              	.LCFI45:
 2656              		.cfi_def_cfa_offset 20
 2657              		.cfi_offset 4, -20
 2658              		.cfi_offset 5, -16
 2659              		.cfi_offset 6, -12
 2660              		.cfi_offset 7, -8
 2661              		.cfi_offset 14, -4
1503:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 2662              		.loc 1 1503 0
 2663 0002 0368     		ldr	r3, [r0]
 2664              	.LVL350:
 2665              	.L256:
1505:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 2666              		.loc 1 1505 0
 2667 0004 1A78     		ldrb	r2, [r3]
 2668 0006 202A     		cmp	r2, #32
 2669 0008 01D1     		bne	.L264
 2670              	.L257:
1506:../Generated_Code/UTIL1.c ****     p++;
 2671              		.loc 1 1506 0
 2672 000a 0133     		add	r3, r3, #1
 2673              	.LVL351:
 2674 000c FAE7     		b	.L256
 2675              	.L264:
1508:../Generated_Code/UTIL1.c ****   *val = 0;
 2676              		.loc 1 1508 0
 2677 000e 0024     		mov	r4, #0
1505:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 2678              		.loc 1 1505 0
 2679 0010 1E1C     		mov	r6, r3
1508:../Generated_Code/UTIL1.c ****   *val = 0;
 2680              		.loc 1 1508 0
 2681 0012 0C70     		strb	r4, [r1]
1499:../Generated_Code/UTIL1.c **** byte UTIL1_ScanDecimal8uNumber(const unsigned char **str, byte *val)
 2682              		.loc 1 1499 0
 2683 0014 1D1D     		add	r5, r3, #4
 2684              	.LVL352:
 2685              	.L258:
1499:../Generated_Code/UTIL1.c **** byte UTIL1_ScanDecimal8uNumber(const unsigned char **str, byte *val)
 2686              		.loc 1 1499 0 is_stmt 0
 2687 0016 371D     		add	r7, r6, #4
 2688 0018 FA1A     		sub	r2, r7, r3
 2689 001a D4B2     		uxtb	r4, r2
1509:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 2690              		.loc 1 1509 0 is_stmt 1
 2691 001c 1A78     		ldrb	r2, [r3]
 2692 001e 171C     		mov	r7, r2
 2693 0020 303F     		sub	r7, r7, #48
 2694 0022 092F     		cmp	r7, #9
 2695 0024 0BD8     		bhi	.L259
1509:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 2696              		.loc 1 1509 0 is_stmt 0
 2697 0026 AB42     		cmp	r3, r5
 2698 0028 07D0     		beq	.L265
 2699              	.L260:
1510:../Generated_Code/UTIL1.c ****     *val = (uint8_t)((*val)*10 + *p-'0');
 2700              		.loc 1 1510 0 is_stmt 1
 2701 002a 0C78     		ldrb	r4, [r1]
 2702 002c 0A27     		mov	r7, #10
 2703 002e 7C43     		mul	r4, r7
 2704 0030 303C     		sub	r4, r4, #48
 2705 0032 1219     		add	r2, r2, r4
 2706 0034 0A70     		strb	r2, [r1]
1512:../Generated_Code/UTIL1.c ****     p++;
 2707              		.loc 1 1512 0
 2708 0036 0133     		add	r3, r3, #1
 2709              	.LVL353:
 2710 0038 EDE7     		b	.L258
 2711              	.L265:
1515:../Generated_Code/UTIL1.c ****     return ERR_OVERFLOW;
 2712              		.loc 1 1515 0
 2713 003a 0421     		mov	r1, #4
 2714              	.LVL354:
 2715 003c 04E0     		b	.L261
 2716              	.LVL355:
 2717              	.L259:
 2718 003e 0421     		mov	r1, #4
 2719              	.LVL356:
1514:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
 2720              		.loc 1 1514 0
 2721 0040 002C     		cmp	r4, #0
 2722 0042 01D0     		beq	.L261
1517:../Generated_Code/UTIL1.c ****   *str = p;
 2723              		.loc 1 1517 0
 2724 0044 0360     		str	r3, [r0]
1518:../Generated_Code/UTIL1.c ****   return ERR_OK;
 2725              		.loc 1 1518 0
 2726 0046 0021     		mov	r1, #0
 2727              	.L261:
1519:../Generated_Code/UTIL1.c **** }
 2728              		.loc 1 1519 0
 2729 0048 081C     		mov	r0, r1
 2730              	.LVL357:
 2731              		@ sp needed for prologue
 2732 004a F0BD     		pop	{r4, r5, r6, r7, pc}
 2733              		.cfi_endproc
 2734              	.LFE35:
 2736              		.section	.text.UTIL1_ScanTime,"ax",%progbits
 2737              		.align	1
 2738              		.global	UTIL1_ScanTime
 2739              		.code	16
 2740              		.thumb_func
 2742              	UTIL1_ScanTime:
 2743              	.LFB33:
1396:../Generated_Code/UTIL1.c **** {
 2744              		.loc 1 1396 0
 2745              		.cfi_startproc
 2746              	.LVL358:
 2747 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 2748              	.LCFI46:
 2749              		.cfi_def_cfa_offset 32
 2750              		.cfi_offset 0, -32
 2751              		.cfi_offset 1, -28
 2752              		.cfi_offset 2, -24
 2753              		.cfi_offset 4, -20
 2754              		.cfi_offset 5, -16
 2755              		.cfi_offset 6, -12
 2756              		.cfi_offset 7, -8
 2757              		.cfi_offset 14, -4
1396:../Generated_Code/UTIL1.c **** {
 2758              		.loc 1 1396 0
 2759 0002 1C1C     		mov	r4, r3
1401:../Generated_Code/UTIL1.c ****   *hour = 0;
 2760              		.loc 1 1401 0
 2761 0004 0023     		mov	r3, #0
 2762              	.LVL359:
 2763 0006 0B70     		strb	r3, [r1]
1396:../Generated_Code/UTIL1.c **** {
 2764              		.loc 1 1396 0
 2765 0008 0E1C     		mov	r6, r1
1404:../Generated_Code/UTIL1.c ****   *hSecond = 0;
 2766              		.loc 1 1404 0
 2767 000a 0899     		ldr	r1, [sp, #32]
 2768              	.LVL360:
1402:../Generated_Code/UTIL1.c ****   *minute = 0;
 2769              		.loc 1 1402 0
 2770 000c 1370     		strb	r3, [r2]
1403:../Generated_Code/UTIL1.c ****   *second = 0;
 2771              		.loc 1 1403 0
 2772 000e 2370     		strb	r3, [r4]
1404:../Generated_Code/UTIL1.c ****   *hSecond = 0;
 2773              		.loc 1 1404 0
 2774 0010 0B70     		strb	r3, [r1]
1396:../Generated_Code/UTIL1.c **** {
 2775              		.loc 1 1396 0
 2776 0012 151C     		mov	r5, r2
1405:../Generated_Code/UTIL1.c ****   p = *str;
 2777              		.loc 1 1405 0
 2778 0014 0268     		ldr	r2, [r0]
 2779              	.LVL361:
1396:../Generated_Code/UTIL1.c **** {
 2780              		.loc 1 1396 0
 2781 0016 071C     		mov	r7, r0
1405:../Generated_Code/UTIL1.c ****   p = *str;
 2782              		.loc 1 1405 0
 2783 0018 0192     		str	r2, [sp, #4]
 2784              	.LVL362:
 2785              	.L267:
1406:../Generated_Code/UTIL1.c ****   while(*p==' ') {
 2786              		.loc 1 1406 0
 2787 001a 0198     		ldr	r0, [sp, #4]
 2788 001c 0378     		ldrb	r3, [r0]
 2789 001e 202B     		cmp	r3, #32
 2790 0020 02D1     		bne	.L275
 2791              	.L268:
1407:../Generated_Code/UTIL1.c ****     p++; /* skip leading spaces */
 2792              		.loc 1 1407 0
 2793 0022 0130     		add	r0, r0, #1
 2794 0024 0190     		str	r0, [sp, #4]
 2795 0026 F8E7     		b	.L267
 2796              	.L275:
1409:../Generated_Code/UTIL1.c ****   if (   UTIL1_ScanDecimal8uNumber(&p, hour)==ERR_OK
 2797              		.loc 1 1409 0
 2798 0028 01A8     		add	r0, sp, #4
 2799 002a 311C     		mov	r1, r6
 2800 002c FFF7FEFF 		bl	UTIL1_ScanDecimal8uNumber
 2801              	.LVL363:
 2802 0030 0028     		cmp	r0, #0
 2803 0032 01D0     		beq	.L269
 2804              	.LVL364:
 2805              	.L271:
1446:../Generated_Code/UTIL1.c ****   return ERR_FAILED; /* wrong format */
 2806              		.loc 1 1446 0
 2807 0034 1B20     		mov	r0, #27
 2808 0036 3BE0     		b	.L270
 2809              	.LVL365:
 2810              	.L269:
1410:../Generated_Code/UTIL1.c ****       && *hour <= 24
 2811              		.loc 1 1410 0
 2812 0038 3678     		ldrb	r6, [r6]
 2813              	.LVL366:
 2814 003a 182E     		cmp	r6, #24
 2815 003c FAD8     		bhi	.L271
1411:../Generated_Code/UTIL1.c ****       && *p==':'
 2816              		.loc 1 1411 0
 2817 003e 0199     		ldr	r1, [sp, #4]
 2818 0040 0A78     		ldrb	r2, [r1]
 2819 0042 3A2A     		cmp	r2, #58
 2820 0044 F6D1     		bne	.L271
1414:../Generated_Code/UTIL1.c ****     p++; /* skip ':' */
 2821              		.loc 1 1414 0
 2822 0046 0131     		add	r1, r1, #1
 2823 0048 0191     		str	r1, [sp, #4]
1415:../Generated_Code/UTIL1.c ****     if (   UTIL1_ScanDecimal8uNumber(&p, minute)==ERR_OK
 2824              		.loc 1 1415 0
 2825 004a 01A8     		add	r0, sp, #4
 2826 004c 291C     		mov	r1, r5
 2827 004e FFF7FEFF 		bl	UTIL1_ScanDecimal8uNumber
 2828              	.LVL367:
 2829 0052 0028     		cmp	r0, #0
 2830 0054 EED1     		bne	.L271
1416:../Generated_Code/UTIL1.c ****         && *minute <= 60
 2831              		.loc 1 1416 0
 2832 0056 2D78     		ldrb	r5, [r5]
 2833              	.LVL368:
 2834 0058 3C2D     		cmp	r5, #60
 2835 005a EBD8     		bhi	.L271
1417:../Generated_Code/UTIL1.c ****         && *p==':'
 2836              		.loc 1 1417 0
 2837 005c 0198     		ldr	r0, [sp, #4]
 2838 005e 0378     		ldrb	r3, [r0]
 2839 0060 3A2B     		cmp	r3, #58
 2840 0062 E7D1     		bne	.L271
1420:../Generated_Code/UTIL1.c ****       p++; /* skip ':' */
 2841              		.loc 1 1420 0
 2842 0064 0130     		add	r0, r0, #1
 2843 0066 0190     		str	r0, [sp, #4]
1421:../Generated_Code/UTIL1.c ****       if (   UTIL1_ScanDecimal8uNumber(&p, second)==ERR_OK
 2844              		.loc 1 1421 0
 2845 0068 211C     		mov	r1, r4
 2846 006a 01A8     		add	r0, sp, #4
 2847 006c FFF7FEFF 		bl	UTIL1_ScanDecimal8uNumber
 2848              	.LVL369:
 2849 0070 0028     		cmp	r0, #0
 2850 0072 DFD1     		bne	.L271
1422:../Generated_Code/UTIL1.c ****           && *second <= 60
 2851              		.loc 1 1422 0
 2852 0074 2478     		ldrb	r4, [r4]
 2853              	.LVL370:
 2854 0076 3C2C     		cmp	r4, #60
 2855 0078 DCD8     		bhi	.L271
1425:../Generated_Code/UTIL1.c ****         if (*p==',') { /* we do have either ",z" or ",hh" */
 2856              		.loc 1 1425 0
 2857 007a 019E     		ldr	r6, [sp, #4]
 2858 007c 3178     		ldrb	r1, [r6]
 2859 007e 2C29     		cmp	r1, #44
 2860 0080 16D1     		bne	.L270
1426:../Generated_Code/UTIL1.c ****           p++; /* skip ',' */
 2861              		.loc 1 1426 0
 2862 0082 721C     		add	r2, r6, #1
 2863 0084 0192     		str	r2, [sp, #4]
1427:../Generated_Code/UTIL1.c ****           if (SCAN_IS_DIGIT(*p)) {
 2864              		.loc 1 1427 0
 2865 0086 7578     		ldrb	r5, [r6, #1]
 2866 0088 303D     		sub	r5, r5, #48
 2867 008a E8B2     		uxtb	r0, r5
 2868 008c 0928     		cmp	r0, #9
 2869 008e D1D8     		bhi	.L271
1428:../Generated_Code/UTIL1.c ****             if (SCAN_IS_DIGIT(*(p+1))) { /* ,hh format */
 2870              		.loc 1 1428 0
 2871 0090 B378     		ldrb	r3, [r6, #2]
 2872 0092 0A21     		mov	r1, #10
 2873 0094 303B     		sub	r3, r3, #48
 2874 0096 DCB2     		uxtb	r4, r3
1429:../Generated_Code/UTIL1.c ****               *hSecond = (uint8_t)((*p-'0')*10 + *(p+1)-'0');
 2875              		.loc 1 1429 0
 2876 0098 4D43     		mul	r5, r1
1428:../Generated_Code/UTIL1.c ****             if (SCAN_IS_DIGIT(*(p+1))) { /* ,hh format */
 2877              		.loc 1 1428 0
 2878 009a 092C     		cmp	r4, #9
 2879 009c 03D8     		bhi	.L272
1429:../Generated_Code/UTIL1.c ****               *hSecond = (uint8_t)((*p-'0')*10 + *(p+1)-'0');
 2880              		.loc 1 1429 0
 2881 009e 089E     		ldr	r6, [sp, #32]
 2882 00a0 6719     		add	r7, r4, r5
 2883              	.LVL371:
 2884 00a2 3770     		strb	r7, [r6]
 2885 00a4 03E0     		b	.L274
 2886              	.LVL372:
 2887              	.L272:
1433:../Generated_Code/UTIL1.c ****               *hSecond = (uint8_t)((*p-'0')*10);
 2888              		.loc 1 1433 0
 2889 00a6 089A     		ldr	r2, [sp, #32]
1434:../Generated_Code/UTIL1.c ****               p++;
 2890              		.loc 1 1434 0
 2891 00a8 0236     		add	r6, r6, #2
1433:../Generated_Code/UTIL1.c ****               *hSecond = (uint8_t)((*p-'0')*10);
 2892              		.loc 1 1433 0
 2893 00aa 1570     		strb	r5, [r2]
1435:../Generated_Code/UTIL1.c ****               *str = p; /* advance pointer for caller */
 2894              		.loc 1 1435 0
 2895 00ac 3E60     		str	r6, [r7]
 2896              	.LVL373:
 2897              	.L274:
1436:../Generated_Code/UTIL1.c ****               return ERR_OK;
 2898              		.loc 1 1436 0
 2899 00ae 0020     		mov	r0, #0
 2900              	.L270:
1447:../Generated_Code/UTIL1.c **** }
 2901              		.loc 1 1447 0
 2902              		@ sp needed for prologue
 2903 00b0 FEBD     		pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 2904              		.cfi_endproc
 2905              	.LFE33:
 2907              		.section	.text.UTIL1_ScanDate,"ax",%progbits
 2908              		.align	1
 2909              		.global	UTIL1_ScanDate
 2910              		.code	16
 2911              		.thumb_func
 2913              	UTIL1_ScanDate:
 2914              	.LFB32:
1335:../Generated_Code/UTIL1.c **** {
 2915              		.loc 1 1335 0
 2916              		.cfi_startproc
 2917              	.LVL374:
 2918 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 2919              	.LCFI47:
 2920              		.cfi_def_cfa_offset 32
 2921              		.cfi_offset 0, -32
 2922              		.cfi_offset 1, -28
 2923              		.cfi_offset 2, -24
 2924              		.cfi_offset 4, -20
 2925              		.cfi_offset 5, -16
 2926              		.cfi_offset 6, -12
 2927              		.cfi_offset 7, -8
 2928              		.cfi_offset 14, -4
1335:../Generated_Code/UTIL1.c **** {
 2929              		.loc 1 1335 0
 2930 0002 151C     		mov	r5, r2
1339:../Generated_Code/UTIL1.c ****   p = *str;
 2931              		.loc 1 1339 0
 2932 0004 0268     		ldr	r2, [r0]
 2933              	.LVL375:
1335:../Generated_Code/UTIL1.c **** {
 2934              		.loc 1 1335 0
 2935 0006 071C     		mov	r7, r0
 2936 0008 0E1C     		mov	r6, r1
 2937 000a 1C1C     		mov	r4, r3
1339:../Generated_Code/UTIL1.c ****   p = *str;
 2938              		.loc 1 1339 0
 2939 000c 0192     		str	r2, [sp, #4]
 2940              	.LVL376:
 2941              	.L277:
1340:../Generated_Code/UTIL1.c ****   while(*p==' ') {
 2942              		.loc 1 1340 0
 2943 000e 019B     		ldr	r3, [sp, #4]
 2944 0010 1878     		ldrb	r0, [r3]
 2945 0012 2028     		cmp	r0, #32
 2946 0014 02D1     		bne	.L291
 2947              	.L278:
1341:../Generated_Code/UTIL1.c ****     p++; /* skip leading spaces */
 2948              		.loc 1 1341 0
 2949 0016 0133     		add	r3, r3, #1
 2950 0018 0193     		str	r3, [sp, #4]
 2951 001a F8E7     		b	.L277
 2952              	.L291:
1343:../Generated_Code/UTIL1.c ****   if (   UTIL1_ScanDecimal8uNumber(&p, day)==ERR_OK
 2953              		.loc 1 1343 0
 2954 001c 01A8     		add	r0, sp, #4
 2955 001e 311C     		mov	r1, r6
 2956              	.LVL377:
 2957 0020 FFF7FEFF 		bl	UTIL1_ScanDecimal8uNumber
 2958              	.LVL378:
 2959 0024 0028     		cmp	r0, #0
 2960 0026 33D1     		bne	.L279
1344:../Generated_Code/UTIL1.c ****       && *day > 0 && *day <= 31
 2961              		.loc 1 1344 0
 2962 0028 3178     		ldrb	r1, [r6]
 2963 002a 0029     		cmp	r1, #0
 2964 002c 30D0     		beq	.L279
1344:../Generated_Code/UTIL1.c ****       && *day > 0 && *day <= 31
 2965              		.loc 1 1344 0 is_stmt 0
 2966 002e 1F29     		cmp	r1, #31
 2967 0030 2ED8     		bhi	.L279
1345:../Generated_Code/UTIL1.c ****       && (*p=='.' || *p=='-')
 2968              		.loc 1 1345 0 is_stmt 1
 2969 0032 019B     		ldr	r3, [sp, #4]
 2970 0034 1A78     		ldrb	r2, [r3]
 2971 0036 2D3A     		sub	r2, r2, #45
 2972 0038 012A     		cmp	r2, #1
 2973 003a 29D8     		bhi	.L279
1348:../Generated_Code/UTIL1.c ****     p++;
 2974              		.loc 1 1348 0
 2975 003c 0133     		add	r3, r3, #1
1349:../Generated_Code/UTIL1.c ****     if (   UTIL1_ScanDecimal8uNumber(&p, month)==ERR_OK
 2976              		.loc 1 1349 0
 2977 003e 01A8     		add	r0, sp, #4
 2978 0040 291C     		mov	r1, r5
1348:../Generated_Code/UTIL1.c ****     p++;
 2979              		.loc 1 1348 0
 2980 0042 0193     		str	r3, [sp, #4]
1349:../Generated_Code/UTIL1.c ****     if (   UTIL1_ScanDecimal8uNumber(&p, month)==ERR_OK
 2981              		.loc 1 1349 0
 2982 0044 FFF7FEFF 		bl	UTIL1_ScanDecimal8uNumber
 2983              	.LVL379:
 2984 0048 0028     		cmp	r0, #0
 2985 004a 21D1     		bne	.L279
1350:../Generated_Code/UTIL1.c ****         && *month > 0 && *month <= 12
 2986              		.loc 1 1350 0
 2987 004c 2878     		ldrb	r0, [r5]
 2988 004e 0028     		cmp	r0, #0
 2989 0050 1ED0     		beq	.L279
1350:../Generated_Code/UTIL1.c ****         && *month > 0 && *month <= 12
 2990              		.loc 1 1350 0 is_stmt 0
 2991 0052 0C28     		cmp	r0, #12
 2992 0054 1CD8     		bhi	.L279
1351:../Generated_Code/UTIL1.c ****         && (*p=='.' || *p=='-')
 2993              		.loc 1 1351 0 is_stmt 1
 2994 0056 0199     		ldr	r1, [sp, #4]
 2995 0058 0B78     		ldrb	r3, [r1]
 2996 005a 2D3B     		sub	r3, r3, #45
 2997 005c 012B     		cmp	r3, #1
 2998 005e 17D8     		bhi	.L279
1354:../Generated_Code/UTIL1.c ****       p++;
 2999              		.loc 1 1354 0
 3000 0060 0131     		add	r1, r1, #1
 3001 0062 0191     		str	r1, [sp, #4]
1355:../Generated_Code/UTIL1.c ****       if (   UTIL1_ScanDecimal16uNumber(&p, year)==ERR_OK
 3002              		.loc 1 1355 0
 3003 0064 01A8     		add	r0, sp, #4
 3004 0066 211C     		mov	r1, r4
 3005 0068 FFF7FEFF 		bl	UTIL1_ScanDecimal16uNumber
 3006              	.LVL380:
 3007 006c 0028     		cmp	r0, #0
 3008 006e 0FD1     		bne	.L279
1356:../Generated_Code/UTIL1.c ****           && *year > 0 && *year <= 3000 /* hopefully this is enough :-) */
 3009              		.loc 1 1356 0
 3010 0070 2088     		ldrh	r0, [r4]
 3011 0072 0028     		cmp	r0, #0
 3012 0074 0CD0     		beq	.L279
1356:../Generated_Code/UTIL1.c ****           && *year > 0 && *year <= 3000 /* hopefully this is enough :-) */
 3013              		.loc 1 1356 0 is_stmt 0
 3014 0076 094A     		ldr	r2, .L292
 3015 0078 9042     		cmp	r0, r2
 3016 007a 09D8     		bhi	.L279
1359:../Generated_Code/UTIL1.c ****         if (*year < 100) {
 3017              		.loc 1 1359 0 is_stmt 1
 3018 007c 6328     		cmp	r0, #99
 3019 007e 03D8     		bhi	.L280
1360:../Generated_Code/UTIL1.c ****           *year += 2000; /* transform '10' into '2010' */
 3020              		.loc 1 1360 0
 3021 0080 FA25     		mov	r5, #250
 3022              	.LVL381:
 3023 0082 EE00     		lsl	r6, r5, #3
 3024              	.LVL382:
 3025 0084 8119     		add	r1, r0, r6
 3026 0086 2180     		strh	r1, [r4]
 3027              	.L280:
1362:../Generated_Code/UTIL1.c ****         *str = p; /* advance pointer for caller */
 3028              		.loc 1 1362 0
 3029 0088 019C     		ldr	r4, [sp, #4]
 3030              	.LVL383:
1363:../Generated_Code/UTIL1.c ****         return ERR_OK;
 3031              		.loc 1 1363 0
 3032 008a 0020     		mov	r0, #0
1362:../Generated_Code/UTIL1.c ****         *str = p; /* advance pointer for caller */
 3033              		.loc 1 1362 0
 3034 008c 3C60     		str	r4, [r7]
 3035 008e 04E0     		b	.L281
 3036              	.LVL384:
 3037              	.L279:
1367:../Generated_Code/UTIL1.c ****   *day = 0;
 3038              		.loc 1 1367 0
 3039 0090 0027     		mov	r7, #0
 3040              	.LVL385:
 3041 0092 3770     		strb	r7, [r6]
1370:../Generated_Code/UTIL1.c ****   return ERR_FAILED; /* wrong format */
 3042              		.loc 1 1370 0
 3043 0094 1B20     		mov	r0, #27
1368:../Generated_Code/UTIL1.c ****   *month = 0;
 3044              		.loc 1 1368 0
 3045 0096 2F70     		strb	r7, [r5]
1369:../Generated_Code/UTIL1.c ****   *year = 0;
 3046              		.loc 1 1369 0
 3047 0098 2780     		strh	r7, [r4]
 3048              	.LVL386:
 3049              	.L281:
1371:../Generated_Code/UTIL1.c **** }
 3050              		.loc 1 1371 0
 3051              		@ sp needed for prologue
 3052 009a FEBD     		pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 3053              	.L293:
 3054              		.align	2
 3055              	.L292:
 3056 009c B80B0000 		.word	3000
 3057              		.cfi_endproc
 3058              	.LFE32:
 3060              		.section	.text.UTIL1_ScanDecimal32uNumber,"ax",%progbits
 3061              		.align	1
 3062              		.global	UTIL1_ScanDecimal32uNumber
 3063              		.code	16
 3064              		.thumb_func
 3066              	UTIL1_ScanDecimal32uNumber:
 3067              	.LFB36:
1536:../Generated_Code/UTIL1.c **** {
 3068              		.loc 1 1536 0
 3069              		.cfi_startproc
 3070              	.LVL387:
 3071 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 3072              	.LCFI48:
 3073              		.cfi_def_cfa_offset 20
 3074              		.cfi_offset 4, -20
 3075              		.cfi_offset 5, -16
 3076              		.cfi_offset 6, -12
 3077              		.cfi_offset 7, -8
 3078              		.cfi_offset 14, -4
1539:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 3079              		.loc 1 1539 0
 3080 0002 0368     		ldr	r3, [r0]
 3081              	.LVL388:
 3082              	.L295:
1541:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 3083              		.loc 1 1541 0
 3084 0004 1A78     		ldrb	r2, [r3]
 3085 0006 202A     		cmp	r2, #32
 3086 0008 01D1     		bne	.L302
 3087              	.L296:
1542:../Generated_Code/UTIL1.c ****     p++;
 3088              		.loc 1 1542 0
 3089 000a 0133     		add	r3, r3, #1
 3090              	.LVL389:
 3091 000c FAE7     		b	.L295
 3092              	.L302:
1544:../Generated_Code/UTIL1.c ****   *val = 0;
 3093              		.loc 1 1544 0
 3094 000e 0024     		mov	r4, #0
1535:../Generated_Code/UTIL1.c **** byte UTIL1_ScanDecimal32uNumber(const unsigned char **str, dword *val)
 3095              		.loc 1 1535 0
 3096 0010 1D1C     		mov	r5, r3
1541:../Generated_Code/UTIL1.c ****   while(*p==' ') { /* skip leading spaces */
 3097              		.loc 1 1541 0
 3098 0012 1E1C     		mov	r6, r3
1544:../Generated_Code/UTIL1.c ****   *val = 0;
 3099              		.loc 1 1544 0
 3100 0014 0C60     		str	r4, [r1]
1535:../Generated_Code/UTIL1.c **** byte UTIL1_ScanDecimal32uNumber(const unsigned char **str, dword *val)
 3101              		.loc 1 1535 0
 3102 0016 0B35     		add	r5, r5, #11
 3103              	.LVL390:
 3104              	.L297:
1535:../Generated_Code/UTIL1.c **** byte UTIL1_ScanDecimal32uNumber(const unsigned char **str, dword *val)
 3105              		.loc 1 1535 0 is_stmt 0
 3106 0018 371C     		mov	r7, r6
 3107 001a 0B37     		add	r7, r7, #11
 3108 001c FA1A     		sub	r2, r7, r3
 3109 001e D4B2     		uxtb	r4, r2
1545:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 3110              		.loc 1 1545 0 is_stmt 1
 3111 0020 1A78     		ldrb	r2, [r3]
 3112 0022 171C     		mov	r7, r2
 3113 0024 303F     		sub	r7, r7, #48
 3114 0026 092F     		cmp	r7, #9
 3115 0028 09D8     		bhi	.L298
1545:../Generated_Code/UTIL1.c ****   while(*p>='0' && *p<='9' && nofDigits > 0) {
 3116              		.loc 1 1545 0 is_stmt 0
 3117 002a AB42     		cmp	r3, r5
 3118 002c 0CD0     		beq	.L301
 3119              	.L299:
1546:../Generated_Code/UTIL1.c ****     *val = (uint32_t)((*val)*10 + *p-'0');
 3120              		.loc 1 1546 0 is_stmt 1
 3121 002e 0F68     		ldr	r7, [r1]
 3122 0030 0A24     		mov	r4, #10
 3123 0032 7C43     		mul	r4, r7
 3124 0034 303C     		sub	r4, r4, #48
 3125 0036 A218     		add	r2, r4, r2
 3126 0038 0A60     		str	r2, [r1]
1548:../Generated_Code/UTIL1.c ****     p++;
 3127              		.loc 1 1548 0
 3128 003a 0133     		add	r3, r3, #1
 3129              	.LVL391:
 3130 003c ECE7     		b	.L297
 3131              	.L298:
1550:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
 3132              		.loc 1 1550 0
 3133 003e 002C     		cmp	r4, #0
 3134 0040 02D0     		beq	.L301
1553:../Generated_Code/UTIL1.c ****   *str = p;
 3135              		.loc 1 1553 0
 3136 0042 0360     		str	r3, [r0]
1554:../Generated_Code/UTIL1.c ****   return ERR_OK;
 3137              		.loc 1 1554 0
 3138 0044 0020     		mov	r0, #0
 3139              	.LVL392:
 3140 0046 00E0     		b	.L300
 3141              	.LVL393:
 3142              	.L301:
1551:../Generated_Code/UTIL1.c ****     return ERR_OVERFLOW;
 3143              		.loc 1 1551 0
 3144 0048 0420     		mov	r0, #4
 3145              	.LVL394:
 3146              	.L300:
1555:../Generated_Code/UTIL1.c **** }
 3147              		.loc 1 1555 0
 3148              		@ sp needed for prologue
 3149 004a F0BD     		pop	{r4, r5, r6, r7, pc}
 3150              		.cfi_endproc
 3151              	.LFE36:
 3153              		.section	.text.UTIL1_ScanHex32uNumber,"ax",%progbits
 3154              		.align	1
 3155              		.global	UTIL1_ScanHex32uNumber
 3156              		.code	16
 3157              		.thumb_func
 3159              	UTIL1_ScanHex32uNumber:
 3160              	.LFB39:
1657:../Generated_Code/UTIL1.c **** 
1658:../Generated_Code/UTIL1.c **** /*
1659:../Generated_Code/UTIL1.c **** ** ===================================================================
1660:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanHex32uNumber (component Utility)
1661:../Generated_Code/UTIL1.c **** **     Description :
1662:../Generated_Code/UTIL1.c **** **         Scans a hexadecimal 32bit number, starting with 0x
1663:../Generated_Code/UTIL1.c **** **     Parameters  :
1664:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1665:../Generated_Code/UTIL1.c **** **         str             - String to scan, starting with 0x. It
1666:../Generated_Code/UTIL1.c **** **                           returns as well until where it has scanned
1667:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1668:../Generated_Code/UTIL1.c **** **     Returns     :
1669:../Generated_Code/UTIL1.c **** **         ---             - Error code
1670:../Generated_Code/UTIL1.c **** ** ===================================================================
1671:../Generated_Code/UTIL1.c **** */
1672:../Generated_Code/UTIL1.c **** byte UTIL1_ScanHex32uNumber(const unsigned char **str, dword *val)
1673:../Generated_Code/UTIL1.c **** {
 3161              		.loc 1 1673 0
 3162              		.cfi_startproc
 3163              	.LVL395:
 3164 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 3165              	.LCFI49:
 3166              		.cfi_def_cfa_offset 32
 3167              		.cfi_offset 0, -32
 3168              		.cfi_offset 1, -28
 3169              		.cfi_offset 2, -24
 3170              		.cfi_offset 4, -20
 3171              		.cfi_offset 5, -16
 3172              		.cfi_offset 6, -12
 3173              		.cfi_offset 7, -8
 3174              		.cfi_offset 14, -4
1674:../Generated_Code/UTIL1.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1675:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = 8+1; /* maximum number of digits to avoid overflow */
1676:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 3175              		.loc 1 1676 0
 3176 0002 0368     		ldr	r3, [r0]
1673:../Generated_Code/UTIL1.c **** {
 3177              		.loc 1 1673 0
 3178 0004 061C     		mov	r6, r0
1677:../Generated_Code/UTIL1.c ****   byte v;
1678:../Generated_Code/UTIL1.c **** 
1679:../Generated_Code/UTIL1.c ****   if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
 3179              		.loc 1 1679 0
 3180 0006 01A8     		add	r0, sp, #4
 3181              	.LVL396:
1673:../Generated_Code/UTIL1.c **** {
 3182              		.loc 1 1673 0
 3183 0008 0D1C     		mov	r5, r1
1676:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 3184              		.loc 1 1676 0
 3185 000a 0193     		str	r3, [sp, #4]
 3186              	.LVL397:
 3187              		.loc 1 1679 0
 3188 000c FFF7FEFF 		bl	PreScanHexNumber
 3189              	.LVL398:
1680:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 3190              		.loc 1 1680 0
 3191 0010 1B21     		mov	r1, #27
1679:../Generated_Code/UTIL1.c ****   if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
 3192              		.loc 1 1679 0
 3193 0012 0028     		cmp	r0, #0
 3194 0014 1BD1     		bne	.L304
1681:../Generated_Code/UTIL1.c ****   }
1682:../Generated_Code/UTIL1.c ****   *val = 0;
 3195              		.loc 1 1682 0
 3196 0016 2860     		str	r0, [r5]
1675:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = 8+1; /* maximum number of digits to avoid overflow */
 3197              		.loc 1 1675 0
 3198 0018 0924     		mov	r4, #9
 3199              	.LVL399:
 3200              	.L305:
1683:../Generated_Code/UTIL1.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 3201              		.loc 1 1683 0
 3202 001a 6F46     		mov	r7, sp
 3203 001c 0337     		add	r7, r7, #3
 3204 001e 01A8     		add	r0, sp, #4
 3205 0020 391C     		mov	r1, r7
 3206 0022 FFF7FEFF 		bl	HexToDec
 3207              	.LVL400:
 3208 0026 0028     		cmp	r0, #0
 3209 0028 0BD1     		bne	.L306
 3210              		.loc 1 1683 0 is_stmt 0
 3211 002a 002C     		cmp	r4, #0
 3212 002c 07D0     		beq	.L311
 3213              	.L307:
1684:../Generated_Code/UTIL1.c ****     *val = (uint32_t)((*val)*16 + v);
 3214              		.loc 1 1684 0 is_stmt 1
 3215 002e 2A68     		ldr	r2, [r5]
 3216              	.LVL401:
 3217 0030 3B78     		ldrb	r3, [r7]
 3218              	.LVL402:
 3219 0032 1001     		lsl	r0, r2, #4
 3220 0034 C718     		add	r7, r0, r3
 3221              	.LVL403:
1685:../Generated_Code/UTIL1.c ****     nofDigits--;
 3222              		.loc 1 1685 0
 3223 0036 013C     		sub	r4, r4, #1
 3224              	.LVL404:
1684:../Generated_Code/UTIL1.c ****     *val = (uint32_t)((*val)*16 + v);
 3225              		.loc 1 1684 0
 3226 0038 2F60     		str	r7, [r5]
 3227              		.loc 1 1685 0
 3228 003a E4B2     		uxtb	r4, r4
 3229              	.LVL405:
 3230 003c EDE7     		b	.L305
 3231              	.LVL406:
 3232              	.L311:
1686:../Generated_Code/UTIL1.c ****   } /* while */
1687:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
1688:../Generated_Code/UTIL1.c ****     return ERR_OVERFLOW;
 3233              		.loc 1 1688 0
 3234 003e 0421     		mov	r1, #4
 3235 0040 05E0     		b	.L304
 3236              	.L306:
 3237 0042 0421     		mov	r1, #4
1687:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
 3238              		.loc 1 1687 0
 3239 0044 002C     		cmp	r4, #0
 3240 0046 02D0     		beq	.L304
1689:../Generated_Code/UTIL1.c ****   }
1690:../Generated_Code/UTIL1.c ****   *str = p;
 3241              		.loc 1 1690 0
 3242 0048 0198     		ldr	r0, [sp, #4]
1691:../Generated_Code/UTIL1.c ****   return ERR_OK;
 3243              		.loc 1 1691 0
 3244 004a 0021     		mov	r1, #0
1690:../Generated_Code/UTIL1.c ****   *str = p;
 3245              		.loc 1 1690 0
 3246 004c 3060     		str	r0, [r6]
 3247              	.LVL407:
 3248              	.L304:
1692:../Generated_Code/UTIL1.c **** }
 3249              		.loc 1 1692 0
 3250 004e 081C     		mov	r0, r1
 3251              		@ sp needed for prologue
 3252              	.LVL408:
 3253              	.LVL409:
 3254 0050 FEBD     		pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 3255              		.cfi_endproc
 3256              	.LFE39:
 3258              		.section	.text.UTIL1_ScanHex16uNumber,"ax",%progbits
 3259              		.align	1
 3260              		.global	UTIL1_ScanHex16uNumber
 3261              		.code	16
 3262              		.thumb_func
 3264              	UTIL1_ScanHex16uNumber:
 3265              	.LFB40:
1693:../Generated_Code/UTIL1.c **** 
1694:../Generated_Code/UTIL1.c **** /*
1695:../Generated_Code/UTIL1.c **** ** ===================================================================
1696:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanHex16uNumber (component Utility)
1697:../Generated_Code/UTIL1.c **** **     Description :
1698:../Generated_Code/UTIL1.c **** **         Scans a hexadecimal 16bit number, starting with 0x
1699:../Generated_Code/UTIL1.c **** **     Parameters  :
1700:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1701:../Generated_Code/UTIL1.c **** **         str             - String to scan, starting with 0x.. It
1702:../Generated_Code/UTIL1.c **** **                           returns as well until where it has scanned
1703:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1704:../Generated_Code/UTIL1.c **** **     Returns     :
1705:../Generated_Code/UTIL1.c **** **         ---             - Error code
1706:../Generated_Code/UTIL1.c **** ** ===================================================================
1707:../Generated_Code/UTIL1.c **** */
1708:../Generated_Code/UTIL1.c **** byte UTIL1_ScanHex16uNumber(const unsigned char **str, word *val)
1709:../Generated_Code/UTIL1.c **** {
 3266              		.loc 1 1709 0
 3267              		.cfi_startproc
 3268              	.LVL410:
 3269 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 3270              	.LCFI50:
 3271              		.cfi_def_cfa_offset 32
 3272              		.cfi_offset 0, -32
 3273              		.cfi_offset 1, -28
 3274              		.cfi_offset 2, -24
 3275              		.cfi_offset 4, -20
 3276              		.cfi_offset 5, -16
 3277              		.cfi_offset 6, -12
 3278              		.cfi_offset 7, -8
 3279              		.cfi_offset 14, -4
1710:../Generated_Code/UTIL1.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1711:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = 4+1; /* maximum number of digits to avoid overflow */
1712:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 3280              		.loc 1 1712 0
 3281 0002 0368     		ldr	r3, [r0]
1709:../Generated_Code/UTIL1.c **** {
 3282              		.loc 1 1709 0
 3283 0004 061C     		mov	r6, r0
1713:../Generated_Code/UTIL1.c ****   byte v;
1714:../Generated_Code/UTIL1.c **** 
1715:../Generated_Code/UTIL1.c ****   if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
 3284              		.loc 1 1715 0
 3285 0006 01A8     		add	r0, sp, #4
 3286              	.LVL411:
1709:../Generated_Code/UTIL1.c **** {
 3287              		.loc 1 1709 0
 3288 0008 0D1C     		mov	r5, r1
1712:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 3289              		.loc 1 1712 0
 3290 000a 0193     		str	r3, [sp, #4]
 3291              	.LVL412:
 3292              		.loc 1 1715 0
 3293 000c FFF7FEFF 		bl	PreScanHexNumber
 3294              	.LVL413:
1716:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 3295              		.loc 1 1716 0
 3296 0010 1B21     		mov	r1, #27
1715:../Generated_Code/UTIL1.c ****   if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
 3297              		.loc 1 1715 0
 3298 0012 0028     		cmp	r0, #0
 3299 0014 1BD1     		bne	.L313
1717:../Generated_Code/UTIL1.c ****   }
1718:../Generated_Code/UTIL1.c ****   *val = 0;
 3300              		.loc 1 1718 0
 3301 0016 2880     		strh	r0, [r5]
1711:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = 4+1; /* maximum number of digits to avoid overflow */
 3302              		.loc 1 1711 0
 3303 0018 0524     		mov	r4, #5
 3304              	.LVL414:
 3305              	.L314:
1719:../Generated_Code/UTIL1.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 3306              		.loc 1 1719 0
 3307 001a 6F46     		mov	r7, sp
 3308              	.LVL415:
 3309 001c 0337     		add	r7, r7, #3
 3310 001e 01A8     		add	r0, sp, #4
 3311 0020 391C     		mov	r1, r7
 3312 0022 FFF7FEFF 		bl	HexToDec
 3313              	.LVL416:
 3314 0026 0028     		cmp	r0, #0
 3315 0028 0BD1     		bne	.L315
 3316              		.loc 1 1719 0 is_stmt 0
 3317 002a 002C     		cmp	r4, #0
 3318 002c 07D0     		beq	.L320
 3319              	.L316:
1720:../Generated_Code/UTIL1.c ****     *val = (uint16_t)((*val)*16 + v);
 3320              		.loc 1 1720 0 is_stmt 1
 3321 002e 2A88     		ldrh	r2, [r5]
 3322              	.LVL417:
 3323 0030 3F78     		ldrb	r7, [r7]
 3324              	.LVL418:
 3325 0032 1301     		lsl	r3, r2, #4
 3326 0034 D819     		add	r0, r3, r7
 3327              	.LVL419:
1721:../Generated_Code/UTIL1.c ****     nofDigits--;
 3328              		.loc 1 1721 0
 3329 0036 013C     		sub	r4, r4, #1
 3330              	.LVL420:
1720:../Generated_Code/UTIL1.c ****     *val = (uint16_t)((*val)*16 + v);
 3331              		.loc 1 1720 0
 3332 0038 2880     		strh	r0, [r5]
 3333              		.loc 1 1721 0
 3334 003a E4B2     		uxtb	r4, r4
 3335              	.LVL421:
 3336 003c EDE7     		b	.L314
 3337              	.LVL422:
 3338              	.L320:
1722:../Generated_Code/UTIL1.c ****   } /* while */
1723:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
1724:../Generated_Code/UTIL1.c ****     return ERR_OVERFLOW;
 3339              		.loc 1 1724 0
 3340 003e 0421     		mov	r1, #4
 3341 0040 05E0     		b	.L313
 3342              	.L315:
 3343 0042 0421     		mov	r1, #4
1723:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
 3344              		.loc 1 1723 0
 3345 0044 002C     		cmp	r4, #0
 3346 0046 02D0     		beq	.L313
1725:../Generated_Code/UTIL1.c ****   }
1726:../Generated_Code/UTIL1.c ****   *str = p;
 3347              		.loc 1 1726 0
 3348 0048 0198     		ldr	r0, [sp, #4]
1727:../Generated_Code/UTIL1.c ****   return ERR_OK;
 3349              		.loc 1 1727 0
 3350 004a 0021     		mov	r1, #0
1726:../Generated_Code/UTIL1.c ****   *str = p;
 3351              		.loc 1 1726 0
 3352 004c 3060     		str	r0, [r6]
 3353              	.LVL423:
 3354              	.L313:
1728:../Generated_Code/UTIL1.c **** }
 3355              		.loc 1 1728 0
 3356 004e 081C     		mov	r0, r1
 3357              		@ sp needed for prologue
 3358              	.LVL424:
 3359              	.LVL425:
 3360 0050 FEBD     		pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 3361              		.cfi_endproc
 3362              	.LFE40:
 3364              		.section	.text.UTIL1_ScanHex8uNumber,"ax",%progbits
 3365              		.align	1
 3366              		.global	UTIL1_ScanHex8uNumber
 3367              		.code	16
 3368              		.thumb_func
 3370              	UTIL1_ScanHex8uNumber:
 3371              	.LFB41:
1729:../Generated_Code/UTIL1.c **** 
1730:../Generated_Code/UTIL1.c **** /*
1731:../Generated_Code/UTIL1.c **** ** ===================================================================
1732:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_ScanHex8uNumber (component Utility)
1733:../Generated_Code/UTIL1.c **** **     Description :
1734:../Generated_Code/UTIL1.c **** **         Scans a hexadecimal 8bit number, starting with 0x
1735:../Generated_Code/UTIL1.c **** **     Parameters  :
1736:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1737:../Generated_Code/UTIL1.c **** **         str             - String to scan, starting with 0x. It
1738:../Generated_Code/UTIL1.c **** **                           returns as well until where it has scanned
1739:../Generated_Code/UTIL1.c **** **       * val             - Pointer to value
1740:../Generated_Code/UTIL1.c **** **     Returns     :
1741:../Generated_Code/UTIL1.c **** **         ---             - Error code
1742:../Generated_Code/UTIL1.c **** ** ===================================================================
1743:../Generated_Code/UTIL1.c **** */
1744:../Generated_Code/UTIL1.c **** byte UTIL1_ScanHex8uNumber(const unsigned char **str, byte *val)
1745:../Generated_Code/UTIL1.c **** {
 3372              		.loc 1 1745 0
 3373              		.cfi_startproc
 3374              	.LVL426:
 3375 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 3376              	.LCFI51:
 3377              		.cfi_def_cfa_offset 32
 3378              		.cfi_offset 0, -32
 3379              		.cfi_offset 1, -28
 3380              		.cfi_offset 2, -24
 3381              		.cfi_offset 4, -20
 3382              		.cfi_offset 5, -16
 3383              		.cfi_offset 6, -12
 3384              		.cfi_offset 7, -8
 3385              		.cfi_offset 14, -4
1746:../Generated_Code/UTIL1.c ****   /* scans a decimal number, and stops at any non-number. Number can have any preceding zeros or sp
1747:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = 2+1; /* maximum number of digits to avoid overflow */
1748:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 3386              		.loc 1 1748 0
 3387 0002 0368     		ldr	r3, [r0]
1745:../Generated_Code/UTIL1.c **** {
 3388              		.loc 1 1745 0
 3389 0004 061C     		mov	r6, r0
1749:../Generated_Code/UTIL1.c ****   byte v;
1750:../Generated_Code/UTIL1.c **** 
1751:../Generated_Code/UTIL1.c ****   if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
 3390              		.loc 1 1751 0
 3391 0006 01A8     		add	r0, sp, #4
 3392              	.LVL427:
1745:../Generated_Code/UTIL1.c **** {
 3393              		.loc 1 1745 0
 3394 0008 0D1C     		mov	r5, r1
1748:../Generated_Code/UTIL1.c ****   const unsigned char *p = *str;
 3395              		.loc 1 1748 0
 3396 000a 0193     		str	r3, [sp, #4]
 3397              	.LVL428:
 3398              		.loc 1 1751 0
 3399 000c FFF7FEFF 		bl	PreScanHexNumber
 3400              	.LVL429:
1752:../Generated_Code/UTIL1.c ****     return ERR_FAILED;
 3401              		.loc 1 1752 0
 3402 0010 1B21     		mov	r1, #27
1751:../Generated_Code/UTIL1.c ****   if (PreScanHexNumber(&p)!=ERR_OK) { /* skip leading spaces, and scan '0x' */
 3403              		.loc 1 1751 0
 3404 0012 0028     		cmp	r0, #0
 3405 0014 1BD1     		bne	.L322
1753:../Generated_Code/UTIL1.c ****   }
1754:../Generated_Code/UTIL1.c ****   *val = 0;
 3406              		.loc 1 1754 0
 3407 0016 2870     		strb	r0, [r5]
1747:../Generated_Code/UTIL1.c ****   uint8_t nofDigits = 2+1; /* maximum number of digits to avoid overflow */
 3408              		.loc 1 1747 0
 3409 0018 0324     		mov	r4, #3
 3410              	.LVL430:
 3411              	.L323:
1755:../Generated_Code/UTIL1.c ****   while (HexToDec(&p, &v)==ERR_OK && nofDigits > 0) {
 3412              		.loc 1 1755 0
 3413 001a 6F46     		mov	r7, sp
 3414              	.LVL431:
 3415 001c 0337     		add	r7, r7, #3
 3416 001e 01A8     		add	r0, sp, #4
 3417 0020 391C     		mov	r1, r7
 3418 0022 FFF7FEFF 		bl	HexToDec
 3419              	.LVL432:
 3420 0026 0028     		cmp	r0, #0
 3421 0028 0BD1     		bne	.L324
 3422              		.loc 1 1755 0 is_stmt 0
 3423 002a 002C     		cmp	r4, #0
 3424 002c 07D0     		beq	.L329
 3425              	.L325:
1756:../Generated_Code/UTIL1.c ****     *val = (uint8_t)((*val)*16 + v);
 3426              		.loc 1 1756 0 is_stmt 1
 3427 002e 2A78     		ldrb	r2, [r5]
 3428              	.LVL433:
 3429 0030 3F78     		ldrb	r7, [r7]
 3430              	.LVL434:
 3431 0032 1301     		lsl	r3, r2, #4
 3432 0034 D819     		add	r0, r3, r7
 3433              	.LVL435:
1757:../Generated_Code/UTIL1.c ****     nofDigits--;
 3434              		.loc 1 1757 0
 3435 0036 013C     		sub	r4, r4, #1
 3436              	.LVL436:
1756:../Generated_Code/UTIL1.c ****     *val = (uint8_t)((*val)*16 + v);
 3437              		.loc 1 1756 0
 3438 0038 2870     		strb	r0, [r5]
 3439              		.loc 1 1757 0
 3440 003a E4B2     		uxtb	r4, r4
 3441              	.LVL437:
 3442 003c EDE7     		b	.L323
 3443              	.LVL438:
 3444              	.L329:
1758:../Generated_Code/UTIL1.c ****   } /* while */
1759:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
1760:../Generated_Code/UTIL1.c ****     return ERR_OVERFLOW;
 3445              		.loc 1 1760 0
 3446 003e 0421     		mov	r1, #4
 3447 0040 05E0     		b	.L322
 3448              	.L324:
 3449 0042 0421     		mov	r1, #4
1759:../Generated_Code/UTIL1.c ****   if (nofDigits==0) {
 3450              		.loc 1 1759 0
 3451 0044 002C     		cmp	r4, #0
 3452 0046 02D0     		beq	.L322
1761:../Generated_Code/UTIL1.c ****   }
1762:../Generated_Code/UTIL1.c ****   *str = p;
 3453              		.loc 1 1762 0
 3454 0048 0198     		ldr	r0, [sp, #4]
1763:../Generated_Code/UTIL1.c ****   return ERR_OK;
 3455              		.loc 1 1763 0
 3456 004a 0021     		mov	r1, #0
1762:../Generated_Code/UTIL1.c ****   *str = p;
 3457              		.loc 1 1762 0
 3458 004c 3060     		str	r0, [r6]
 3459              	.LVL439:
 3460              	.L322:
1764:../Generated_Code/UTIL1.c **** }
 3461              		.loc 1 1764 0
 3462 004e 081C     		mov	r0, r1
 3463              		@ sp needed for prologue
 3464              	.LVL440:
 3465              	.LVL441:
 3466 0050 FEBD     		pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 3467              		.cfi_endproc
 3468              	.LFE41:
 3470              		.section	.text.UTIL1_strtailcmp,"ax",%progbits
 3471              		.align	1
 3472              		.global	UTIL1_strtailcmp
 3473              		.code	16
 3474              		.thumb_func
 3476              	UTIL1_strtailcmp:
 3477              	.LFB42:
1765:../Generated_Code/UTIL1.c **** 
1766:../Generated_Code/UTIL1.c **** /*
1767:../Generated_Code/UTIL1.c **** ** ===================================================================
1768:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strtailcmp (component Utility)
1769:../Generated_Code/UTIL1.c **** **     Description :
1770:../Generated_Code/UTIL1.c **** **         Compares the tail of a string and returns 0 if it matches, 1
1771:../Generated_Code/UTIL1.c **** **         otherwise
1772:../Generated_Code/UTIL1.c **** **     Parameters  :
1773:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1774:../Generated_Code/UTIL1.c **** **       * str             - Pointer to string. This string is compared
1775:../Generated_Code/UTIL1.c **** **                           if it contains the tail.
1776:../Generated_Code/UTIL1.c **** **       * tail            - Pointer to tail string.
1777:../Generated_Code/UTIL1.c **** **     Returns     :
1778:../Generated_Code/UTIL1.c **** **         ---             - returns 0 if tail matches, -1 otherwise
1779:../Generated_Code/UTIL1.c **** ** ===================================================================
1780:../Generated_Code/UTIL1.c **** */
1781:../Generated_Code/UTIL1.c **** byte UTIL1_strtailcmp(byte *str, byte *tail)
1782:../Generated_Code/UTIL1.c **** {
 3478              		.loc 1 1782 0
 3479              		.cfi_startproc
 3480              	.LVL442:
 3481 0000 70B5     		push	{r4, r5, r6, lr}
 3482              	.LCFI52:
 3483              		.cfi_def_cfa_offset 16
 3484              		.cfi_offset 4, -16
 3485              		.cfi_offset 5, -12
 3486              		.cfi_offset 6, -8
 3487              		.cfi_offset 14, -4
 3488              		.loc 1 1782 0
 3489 0002 0C1C     		mov	r4, r1
 3490 0004 051C     		mov	r5, r0
1783:../Generated_Code/UTIL1.c ****   int i, j;
1784:../Generated_Code/UTIL1.c **** 
1785:../Generated_Code/UTIL1.c ****   i = (int)UTIL1_strlen((char*)str);
 3491              		.loc 1 1785 0
 3492 0006 FFF7FEFF 		bl	strlen
 3493              	.LVL443:
 3494 000a 061C     		mov	r6, r0
 3495              	.LVL444:
1786:../Generated_Code/UTIL1.c ****   j = (int)UTIL1_strlen((char*)tail);
 3496              		.loc 1 1786 0
 3497 000c 201C     		mov	r0, r4
 3498              	.LVL445:
 3499 000e FFF7FEFF 		bl	strlen
 3500              	.LVL446:
1787:../Generated_Code/UTIL1.c ****   if (j>i) { /* str is smaller than tail */
1788:../Generated_Code/UTIL1.c ****     return 1; /* cannot match */
 3501              		.loc 1 1788 0
 3502 0012 0121     		mov	r1, #1
1786:../Generated_Code/UTIL1.c ****   j = (int)UTIL1_strlen((char*)tail);
 3503              		.loc 1 1786 0
 3504 0014 031E     		sub	r3, r0, #0
 3505              	.LVL447:
1787:../Generated_Code/UTIL1.c ****   if (j>i) { /* str is smaller than tail */
 3506              		.loc 1 1787 0
 3507 0016 B342     		cmp	r3, r6
 3508 0018 0ADC     		bgt	.L331
 3509              	.LVL448:
 3510              	.L337:
1781:../Generated_Code/UTIL1.c **** byte UTIL1_strtailcmp(byte *str, byte *tail)
 3511              		.loc 1 1781 0
 3512 001a 321A     		sub	r2, r6, r0
 3513 001c A918     		add	r1, r5, r2
1789:../Generated_Code/UTIL1.c ****   }
1790:../Generated_Code/UTIL1.c ****   /* compare strings */
1791:../Generated_Code/UTIL1.c ****   while(str[i]==tail[j]) {
 3514              		.loc 1 1791 0
 3515 001e C95C     		ldrb	r1, [r1, r3]
 3516 0020 E25C     		ldrb	r2, [r4, r3]
 3517 0022 9142     		cmp	r1, r2
 3518 0024 03D1     		bne	.L338
 3519              	.L334:
 3520              	.LVL449:
1792:../Generated_Code/UTIL1.c ****     i--;
1793:../Generated_Code/UTIL1.c ****     j--;
1794:../Generated_Code/UTIL1.c ****     if (j<0) {
 3521              		.loc 1 1794 0
 3522 0026 013B     		sub	r3, r3, #1
 3523 0028 F7D5     		bpl	.L337
 3524              	.LVL450:
 3525              	.L336:
1795:../Generated_Code/UTIL1.c ****       return 0; /* match */
 3526              		.loc 1 1795 0
 3527 002a 0021     		mov	r1, #0
 3528 002c 00E0     		b	.L331
 3529              	.L338:
1788:../Generated_Code/UTIL1.c ****     return 1; /* cannot match */
 3530              		.loc 1 1788 0
 3531 002e 0121     		mov	r1, #1
 3532              	.L331:
1796:../Generated_Code/UTIL1.c ****     }
1797:../Generated_Code/UTIL1.c ****   }
1798:../Generated_Code/UTIL1.c ****   return 1; /* !=0 means no match */
1799:../Generated_Code/UTIL1.c **** }
 3533              		.loc 1 1799 0
 3534 0030 081C     		mov	r0, r1
 3535              		@ sp needed for prologue
 3536              	.LVL451:
 3537              	.LVL452:
 3538 0032 70BD     		pop	{r4, r5, r6, pc}
 3539              		.cfi_endproc
 3540              	.LFE42:
 3542              		.section	.text.UTIL1_strCutTail,"ax",%progbits
 3543              		.align	1
 3544              		.global	UTIL1_strCutTail
 3545              		.code	16
 3546              		.thumb_func
 3548              	UTIL1_strCutTail:
 3549              	.LFB43:
1800:../Generated_Code/UTIL1.c **** 
1801:../Generated_Code/UTIL1.c **** /*
1802:../Generated_Code/UTIL1.c **** ** ===================================================================
1803:../Generated_Code/UTIL1.c **** **     Method      :  UTIL1_strCutTail (component Utility)
1804:../Generated_Code/UTIL1.c **** **     Description :
1805:../Generated_Code/UTIL1.c **** **         Removes a tailing substring from a string. The string passed
1806:../Generated_Code/UTIL1.c **** **         will be modified (the tail is cut by writing a zero byte to
1807:../Generated_Code/UTIL1.c **** **         the string!)
1808:../Generated_Code/UTIL1.c **** **     Parameters  :
1809:../Generated_Code/UTIL1.c **** **         NAME            - DESCRIPTION
1810:../Generated_Code/UTIL1.c **** **       * str             - Pointer to string where to remove the tail
1811:../Generated_Code/UTIL1.c **** **       * tail            - Pointer to substring to remove
1812:../Generated_Code/UTIL1.c **** **     Returns     :
1813:../Generated_Code/UTIL1.c **** **         ---             - Error code, ERR_OK if no error, otherwise
1814:../Generated_Code/UTIL1.c **** **                           ERR_FAIL if tail is not found
1815:../Generated_Code/UTIL1.c **** ** ===================================================================
1816:../Generated_Code/UTIL1.c **** */
1817:../Generated_Code/UTIL1.c **** byte UTIL1_strCutTail(byte *str, byte *tail)
1818:../Generated_Code/UTIL1.c **** {
 3550              		.loc 1 1818 0
 3551              		.cfi_startproc
 3552              	.LVL453:
 3553 0000 70B5     		push	{r4, r5, r6, lr}
 3554              	.LCFI53:
 3555              		.cfi_def_cfa_offset 16
 3556              		.cfi_offset 4, -16
 3557              		.cfi_offset 5, -12
 3558              		.cfi_offset 6, -8
 3559              		.cfi_offset 14, -4
 3560              		.loc 1 1818 0
 3561 0002 051C     		mov	r5, r0
 3562 0004 0E1C     		mov	r6, r1
1819:../Generated_Code/UTIL1.c ****   /* cut the tail from the string */
1820:../Generated_Code/UTIL1.c ****   size_t strLen, tailLen;
1821:../Generated_Code/UTIL1.c **** 
1822:../Generated_Code/UTIL1.c ****   if (UTIL1_strtailcmp(str, tail)!=0) { /* check if tail is present */
 3563              		.loc 1 1822 0
 3564 0006 FFF7FEFF 		bl	UTIL1_strtailcmp
 3565              	.LVL454:
 3566 000a 041C     		mov	r4, r0
1823:../Generated_Code/UTIL1.c ****     return ERR_FAILED; /* tail not found */
 3567              		.loc 1 1823 0
 3568 000c 1B20     		mov	r0, #27
1822:../Generated_Code/UTIL1.c ****   if (UTIL1_strtailcmp(str, tail)!=0) { /* check if tail is present */
 3569              		.loc 1 1822 0
 3570 000e 002C     		cmp	r4, #0
 3571 0010 09D1     		bne	.L340
1824:../Generated_Code/UTIL1.c ****   }
1825:../Generated_Code/UTIL1.c ****   tailLen = UTIL1_strlen((char*)tail);
 3572              		.loc 1 1825 0
 3573 0012 301C     		mov	r0, r6
 3574 0014 FFF7FEFF 		bl	strlen
 3575              	.LVL455:
 3576 0018 061C     		mov	r6, r0
 3577              	.LVL456:
1826:../Generated_Code/UTIL1.c ****   strLen = UTIL1_strlen((char*)str);
 3578              		.loc 1 1826 0
 3579 001a 281C     		mov	r0, r5
 3580              	.LVL457:
 3581 001c FFF7FEFF 		bl	strlen
 3582              	.LVL458:
1827:../Generated_Code/UTIL1.c ****   /* write \0 to cut the tail */
1828:../Generated_Code/UTIL1.c ****   str[strLen-tailLen] = '\0';
 3583              		.loc 1 1828 0
 3584 0020 801B     		sub	r0, r0, r6
 3585              	.LVL459:
 3586 0022 2C54     		strb	r4, [r5, r0]
1829:../Generated_Code/UTIL1.c ****   return ERR_OK;
 3587              		.loc 1 1829 0
 3588 0024 201C     		mov	r0, r4
 3589              	.LVL460:
 3590              	.L340:
1830:../Generated_Code/UTIL1.c **** }
 3591              		.loc 1 1830 0
 3592              		@ sp needed for prologue
 3593              	.LVL461:
 3594 0026 70BD     		pop	{r4, r5, r6, pc}
 3595              		.cfi_endproc
 3596              	.LFE43:
 3598              		.section	.rodata.skew.6095,"a",%progbits
 3599              		.set	.LANCHOR0,. + 0
 3602              	skew.6095:
 3603 0000 00       		.byte	0
 3604 0001 03       		.byte	3
 3605 0002 03       		.byte	3
 3606 0003 06       		.byte	6
 3607 0004 01       		.byte	1
 3608 0005 04       		.byte	4
 3609 0006 06       		.byte	6
 3610 0007 02       		.byte	2
 3611 0008 05       		.byte	5
 3612 0009 00       		.byte	0
 3613 000a 03       		.byte	3
 3614 000b 05       		.byte	5
 3615              		.section	.rodata.str1.1,"aMS",%progbits,1
 3616              	.LC3:
 3617 0000 00       		.ascii	"\000"
 3618              		.text
 3619              	.Letext0:
 3620              		.file 2 "C:/Freescale/CW MCU v10.6/MCU/ARM_GCC_Support/ewl/EWL_C/include/cstdint"
 3621              		.file 3 "../Generated_Code/PE_Types.h"
 3622              		.file 4 "C:/Freescale/CW MCU v10.6/MCU/ARM_GCC_Support/ewl/EWL_C/include/size_t.h"
DEFINED SYMBOLS
                            *ABS*:00000000 UTIL1.c
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:18     .text.ShiftRightAndFill:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:22     .text.ShiftRightAndFill:00000000 ShiftRightAndFill
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:120    .text.PreScanHexNumber:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:124    .text.PreScanHexNumber:00000000 PreScanHexNumber
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:176    .text.HexToDec:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:180    .text.HexToDec:00000000 HexToDec
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:246    .text.UTIL1_strcpy:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:251    .text.UTIL1_strcpy:00000000 UTIL1_strcpy
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:294    .text.UTIL1_strcat:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:299    .text.UTIL1_strcat:00000000 UTIL1_strcat
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:360    .text.UTIL1_chcat:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:365    .text.UTIL1_chcat:00000000 UTIL1_chcat
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:413    .text.UTIL1_Num16uToStr:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:418    .text.UTIL1_Num16uToStr:00000000 UTIL1_Num16uToStr
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:557    .text.UTIL1_Num8uToStr:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:562    .text.UTIL1_Num8uToStr:00000000 UTIL1_Num8uToStr
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:584    .text.UTIL1_Num16sToStr:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:589    .text.UTIL1_Num16sToStr:00000000 UTIL1_Num16sToStr
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:755    .text.UTIL1_Num8sToStr:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:760    .text.UTIL1_Num8sToStr:00000000 UTIL1_Num8sToStr
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:780    .text.UTIL1_Num16sToStrFormatted:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:785    .text.UTIL1_Num16sToStrFormatted:00000000 UTIL1_Num16sToStrFormatted
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:820    .text.UTIL1_Num16uToStrFormatted:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:825    .text.UTIL1_Num16uToStrFormatted:00000000 UTIL1_Num16uToStrFormatted
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:860    .text.UTIL1_strcatNum8u:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:865    .text.UTIL1_strcatNum8u:00000000 UTIL1_strcatNum8u
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:910    .text.UTIL1_strcatNum8s:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:915    .text.UTIL1_strcatNum8s:00000000 UTIL1_strcatNum8s
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:960    .text.UTIL1_strcatNum16u:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:965    .text.UTIL1_strcatNum16u:00000000 UTIL1_strcatNum16u
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1004   .text.UTIL1_strcatNum16s:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1009   .text.UTIL1_strcatNum16s:00000000 UTIL1_strcatNum16s
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1048   .text.UTIL1_strcatNum16uFormatted:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1053   .text.UTIL1_strcatNum16uFormatted:00000000 UTIL1_strcatNum16uFormatted
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1096   .text.UTIL1_strcatNum16sFormatted:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1101   .text.UTIL1_strcatNum16sFormatted:00000000 UTIL1_strcatNum16sFormatted
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1144   .text.UTIL1_strcatNum8Hex:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1149   .text.UTIL1_strcatNum8Hex:00000000 UTIL1_strcatNum8Hex
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1209   .text.UTIL1_strcatNum16Hex:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1214   .text.UTIL1_strcatNum16Hex:00000000 UTIL1_strcatNum16Hex
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1271   .text.UTIL1_strcatNum24Hex:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1276   .text.UTIL1_strcatNum24Hex:00000000 UTIL1_strcatNum24Hex
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1334   .text.UTIL1_strcatNum32Hex:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1339   .text.UTIL1_strcatNum32Hex:00000000 UTIL1_strcatNum32Hex
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1402   .text.UTIL1_Num32sToStr:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1407   .text.UTIL1_Num32sToStr:00000000 UTIL1_Num32sToStr
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1571   .text.UTIL1_strcatNum32s:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1576   .text.UTIL1_strcatNum32s:00000000 UTIL1_strcatNum32s
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1616   .text.UTIL1_Num32sToStrFormatted:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1621   .text.UTIL1_Num32sToStrFormatted:00000000 UTIL1_Num32sToStrFormatted
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1656   .text.UTIL1_strcatNum32sFormatted:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1661   .text.UTIL1_strcatNum32sFormatted:00000000 UTIL1_strcatNum32sFormatted
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1704   .text.UTIL1_Num32uToStr:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1709   .text.UTIL1_Num32uToStr:00000000 UTIL1_Num32uToStr
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1848   .text.UTIL1_strcatNum32u:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1853   .text.UTIL1_strcatNum32u:00000000 UTIL1_strcatNum32u
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1893   .text.UTIL1_Num32uToStrFormatted:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1898   .text.UTIL1_Num32uToStrFormatted:00000000 UTIL1_Num32uToStrFormatted
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1933   .text.UTIL1_strcatNum32uFormatted:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1938   .text.UTIL1_strcatNum32uFormatted:00000000 UTIL1_strcatNum32uFormatted
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1981   .text.UTIL1_IsLeapYear:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:1986   .text.UTIL1_IsLeapYear:00000000 UTIL1_IsLeapYear
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:2027   .text.UTIL1_WeekDay:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:2032   .text.UTIL1_WeekDay:00000000 UTIL1_WeekDay
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:2120   .text.UTIL1_WeekDay:00000050 $d
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:2126   .text.UTIL1_ReadEscapedName:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:2131   .text.UTIL1_ReadEscapedName:00000000 UTIL1_ReadEscapedName
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:2343   .text.UTIL1_ReadEscapedName:000000d0 $d
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:2348   .text.UTIL1_xatoi:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:2353   .text.UTIL1_xatoi:00000000 UTIL1_xatoi
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:2551   .text.UTIL1_ScanDecimal16uNumber:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:2556   .text.UTIL1_ScanDecimal16uNumber:00000000 UTIL1_ScanDecimal16uNumber
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:2644   .text.UTIL1_ScanDecimal8uNumber:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:2649   .text.UTIL1_ScanDecimal8uNumber:00000000 UTIL1_ScanDecimal8uNumber
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:2737   .text.UTIL1_ScanTime:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:2742   .text.UTIL1_ScanTime:00000000 UTIL1_ScanTime
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:2908   .text.UTIL1_ScanDate:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:2913   .text.UTIL1_ScanDate:00000000 UTIL1_ScanDate
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:3056   .text.UTIL1_ScanDate:0000009c $d
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:3061   .text.UTIL1_ScanDecimal32uNumber:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:3066   .text.UTIL1_ScanDecimal32uNumber:00000000 UTIL1_ScanDecimal32uNumber
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:3154   .text.UTIL1_ScanHex32uNumber:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:3159   .text.UTIL1_ScanHex32uNumber:00000000 UTIL1_ScanHex32uNumber
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:3259   .text.UTIL1_ScanHex16uNumber:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:3264   .text.UTIL1_ScanHex16uNumber:00000000 UTIL1_ScanHex16uNumber
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:3365   .text.UTIL1_ScanHex8uNumber:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:3370   .text.UTIL1_ScanHex8uNumber:00000000 UTIL1_ScanHex8uNumber
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:3471   .text.UTIL1_strtailcmp:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:3476   .text.UTIL1_strtailcmp:00000000 UTIL1_strtailcmp
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:3543   .text.UTIL1_strCutTail:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:3548   .text.UTIL1_strCutTail:00000000 UTIL1_strCutTail
C:\Users\Franco\AppData\Local\Temp\cc027bDr.s:3602   .rodata.skew.6095:00000000 skew.6095
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_uidivmod
__aeabi_uidiv
__aeabi_idivmod
__aeabi_idiv
strchr
strlen
