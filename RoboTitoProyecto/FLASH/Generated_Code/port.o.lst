   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 4
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"port.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.pxPortInitialiseStack,"ax",%progbits
  18              		.align	1
  19              		.global	pxPortInitialiseStack
  20              		.code	16
  21              		.thumb_func
  23              	pxPortInitialiseStack:
  24              	.LFB0:
  25              		.file 1 "../Generated_Code/port.c"
   1:../Generated_Code/port.c **** /*
   2:../Generated_Code/port.c ****     FreeRTOS V7.2.0 - Copyright (C) 2012 Real Time Engineers Ltd.
   3:../Generated_Code/port.c **** 
   4:../Generated_Code/port.c **** 
   5:../Generated_Code/port.c ****     ***************************************************************************
   6:../Generated_Code/port.c ****      *                                                                       *
   7:../Generated_Code/port.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../Generated_Code/port.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../Generated_Code/port.c ****      *    available.                                                         *
  10:../Generated_Code/port.c ****      *                                                                       *
  11:../Generated_Code/port.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../Generated_Code/port.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../Generated_Code/port.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../Generated_Code/port.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../Generated_Code/port.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../Generated_Code/port.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../Generated_Code/port.c ****      *                                                                       *
  18:../Generated_Code/port.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../Generated_Code/port.c ****      *                                                                       *
  20:../Generated_Code/port.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../Generated_Code/port.c ****      *                                                                       *
  22:../Generated_Code/port.c ****     ***************************************************************************
  23:../Generated_Code/port.c **** 
  24:../Generated_Code/port.c **** 
  25:../Generated_Code/port.c ****     This file is part of the FreeRTOS distribution.
  26:../Generated_Code/port.c **** 
  27:../Generated_Code/port.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../Generated_Code/port.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../Generated_Code/port.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../Generated_Code/port.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../Generated_Code/port.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../Generated_Code/port.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../Generated_Code/port.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../Generated_Code/port.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../Generated_Code/port.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../Generated_Code/port.c ****     more details. You should have received a copy of the GNU General Public
  37:../Generated_Code/port.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../Generated_Code/port.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../Generated_Code/port.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../Generated_Code/port.c ****     FreeRTOS WEB site.
  41:../Generated_Code/port.c **** 
  42:../Generated_Code/port.c ****     1 tab == 4 spaces!
  43:../Generated_Code/port.c **** 
  44:../Generated_Code/port.c ****     ***************************************************************************
  45:../Generated_Code/port.c ****      *                                                                       *
  46:../Generated_Code/port.c ****      *    Having a problem?  Start by reading the FAQ "My application does   *
  47:../Generated_Code/port.c ****      *    not run, what could be wrong?                                      *
  48:../Generated_Code/port.c ****      *                                                                       *
  49:../Generated_Code/port.c ****      *    http://www.FreeRTOS.org/FAQHelp.html                               *
  50:../Generated_Code/port.c ****      *                                                                       *
  51:../Generated_Code/port.c ****     ***************************************************************************
  52:../Generated_Code/port.c **** 
  53:../Generated_Code/port.c **** 
  54:../Generated_Code/port.c ****     http://www.FreeRTOS.org - Documentation, training, latest information,
  55:../Generated_Code/port.c ****     license and contact details.
  56:../Generated_Code/port.c **** 
  57:../Generated_Code/port.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  58:../Generated_Code/port.c ****     including FreeRTOS+Trace - an indispensable productivity tool.
  59:../Generated_Code/port.c **** 
  60:../Generated_Code/port.c ****     Real Time Engineers ltd license FreeRTOS to High Integrity Systems, who sell
  61:../Generated_Code/port.c ****     the code with commercial support, indemnification, and middleware, under
  62:../Generated_Code/port.c ****     the OpenRTOS brand: http://www.OpenRTOS.com.  High Integrity Systems also
  63:../Generated_Code/port.c ****     provide a safety engineered and independently SIL3 certified version under
  64:../Generated_Code/port.c ****     the SafeRTOS brand: http://www.SafeRTOS.com.
  65:../Generated_Code/port.c **** */
  66:../Generated_Code/port.c **** 
  67:../Generated_Code/port.c **** /* include inherited beans */
  68:../Generated_Code/port.c **** #include "UTIL1.h"
  69:../Generated_Code/port.c **** #include "RTOSTICKLDD1.h"
  70:../Generated_Code/port.c **** 
  71:../Generated_Code/port.c **** /* Kernel includes. */
  72:../Generated_Code/port.c **** #include "FreeRTOS.h"
  73:../Generated_Code/port.c **** #include "task.h"
  74:../Generated_Code/port.c **** 
  75:../Generated_Code/port.c **** /* Constants required to manipulate the NVIC. */
  76:../Generated_Code/port.c **** #define portNVIC_INT_CTRL        ((volatile unsigned long*)0xe000ed04) /* interrupt control and sta
  77:../Generated_Code/port.c **** #define portNVIC_SYSPRI3         ((volatile unsigned long*)0xe000ed20) /* system handler priority r
  78:../Generated_Code/port.c **** #define portNVIC_PENDSVSET       0x10000000 /* bit 28 in portNVIC_INT_CTRL (PENDSVSET), see http://
  79:../Generated_Code/port.c **** #define portNVIC_PENDSV_PRI      (((unsigned long)configKERNEL_INTERRUPT_PRIORITY)<<16) /* priority
  80:../Generated_Code/port.c **** #define portNVIC_SYSTICK_PRI     (((unsigned long)configKERNEL_INTERRUPT_PRIORITY)<<24) /* priority
  81:../Generated_Code/port.c **** 
  82:../Generated_Code/port.c **** /* Constants required to set up the initial stack. */
  83:../Generated_Code/port.c **** #define portINITIAL_XPSR         (0x01000000)
  84:../Generated_Code/port.c **** #define portINITIAL_EXEC_RETURN  (0xfffffffd)
  85:../Generated_Code/port.c **** static LDD_TDeviceData *RTOS_TickDevice;
  86:../Generated_Code/port.c **** /* Used to keep track of the number of nested calls to taskENTER_CRITICAL().
  87:../Generated_Code/port.c ****    This will be set to 0 prior to the first task being started. */
  88:../Generated_Code/port.c **** /* Each task maintains its own interrupt status in the critical nesting variable. */
  89:../Generated_Code/port.c **** static unsigned portBASE_TYPE uxCriticalNesting = 0xaaaaaaaa;
  90:../Generated_Code/port.c **** 
  91:../Generated_Code/port.c **** /*-----------------------------------------------------------*/
  92:../Generated_Code/port.c **** portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE * pxTopOfStack, pdTASK_CODE pxCode, void *pvP
  26              		.loc 1 92 0
  27              		.cfi_startproc
  28              	.LVL0:
  29 0000 10B5     		push	{r4, lr}
  30              	.LCFI0:
  31              		.cfi_def_cfa_offset 8
  32              		.cfi_offset 4, -8
  33              		.cfi_offset 14, -4
  93:../Generated_Code/port.c ****   /* Simulate the stack frame as it would be created by a context switch interrupt. */
  94:../Generated_Code/port.c ****   pxTopOfStack--;
  95:../Generated_Code/port.c ****   *pxTopOfStack = portINITIAL_XPSR;   /* xPSR */
  34              		.loc 1 95 0
  35 0002 8024     		mov	r4, #128
  36 0004 031F     		sub	r3, r0, #4
  37              	.LVL1:
  38 0006 6404     		lsl	r4, r4, #17
  39 0008 1C60     		str	r4, [r3]
  40              	.LVL2:
  96:../Generated_Code/port.c ****   pxTopOfStack--;
  97:../Generated_Code/port.c ****   *pxTopOfStack = (portSTACK_TYPE)pxCode;  /* PC */
  41              		.loc 1 97 0
  42 000a 043B     		sub	r3, r3, #4
  43 000c 1960     		str	r1, [r3]
  44              	.LVL3:
  98:../Generated_Code/port.c ****   pxTopOfStack--;
  99:../Generated_Code/port.c ****   *pxTopOfStack = 0;  /* LR */
  45              		.loc 1 99 0
  46 000e 043B     		sub	r3, r3, #4
  47 0010 0021     		mov	r1, #0
  48              	.LVL4:
  49 0012 1960     		str	r1, [r3]
  50              	.LVL5:
 100:../Generated_Code/port.c **** 
 101:../Generated_Code/port.c ****   /* Save code space by skipping register initialization. */
 102:../Generated_Code/port.c ****   pxTopOfStack -= 5;  /* R12, R3, R2 and R1. */
 103:../Generated_Code/port.c ****   *pxTopOfStack = (portSTACK_TYPE)pvParameters; /* R0 */
  51              		.loc 1 103 0
  52 0014 143B     		sub	r3, r3, #20
  53              	.LVL6:
 104:../Generated_Code/port.c **** 
 105:../Generated_Code/port.c ****   pxTopOfStack -= 8;  /* R11, R10, R9, R8, R7, R6, R5 and R4. */
 106:../Generated_Code/port.c ****   return pxTopOfStack;
  54              		.loc 1 106 0
  55 0016 4038     		sub	r0, r0, #64
  56              	.LVL7:
 103:../Generated_Code/port.c ****   *pxTopOfStack = (portSTACK_TYPE)pvParameters; /* R0 */
  57              		.loc 1 103 0
  58 0018 1A60     		str	r2, [r3]
  59              	.LVL8:
 107:../Generated_Code/port.c **** }
  60              		.loc 1 107 0
  61              		@ sp needed for prologue
  62 001a 10BD     		pop	{r4, pc}
  63              		.cfi_endproc
  64              	.LFE0:
  66              		.section	.text.vPortEnterCritical,"ax",%progbits
  67              		.align	1
  68              		.global	vPortEnterCritical
  69              		.code	16
  70              		.thumb_func
  72              	vPortEnterCritical:
  73              	.LFB2:
 108:../Generated_Code/port.c **** /*-----------------------------------------------------------*/
 109:../Generated_Code/port.c **** portBASE_TYPE xPortStartScheduler(void) {
 110:../Generated_Code/port.c ****   /* Make PendSV and SysTick the lowest priority interrupts. */
 111:../Generated_Code/port.c ****   /* Overwrite PendSV priority as set inside the CPU component: it needs to have the lowest priorit
 112:../Generated_Code/port.c ****   *(portNVIC_SYSPRI3) |= portNVIC_PENDSV_PRI; /* set priority of PendSV interrupt */
 113:../Generated_Code/port.c ****   uxCriticalNesting = 0; /* Initialize the critical nesting count ready for the first task. */
 114:../Generated_Code/port.c ****   RTOS_TickDevice = RTOSTICKLDD1_Init(NULL); /* initialize the tick timer */
 115:../Generated_Code/port.c ****   /* overwrite SysTick priority is set inside the FreeRTOS component */
 116:../Generated_Code/port.c ****   *(portNVIC_SYSPRI3) |= portNVIC_SYSTICK_PRI; /* set priority of SysTick interrupt */
 117:../Generated_Code/port.c ****   /* Start the timer that generates the tick ISR. Interrupts are disabled here already. */
 118:../Generated_Code/port.c ****   (void)RTOSTICKLDD1_Enable(RTOS_TickDevice); /* start the tick timer */
 119:../Generated_Code/port.c ****   vPortStartFirstTask(); /* Start the first task. */
 120:../Generated_Code/port.c ****   /* Should not get here, unless you call vTaskEndScheduler()! */
 121:../Generated_Code/port.c ****   return pdFALSE;
 122:../Generated_Code/port.c **** }
 123:../Generated_Code/port.c **** /*-----------------------------------------------------------*/
 124:../Generated_Code/port.c **** void vPortEnterCritical(void) {
  74              		.loc 1 124 0
  75              		.cfi_startproc
 125:../Generated_Code/port.c **** /*
 126:../Generated_Code/port.c ****  * Disable interrupts before incrementing the count of critical section nesting.
 127:../Generated_Code/port.c ****  * The nesting count is maintained so we know when interrupts should be
 128:../Generated_Code/port.c ****  * re-enabled.  Once interrupts are disabled the nesting count can be accessed
 129:../Generated_Code/port.c ****  * directly.  Each task maintains its own nesting count.
 130:../Generated_Code/port.c ****  */
 131:../Generated_Code/port.c ****   portDISABLE_INTERRUPTS();
  76              		.loc 1 131 0
  77              	@ 131 "../Generated_Code/port.c" 1
  78 0000 5020     		  mov r0, #80 
  79 0002 80F31188 	  msr basepri, r0 
  80              	
  81              	@ 0 "" 2
 132:../Generated_Code/port.c ****   uxCriticalNesting++;
  82              		.loc 1 132 0
  83              		.code	16
  84 0006 024B     		ldr	r3, .L3
 133:../Generated_Code/port.c **** }
  85              		.loc 1 133 0
  86              		@ sp needed for prologue
 132:../Generated_Code/port.c ****   uxCriticalNesting++;
  87              		.loc 1 132 0
  88 0008 1A68     		ldr	r2, [r3]
  89 000a 0132     		add	r2, r2, #1
  90 000c 1A60     		str	r2, [r3]
  91              		.loc 1 133 0
  92 000e 7047     		bx	lr
  93              	.L4:
  94              		.align	2
  95              	.L3:
  96 0010 00000000 		.word	.LANCHOR0
  97              		.cfi_endproc
  98              	.LFE2:
 100              		.section	.text.vPortExitCritical,"ax",%progbits
 101              		.align	1
 102              		.global	vPortExitCritical
 103              		.code	16
 104              		.thumb_func
 106              	vPortExitCritical:
 107              	.LFB3:
 134:../Generated_Code/port.c **** /*-----------------------------------------------------------*/
 135:../Generated_Code/port.c **** void vPortExitCritical(void) {
 108              		.loc 1 135 0
 109              		.cfi_startproc
 136:../Generated_Code/port.c ****  /* Interrupts are disabled so we can access the nesting count directly.  If the
 137:../Generated_Code/port.c ****   * nesting is found to be 0 (no nesting) then we are leaving the critical
 138:../Generated_Code/port.c ****   * section and interrupts can be re-enabled.
 139:../Generated_Code/port.c ****   */
 140:../Generated_Code/port.c ****   uxCriticalNesting--;
 110              		.loc 1 140 0
 111 0000 054A     		ldr	r2, .L8
 135:../Generated_Code/port.c **** void vPortExitCritical(void) {
 112              		.loc 1 135 0
 113 0002 00B5     		push	{lr}
 114              	.LCFI1:
 115              		.cfi_def_cfa_offset 4
 116              		.cfi_offset 14, -4
 117              		.loc 1 140 0
 118 0004 1368     		ldr	r3, [r2]
 119 0006 013B     		sub	r3, r3, #1
 120 0008 1360     		str	r3, [r2]
 141:../Generated_Code/port.c ****   if (uxCriticalNesting == 0)  {
 121              		.loc 1 141 0
 122 000a 002B     		cmp	r3, #0
 123 000c 02D1     		bne	.L5
 142:../Generated_Code/port.c ****     portENABLE_INTERRUPTS();
 124              		.loc 1 142 0
 125              	@ 142 "../Generated_Code/port.c" 1
 126 000e 0020     		  mov r0, #0      
 127 0010 80F31188 	  msr basepri, r0 
 128              	
 129              	@ 0 "" 2
 130              		.code	16
 131              	.L5:
 143:../Generated_Code/port.c ****   }
 144:../Generated_Code/port.c **** }
 132              		.loc 1 144 0
 133              		@ sp needed for prologue
 134 0014 00BD     		pop	{pc}
 135              	.L9:
 136 0016 C046     		.align	2
 137              	.L8:
 138 0018 00000000 		.word	.LANCHOR0
 139              		.cfi_endproc
 140              	.LFE3:
 142              		.section	.text.vPortYieldFromISR,"ax",%progbits
 143              		.align	1
 144              		.global	vPortYieldFromISR
 145              		.code	16
 146              		.thumb_func
 148              	vPortYieldFromISR:
 149              	.LFB4:
 145:../Generated_Code/port.c **** /*-----------------------------------------------------------*/
 146:../Generated_Code/port.c **** void vPortYieldFromISR(void) {
 150              		.loc 1 146 0
 151              		.cfi_startproc
 147:../Generated_Code/port.c ****   /* Set a PendSV to request a context switch. */
 148:../Generated_Code/port.c ****   *(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 152              		.loc 1 148 0
 153 0000 8022     		mov	r2, #128
 154 0002 024B     		ldr	r3, .L11
 155 0004 5005     		lsl	r0, r2, #21
 156 0006 1860     		str	r0, [r3]
 149:../Generated_Code/port.c **** }
 157              		.loc 1 149 0
 158              		@ sp needed for prologue
 159 0008 7047     		bx	lr
 160              	.L12:
 161 000a C046     		.align	2
 162              	.L11:
 163 000c 04ED00E0 		.word	-536810236
 164              		.cfi_endproc
 165              	.LFE4:
 167              		.section	.text.uxGetTickCounterValue,"ax",%progbits
 168              		.align	1
 169              		.global	uxGetTickCounterValue
 170              		.code	16
 171              		.thumb_func
 173              	uxGetTickCounterValue:
 174              	.LFB5:
 150:../Generated_Code/port.c **** /*-----------------------------------------------------------*/
 151:../Generated_Code/port.c **** 
 152:../Generated_Code/port.c **** /* return the tick raw counter value. It is assumed that the counter register has been reset at the
 153:../Generated_Code/port.c **** portLONG uxGetTickCounterValue(void) {
 175              		.loc 1 153 0
 176              		.cfi_startproc
 177 0000 08B5     		push	{r3, lr}
 178              	.LCFI2:
 179              		.cfi_def_cfa_offset 8
 180              		.cfi_offset 3, -8
 181              		.cfi_offset 14, -4
 154:../Generated_Code/port.c ****   return (portLONG)RTOSTICKLDD1_GetCounterValue(RTOS_TickDevice);
 182              		.loc 1 154 0
 183 0002 024B     		ldr	r3, .L14
 155:../Generated_Code/port.c **** }
 184              		.loc 1 155 0
 185              		@ sp needed for prologue
 154:../Generated_Code/port.c ****   return (portLONG)RTOSTICKLDD1_GetCounterValue(RTOS_TickDevice);
 186              		.loc 1 154 0
 187 0004 1868     		ldr	r0, [r3]
 188 0006 FFF7FEFF 		bl	RTOSTICKLDD1_GetCounterValue
 189              	.LVL9:
 190              		.loc 1 155 0
 191 000a 08BD     		pop	{r3, pc}
 192              	.L15:
 193              		.align	2
 194              	.L14:
 195 000c 00000000 		.word	.LANCHOR1
 196              		.cfi_endproc
 197              	.LFE5:
 199              		.section	.text.vOnCounterRestart,"ax",%progbits
 200              		.align	1
 201              		.global	vOnCounterRestart
 202              		.code	16
 203              		.thumb_func
 205              	vOnCounterRestart:
 206              	.LFB6:
 156:../Generated_Code/port.c **** /*-----------------------------------------------------------*/
 157:../Generated_Code/port.c **** __attribute__ ((naked)) void vOnCounterRestart(void) {
 207              		.loc 1 157 0
 208              		.cfi_startproc
 158:../Generated_Code/port.c **** #if FREERTOS_CPU_CORTEX_M==4 /* Cortex M4 */
 159:../Generated_Code/port.c ****   #if __OPTIMIZE_SIZE__ || __OPTIMIZE__
 160:../Generated_Code/port.c ****     /*
 161:../Generated_Code/port.c ****               RTOSTICKLDD1_Interrupt:
 162:../Generated_Code/port.c ****     249       {
 163:../Generated_Code/port.c ****     0000102c:   cpy r0,sp
 164:../Generated_Code/port.c ****     0000102e:   bic r1,r0,#0x7
 165:../Generated_Code/port.c ****     00001032:   cpy sp,r1
 166:../Generated_Code/port.c ****     00001034:   push {r0,lr}  <===
 167:../Generated_Code/port.c ****     ...
 168:../Generated_Code/port.c ****     00001046:   bl RTOSTICKLDD1_OnCounterRestart (0x90c); 0x0000090c
 169:../Generated_Code/port.c ****     ....
 170:../Generated_Code/port.c ****     */
 171:../Generated_Code/port.c ****     /* nothing needed, as SP and LR are already on the stack */
 172:../Generated_Code/port.c ****   #else
 173:../Generated_Code/port.c ****   /* Code in RTOSTICKLDD1_Interrupt():
 174:../Generated_Code/port.c ****    0:	4668      	mov	r0, sp
 175:../Generated_Code/port.c ****    2:	f020 0107 	bic.w	r1, r0, #7
 176:../Generated_Code/port.c ****    6:	468d      	mov	sp, r1
 177:../Generated_Code/port.c ****    8:	b581      	push	{r0, r7, lr}   <=============
 178:../Generated_Code/port.c ****    a:	b083      	sub	sp, #12        <=============
 179:../Generated_Code/port.c ****    c:	af00      	add	r7, sp, #0
 180:../Generated_Code/port.c ****   ...
 181:../Generated_Code/port.c ****   38:	f7ff fffe 	bl	0 <RTOSTICKLDD1_OnCounterRestart>
 182:../Generated_Code/port.c ****   3c:	f107 070c 	add.w	r7, r7, #12     <============
 183:../Generated_Code/port.c ****   40:	46bd      	mov	sp, r7
 184:../Generated_Code/port.c ****   42:	e8bd 4081 	ldmia.w	sp!, {r0, r7, lr} <===========
 185:../Generated_Code/port.c ****   46:	4685      	mov	sp, r0
 186:../Generated_Code/port.c ****   48:	4770      	bx	lr
 187:../Generated_Code/port.c ****   */
 188:../Generated_Code/port.c ****   __asm volatile (
 189:../Generated_Code/port.c ****     " add sp,sp,#12   \n" /* remove space allocated in RTOSTICKLDD1_Interrupt() */
 190:../Generated_Code/port.c ****     " pop {r0,r7,lr}  \n" /* these were pushed in RTOSTICKLDD1_Interrupt() */
 191:../Generated_Code/port.c ****     " push {r4,lr}    \n"
 192:../Generated_Code/port.c ****   );
 193:../Generated_Code/port.c ****   #endif
 194:../Generated_Code/port.c **** #else /* Cortex M0+ */
 195:../Generated_Code/port.c ****   #if __OPTIMIZE_SIZE__ || __OPTIMIZE__
 196:../Generated_Code/port.c ****   /*
 197:../Generated_Code/port.c **** PE_ISR(RTOSTICKLDD1_Interrupt)
 198:../Generated_Code/port.c **** {
 199:../Generated_Code/port.c ****    0:	b508      	push	{r3, lr}  <<================
 200:../Generated_Code/port.c ****     RTOSTICKLDD1_TDeviceDataPtr DeviceDataPrv = INT_SysTick__BAREBOARD_RTOS_ISRPARAM;
 201:../Generated_Code/port.c ****    2:	4b05      	ldr	r3, [pc, #20]	; (18 <RTOSTICKLDD1_Interrupt+0x18>)
 202:../Generated_Code/port.c ****   SysTick_PDD_ClearInterruptFlag(SysTick_BASE_PTR); // Clear interrupt flag
 203:../Generated_Code/port.c ****    4:	4905      	ldr	r1, [pc, #20]	; (1c <RTOSTICKLDD1_Interrupt+0x1c>)
 204:../Generated_Code/port.c ****   RTOSTICKLDD1_TDeviceDataPtr DeviceDataPrv = INT_SysTick__BAREBOARD_RTOS_ISRPARAM;
 205:../Generated_Code/port.c ****    6:	681a      	ldr	r2, [r3, #0]
 206:../Generated_Code/port.c ****   SysTick_PDD_ClearInterruptFlag(SysTick_BASE_PTR); // Clear interrupt flag
 207:../Generated_Code/port.c ****    8:	4b05      	ldr	r3, [pc, #20]	; (20 <RTOSTICKLDD1_Interrupt+0x20>)
 208:../Generated_Code/port.c ****    a:	6818      	ldr	r0, [r3, #0]
 209:../Generated_Code/port.c ****    c:	4001      	ands	r1, r0
 210:../Generated_Code/port.c ****    e:	6019      	str	r1, [r3, #0]
 211:../Generated_Code/port.c ****   RTOSTICKLDD1_OnCounterRestart(DeviceDataPrv->UserDataPtr); // Invoke OnCounterRestart event
 212:../Generated_Code/port.c ****   10:	6810      	ldr	r0, [r2, #0]
 213:../Generated_Code/port.c ****   12:	f7ff fffe 	bl	0 <RTOSTICKLDD1_OnCounterRestart>
 214:../Generated_Code/port.c ****    */
 215:../Generated_Code/port.c ****   /* nothing needed, as r3 and LR are already on the stack */
 216:../Generated_Code/port.c ****   #else
 217:../Generated_Code/port.c ****   /*
 218:../Generated_Code/port.c ****     //PE_ISR(RTOSTICKLDD1_Interrupt):
 219:../Generated_Code/port.c ****      0:	b580      	push	{r7, lr} <<===================
 220:../Generated_Code/port.c ****      2:	b082      	sub	sp, #8      <<====================
 221:../Generated_Code/port.c ****      4:	af00      	add	r7, sp, #0
 222:../Generated_Code/port.c ****     RTOSTICKLDD1_TDeviceDataPtr DeviceDataPrv = INT_SysTick__BAREBOARD_RTOS_ISRPARAM;
 223:../Generated_Code/port.c ****      6:	4b09      	ldr	r3, [pc, #36]	; (2c <RTOSTICKLDD1_Interrupt+0x2c>)
 224:../Generated_Code/port.c ****      8:	681b      	ldr	r3, [r3, #0]
 225:../Generated_Code/port.c ****      a:	607b      	str	r3, [r7, #4]
 226:../Generated_Code/port.c **** 
 227:../Generated_Code/port.c ****     SysTick_PDD_ClearInterruptFlag(SysTick_BASE_PTR); // Clear interrupt flag
 228:../Generated_Code/port.c ****      c:	4b08      	ldr	r3, [pc, #32]	; (30 <RTOSTICKLDD1_Interrupt+0x30>)
 229:../Generated_Code/port.c ****      e:	4a08      	ldr	r2, [pc, #32]	; (30 <RTOSTICKLDD1_Interrupt+0x30>)
 230:../Generated_Code/port.c ****     10:	6812      	ldr	r2, [r2, #0]
 231:../Generated_Code/port.c ****     12:	1c11      	adds	r1, r2, #0
 232:../Generated_Code/port.c ****     14:	4a07      	ldr	r2, [pc, #28]	; (34 <RTOSTICKLDD1_Interrupt+0x34>)
 233:../Generated_Code/port.c ****     16:	400a      	ands	r2, r1
 234:../Generated_Code/port.c ****     18:	601a      	str	r2, [r3, #0]
 235:../Generated_Code/port.c ****     RTOSTICKLDD1_OnCounterRestart(DeviceDataPrv->UserDataPtr); // Invoke OnCounterRestart event
 236:../Generated_Code/port.c ****     1a:	687b      	ldr	r3, [r7, #4]
 237:../Generated_Code/port.c ****     1c:	681b      	ldr	r3, [r3, #0]
 238:../Generated_Code/port.c ****     1e:	1c18      	adds	r0, r3, #0
 239:../Generated_Code/port.c ****     20:	f7ff fffe 	bl	0 <RTOSTICKLDD1_OnCounterRestart>
 240:../Generated_Code/port.c ****    */
 241:../Generated_Code/port.c ****   __asm volatile (
 242:../Generated_Code/port.c ****     " add sp,#8       \n" /* remove space allocated in RTOSTICKLDD1_Interrupt() */
 243:../Generated_Code/port.c ****     " pop {r0, r7}    \n" /* restore r7 and lr into r0 and r7, which were pushed in RTOSTICKLDD1_In
 244:../Generated_Code/port.c ****     " push {r0, r7}   \n"
 245:../Generated_Code/port.c ****   );
 246:../Generated_Code/port.c ****   #endif
 247:../Generated_Code/port.c **** #endif
 248:../Generated_Code/port.c ****   /* If using preemption, also force a context switch. */
 249:../Generated_Code/port.c ****   #if configUSE_PREEMPTION == 1
 250:../Generated_Code/port.c ****   *(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 209              		.loc 1 250 0
 210 0000 8022     		mov	r2, #128
 211 0002 064B     		ldr	r3, .L17
 212 0004 5005     		lsl	r0, r2, #21
 213 0006 1860     		str	r0, [r3]
 251:../Generated_Code/port.c ****   #endif
 252:../Generated_Code/port.c ****   portSET_INTERRUPT_MASK();   /* disable interrupts */
 214              		.loc 1 252 0
 215              	@ 252 "../Generated_Code/port.c" 1
 216 0008 5020     		  mov r0, #80 
 217 000a 80F31188 	  msr basepri, r0 
 218              	
 219              	@ 0 "" 2
 253:../Generated_Code/port.c ****   vTaskIncrementTick(); /* increment tick count, might schedule a task */
 220              		.loc 1 253 0
 221              		.code	16
 222 000e FFF7FEFF 		bl	vTaskIncrementTick
 223              	.LVL10:
 254:../Generated_Code/port.c ****   portCLEAR_INTERRUPT_MASK(); /* enable interrupts again */
 224              		.loc 1 254 0
 225              	@ 254 "../Generated_Code/port.c" 1
 226 0012 0020     		  mov r0, #0      
 227 0014 80F31188 	  msr basepri, r0 
 228              	
 229              	@ 0 "" 2
 255:../Generated_Code/port.c **** #if FREERTOS_CPU_CORTEX_M==4 /* Cortex M4 */
 256:../Generated_Code/port.c ****   #if __OPTIMIZE_SIZE__ || __OPTIMIZE__
 257:../Generated_Code/port.c ****   __asm volatile (
 258:../Generated_Code/port.c ****     " pop {r0,lr}  \n" /* start exit sequence from interrupt: sp and lr where pushed */
 259:../Generated_Code/port.c ****     " mov sp, r0   \n"
 260:../Generated_Code/port.c ****     " bx lr        \n"
 261:../Generated_Code/port.c ****     " nop          \n"
 262:../Generated_Code/port.c ****   );
 263:../Generated_Code/port.c ****   #else
 264:../Generated_Code/port.c ****   __asm volatile (
 265:../Generated_Code/port.c ****     " pop {r4,lr}  \n" /* start exit sequence from interrupt: r4 and lr where pushed above */
 266:../Generated_Code/port.c ****     " bx lr        \n"
 267:../Generated_Code/port.c ****     " nop          \n"
 268:../Generated_Code/port.c ****   );
 269:../Generated_Code/port.c ****   #endif
 270:../Generated_Code/port.c **** #else /* Cortex M0+ */
 271:../Generated_Code/port.c **** #if __OPTIMIZE_SIZE__ || __OPTIMIZE__
 272:../Generated_Code/port.c ****   __asm volatile (
 230              		.loc 1 272 0
 231              	@ 272 "../Generated_Code/port.c" 1
 232 0018 08BD     		 pop {r3,pc}                
 233              	
 234              	@ 0 "" 2
 273:../Generated_Code/port.c ****     " pop {r3,pc}                \n" /* start exit sequence from interrupt: r3 and lr where pushed 
 274:../Generated_Code/port.c ****   );
 275:../Generated_Code/port.c **** #else
 276:../Generated_Code/port.c ****   __asm volatile (
 277:../Generated_Code/port.c ****     " pop {r7,pc}                \n" /* start exit sequence from interrupt: r7 and lr where pushed 
 278:../Generated_Code/port.c ****   );
 279:../Generated_Code/port.c **** #endif
 280:../Generated_Code/port.c **** #endif
 281:../Generated_Code/port.c **** }
 235              		.loc 1 281 0
 236              		.code	16
 237              	.L18:
 238 001a C046     		.align	2
 239              	.L17:
 240 001c 04ED00E0 		.word	-536810236
 241              		.cfi_endproc
 242              	.LFE6:
 244              		.section	.text.vPortStartFirstTask,"ax",%progbits
 245              		.align	1
 246              		.global	vPortStartFirstTask
 247              		.code	16
 248              		.thumb_func
 250              	vPortStartFirstTask:
 251              	.LFB7:
 282:../Generated_Code/port.c **** /*-----------------------------------------------------------*/
 283:../Generated_Code/port.c **** void vPortStartFirstTask(void) {
 252              		.loc 1 283 0
 253              		.cfi_startproc
 284:../Generated_Code/port.c **** #if FREERTOS_CPU_CORTEX_M==4 /* Cortex M4 */
 285:../Generated_Code/port.c ****   __asm volatile (
 286:../Generated_Code/port.c ****     " ldr r0, =0xE000ED08 \n" /* Use the NVIC offset register to locate the stack. */
 287:../Generated_Code/port.c ****     " ldr r0, [r0]        \n"
 288:../Generated_Code/port.c ****     " ldr r0, [r0]        \n"
 289:../Generated_Code/port.c ****     " msr msp, r0         \n" /* Set the msp back to the start of the stack. */
 290:../Generated_Code/port.c ****     " cpsie i             \n" /* Globally enable interrupts. */
 291:../Generated_Code/port.c ****     " svc 0               \n" /* System call to start first task. */
 292:../Generated_Code/port.c ****     " nop                 \n"
 293:../Generated_Code/port.c ****   );
 294:../Generated_Code/port.c **** #else /* Cortex M0+ */
 295:../Generated_Code/port.c ****   __asm volatile(
 254              		.loc 1 295 0
 255              	@ 295 "../Generated_Code/port.c" 1
 256 0000 0020     		 movs r0, #0x00      
 257 0002 0068     	 ldr r0, [r0]        
 258 0004 80F30888 	 msr msp, r0         
 259 0008 62B6     	 cpsie i             
 260 000a 00DF     	 svc 0               
 261 000c C046     	 nop                 
 262              	
 263              	@ 0 "" 2
 296:../Generated_Code/port.c ****     " movs r0, #0x00      \n" /* Locate the top of stack. */
 297:../Generated_Code/port.c ****     " ldr r0, [r0]        \n"
 298:../Generated_Code/port.c ****     " msr msp, r0         \n" /* Set the msp back to the start of the stack. */
 299:../Generated_Code/port.c ****     " cpsie i             \n" /* Globally enable interrupts. */
 300:../Generated_Code/port.c ****     " svc 0               \n" /* System call to start first task. */
 301:../Generated_Code/port.c ****     " nop                 \n"
 302:../Generated_Code/port.c ****   );
 303:../Generated_Code/port.c **** #endif
 304:../Generated_Code/port.c **** }
 264              		.loc 1 304 0
 265              		.code	16
 266              		@ sp needed for prologue
 267 000e 7047     		bx	lr
 268              		.cfi_endproc
 269              	.LFE7:
 271              		.section	.text.xPortStartScheduler,"ax",%progbits
 272              		.align	1
 273              		.global	xPortStartScheduler
 274              		.code	16
 275              		.thumb_func
 277              	xPortStartScheduler:
 278              	.LFB1:
 109:../Generated_Code/port.c **** portBASE_TYPE xPortStartScheduler(void) {
 279              		.loc 1 109 0
 280              		.cfi_startproc
 281 0000 38B5     		push	{r3, r4, r5, lr}
 282              	.LCFI3:
 283              		.cfi_def_cfa_offset 16
 284              		.cfi_offset 3, -16
 285              		.cfi_offset 4, -12
 286              		.cfi_offset 5, -8
 287              		.cfi_offset 14, -4
 112:../Generated_Code/port.c ****   *(portNVIC_SYSPRI3) |= portNVIC_PENDSV_PRI; /* set priority of PendSV interrupt */
 288              		.loc 1 112 0
 289 0002 0C4C     		ldr	r4, .L21
 290 0004 F023     		mov	r3, #240
 291 0006 2268     		ldr	r2, [r4]
 292 0008 1804     		lsl	r0, r3, #16
 113:../Generated_Code/port.c ****   uxCriticalNesting = 0; /* Initialize the critical nesting count ready for the first task. */
 293              		.loc 1 113 0
 294 000a 0025     		mov	r5, #0
 112:../Generated_Code/port.c ****   *(portNVIC_SYSPRI3) |= portNVIC_PENDSV_PRI; /* set priority of PendSV interrupt */
 295              		.loc 1 112 0
 296 000c 1043     		orr	r0, r2
 113:../Generated_Code/port.c ****   uxCriticalNesting = 0; /* Initialize the critical nesting count ready for the first task. */
 297              		.loc 1 113 0
 298 000e 0A49     		ldr	r1, .L21+4
 112:../Generated_Code/port.c ****   *(portNVIC_SYSPRI3) |= portNVIC_PENDSV_PRI; /* set priority of PendSV interrupt */
 299              		.loc 1 112 0
 300 0010 2060     		str	r0, [r4]
 114:../Generated_Code/port.c ****   RTOS_TickDevice = RTOSTICKLDD1_Init(NULL); /* initialize the tick timer */
 301              		.loc 1 114 0
 302 0012 281C     		mov	r0, r5
 113:../Generated_Code/port.c ****   uxCriticalNesting = 0; /* Initialize the critical nesting count ready for the first task. */
 303              		.loc 1 113 0
 304 0014 0D60     		str	r5, [r1]
 114:../Generated_Code/port.c ****   RTOS_TickDevice = RTOSTICKLDD1_Init(NULL); /* initialize the tick timer */
 305              		.loc 1 114 0
 306 0016 FFF7FEFF 		bl	RTOSTICKLDD1_Init
 307              	.LVL11:
 308 001a 084A     		ldr	r2, .L21+8
 116:../Generated_Code/port.c ****   *(portNVIC_SYSPRI3) |= portNVIC_SYSTICK_PRI; /* set priority of SysTick interrupt */
 309              		.loc 1 116 0
 310 001c 2168     		ldr	r1, [r4]
 311 001e F023     		mov	r3, #240
 114:../Generated_Code/port.c ****   RTOS_TickDevice = RTOSTICKLDD1_Init(NULL); /* initialize the tick timer */
 312              		.loc 1 114 0
 313 0020 1060     		str	r0, [r2]
 116:../Generated_Code/port.c ****   *(portNVIC_SYSPRI3) |= portNVIC_SYSTICK_PRI; /* set priority of SysTick interrupt */
 314              		.loc 1 116 0
 315 0022 1A06     		lsl	r2, r3, #24
 316 0024 0A43     		orr	r2, r1
 317 0026 2260     		str	r2, [r4]
 118:../Generated_Code/port.c ****   (void)RTOSTICKLDD1_Enable(RTOS_TickDevice); /* start the tick timer */
 318              		.loc 1 118 0
 319 0028 FFF7FEFF 		bl	RTOSTICKLDD1_Enable
 320              	.LVL12:
 122:../Generated_Code/port.c **** }
 321              		.loc 1 122 0
 322              		@ sp needed for prologue
 119:../Generated_Code/port.c ****   vPortStartFirstTask(); /* Start the first task. */
 323              		.loc 1 119 0
 324 002c FFF7FEFF 		bl	vPortStartFirstTask
 325              	.LVL13:
 122:../Generated_Code/port.c **** }
 326              		.loc 1 122 0
 327 0030 281C     		mov	r0, r5
 328 0032 38BD     		pop	{r3, r4, r5, pc}
 329              	.L22:
 330              		.align	2
 331              	.L21:
 332 0034 20ED00E0 		.word	-536810208
 333 0038 00000000 		.word	.LANCHOR0
 334 003c 00000000 		.word	.LANCHOR1
 335              		.cfi_endproc
 336              	.LFE1:
 338              		.section	.text.vPortSVCHandler,"ax",%progbits
 339              		.align	1
 340              		.global	vPortSVCHandler
 341              		.code	16
 342              		.thumb_func
 344              	vPortSVCHandler:
 345              	.LFB8:
 305:../Generated_Code/port.c **** /*-----------------------------------------------------------*/
 306:../Generated_Code/port.c **** __attribute__ ((naked)) void vPortSVCHandler(void) {
 346              		.loc 1 306 0
 347              		.cfi_startproc
 307:../Generated_Code/port.c **** #if FREERTOS_CPU_CORTEX_M==4 /* Cortex M4 */
 308:../Generated_Code/port.c **** __asm volatile (
 309:../Generated_Code/port.c ****     " ldr r3, pxCurrentTCBConst2 \n" /* Restore the context. */
 310:../Generated_Code/port.c ****     " ldr r1, [r3]               \n" /* Use pxCurrentTCBConst to get the pxCurrentTCB address. */
 311:../Generated_Code/port.c ****     " ldr r0, [r1]               \n" /* The first item in pxCurrentTCB is the task top of stack. */
 312:../Generated_Code/port.c ****     /* pop the core registers */
 313:../Generated_Code/port.c ****     " ldmia r0!, {r4-r11}        \n"
 314:../Generated_Code/port.c ****     " msr psp, r0                \n"
 315:../Generated_Code/port.c ****     " mov r0, #0                 \n"
 316:../Generated_Code/port.c ****     " msr basepri, r0            \n"
 317:../Generated_Code/port.c ****     " orr r14, r14, #13          \n"
 318:../Generated_Code/port.c ****     " bx r14                     \n"
 319:../Generated_Code/port.c ****     "                            \n"
 320:../Generated_Code/port.c ****     " .align 2                   \n"
 321:../Generated_Code/port.c ****     "pxCurrentTCBConst2: .word pxCurrentTCB \n"
 322:../Generated_Code/port.c ****   );
 323:../Generated_Code/port.c **** #else /* Cortex M0+ */
 324:../Generated_Code/port.c ****   __asm volatile (
 348              		.loc 1 324 0
 349              	@ 324 "../Generated_Code/port.c" 1
 350 0000 084B     		 ldr r3, pxCurrentTCBConst2 
 351 0002 1968     	 ldr r1, [r3]               
 352 0004 0868     	 ldr r0, [r1]               
 353 0006 1030     	 add r0, r0, #16            
 354 0008 F0C8     	 ldmia r0!, {r4-r7}         
 355 000a A046     	 mov r8, r4                 
 356 000c A946     	 mov r9, r5                 
 357 000e B246     	 mov r10, r6                
 358 0010 BB46     	 mov r11, r7                
 359              	                            
 360 0012 80F30988 	 msr psp, r0                
 361              	                            
 362 0016 2038     	 sub r0, r0, #32            
 363 0018 F0C8     	 ldmia r0!, {r4-r7}         
 364 001a 7146     	 mov r1, r14                
 365 001c 0D20     	 movs r0, #0x0d             
 366 001e 0143     	 orr r1, r0                 
 367 0020 0847     	 bx r1                      
 368              	                            
 369 0022 C046     	.align 2                    
 370 0024 00000000 	pxCurrentTCBConst2: .word pxCurrentTCB 
 371              	
 372              	@ 0 "" 2
 325:../Generated_Code/port.c ****     " ldr r3, pxCurrentTCBConst2 \n" /* Restore the context. */
 326:../Generated_Code/port.c ****     " ldr r1, [r3]               \n" /* Use pxCurrentTCBConst to get the pxCurrentTCB address. */
 327:../Generated_Code/port.c ****     " ldr r0, [r1]               \n" /* The first item in pxCurrentTCB is the task top of stack. */
 328:../Generated_Code/port.c ****     " add r0, r0, #16            \n" /* Move to the high registers. */
 329:../Generated_Code/port.c ****     " ldmia r0!, {r4-r7}         \n" /* Pop the high registers. */
 330:../Generated_Code/port.c ****     " mov r8, r4                 \n"
 331:../Generated_Code/port.c ****     " mov r9, r5                 \n"
 332:../Generated_Code/port.c ****     " mov r10, r6                \n"
 333:../Generated_Code/port.c ****     " mov r11, r7                \n"
 334:../Generated_Code/port.c ****     "                            \n"
 335:../Generated_Code/port.c ****     " msr psp, r0                \n" /* Remember the new top of stack for the task. */
 336:../Generated_Code/port.c ****     "                            \n"
 337:../Generated_Code/port.c ****     " sub r0, r0, #32            \n" /* Go back for the low registers that are not automatically re
 338:../Generated_Code/port.c ****     " ldmia r0!, {r4-r7}         \n" /* Pop low registers.  */
 339:../Generated_Code/port.c ****     " mov r1, r14                \n" /* OR R14 with 0x0d. */
 340:../Generated_Code/port.c ****     " movs r0, #0x0d             \n"
 341:../Generated_Code/port.c ****     " orr r1, r0                 \n"
 342:../Generated_Code/port.c ****     " bx r1                      \n"
 343:../Generated_Code/port.c ****     "                            \n"
 344:../Generated_Code/port.c ****     ".align 2                    \n"
 345:../Generated_Code/port.c ****     "pxCurrentTCBConst2: .word pxCurrentTCB \n"
 346:../Generated_Code/port.c ****   );
 347:../Generated_Code/port.c **** #endif
 348:../Generated_Code/port.c **** }
 373              		.loc 1 348 0
 374              		.code	16
 375              		.cfi_endproc
 376              	.LFE8:
 378              		.section	.text.vPortPendSVHandler,"ax",%progbits
 379              		.align	1
 380              		.global	vPortPendSVHandler
 381              		.code	16
 382              		.thumb_func
 384              	vPortPendSVHandler:
 385              	.LFB9:
 349:../Generated_Code/port.c **** /*-----------------------------------------------------------*/
 350:../Generated_Code/port.c **** __attribute__ ((naked)) void vPortPendSVHandler(void) {
 386              		.loc 1 350 0
 387              		.cfi_startproc
 351:../Generated_Code/port.c **** #if FREERTOS_CPU_CORTEX_M==4 /* Cortex M4 */
 352:../Generated_Code/port.c ****   __asm volatile (
 353:../Generated_Code/port.c ****     " mrs r0, psp                \n"
 354:../Generated_Code/port.c ****     " ldr  r3, pxCurrentTCBConst \n" /* Get the location of the current TCB. */
 355:../Generated_Code/port.c ****     " ldr  r2, [r3]              \n"
 356:../Generated_Code/port.c ****     " stmdb r0!, {r4-r11}        \n" /* Save the core registers. */
 357:../Generated_Code/port.c ****     " str r0, [r2]               \n" /* Save the new top of stack into the first member of the TCB.
 358:../Generated_Code/port.c ****     " stmdb sp!, {r3, r14}       \n"
 359:../Generated_Code/port.c ****     " mov r0, %0                 \n"
 360:../Generated_Code/port.c ****     " msr basepri, r0            \n"
 361:../Generated_Code/port.c ****     " bl vTaskSwitchContext      \n"
 362:../Generated_Code/port.c ****     " mov r0, #0                 \n"
 363:../Generated_Code/port.c ****     " msr basepri, r0            \n"
 364:../Generated_Code/port.c ****     " ldmia sp!, {r3, r14}       \n"
 365:../Generated_Code/port.c ****     " ldr r1, [r3]               \n" /* The first item in pxCurrentTCB is the task top of stack. */
 366:../Generated_Code/port.c ****     " ldr r0, [r1]               \n"
 367:../Generated_Code/port.c ****     " ldmia r0!, {r4-r11}        \n" /* Pop the core registers. */
 368:../Generated_Code/port.c ****     " msr psp, r0                \n"
 369:../Generated_Code/port.c ****     " bx r14                     \n"
 370:../Generated_Code/port.c ****     "                            \n"
 371:../Generated_Code/port.c ****     " .align 2                   \n"
 372:../Generated_Code/port.c ****     "pxCurrentTCBConst: .word pxCurrentTCB  \n"
 373:../Generated_Code/port.c ****     ::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
 374:../Generated_Code/port.c ****   );
 375:../Generated_Code/port.c **** #else /* Cortex M0+ */
 376:../Generated_Code/port.c ****   __asm volatile (
 388              		.loc 1 376 0
 389              	@ 376 "../Generated_Code/port.c" 1
 390 0000 EFF30980 		 mrs r0, psp                
 391              	                            
 392 0004 0E4B     	 ldr r3, pxCurrentTCBConst  
 393 0006 1A68     	 ldr r2, [r3]   
 394              	                            
 395 0008 2038     	 sub r0, r0, #32            
 396 000a 1060     	 str r0, [r2]               
 397 000c F0C0     	 stmia r0!, {r4-r7}         
 398 000e 4446     	 mov r4, r8                 
 399 0010 4D46     	 mov r5, r9                 
 400 0012 5646     	 mov r6, r10                
 401 0014 5F46     	 mov r7, r11                
 402 0016 F0C0     	 stmia r0!, {r4-r7}         
 403              	                            
 404 0018 08B5     	 push {r3, r14}             
 405 001a 72B6     	 cpsid i                    
 406 001c FFF7FEFF 	 bl vTaskSwitchContext      
 407 0020 62B6     	 cpsie i                    
 408 0022 0CBC     	 pop {r2, r3}               
 409              	                            
 410 0024 1168     	 ldr r1, [r2]               
 411 0026 0868     	 ldr r0, [r1]               
 412 0028 1030     	 add r0, r0, #16            
 413 002a F0C8     	 ldmia r0!, {r4-r7}         
 414 002c A046     	 mov r8, r4                 
 415 002e A946     	 mov r9, r5                 
 416 0030 B246     	 mov r10, r6                
 417 0032 BB46     	 mov r11, r7                
 418              	                            
 419 0034 80F30988 	 msr psp, r0                
 420              	                            
 421 0038 2038     	 sub r0, r0, #32            
 422 003a F0C8     	 ldmia r0!, {r4-r7}         
 423              	                            
 424 003c 1847     	 bx r3	                     
 425              	                            
 426 003e C046     	.align 2                    
 427 0040 00000000 	pxCurrentTCBConst: .word pxCurrentTCB
 428              	@ 0 "" 2
 377:../Generated_Code/port.c ****     " mrs r0, psp                \n"
 378:../Generated_Code/port.c ****     "                            \n"
 379:../Generated_Code/port.c ****     " ldr r3, pxCurrentTCBConst  \n" /* Get the location of the current TCB. */
 380:../Generated_Code/port.c ****     " ldr r2, [r3]   \n"
 381:../Generated_Code/port.c ****     "                            \n"
 382:../Generated_Code/port.c ****     " sub r0, r0, #32            \n" /* Make space for the remaining low registers. */
 383:../Generated_Code/port.c ****     " str r0, [r2]               \n" /* Save the new top of stack. */
 384:../Generated_Code/port.c ****     " stmia r0!, {r4-r7}         \n" /* Store the low registers that are not saved automatically. *
 385:../Generated_Code/port.c ****     " mov r4, r8                 \n" /* Store the high registers. */
 386:../Generated_Code/port.c ****     " mov r5, r9                 \n"
 387:../Generated_Code/port.c ****     " mov r6, r10                \n"
 388:../Generated_Code/port.c ****     " mov r7, r11                \n"
 389:../Generated_Code/port.c ****     " stmia r0!, {r4-r7}         \n"
 390:../Generated_Code/port.c ****     "                            \n"
 391:../Generated_Code/port.c ****     " push {r3, r14}             \n"
 392:../Generated_Code/port.c ****     " cpsid i                    \n"
 393:../Generated_Code/port.c ****     " bl vTaskSwitchContext      \n"
 394:../Generated_Code/port.c ****     " cpsie i                    \n"
 395:../Generated_Code/port.c ****     " pop {r2, r3}               \n" /* lr goes in r3. r2 now holds tcb pointer. */
 396:../Generated_Code/port.c ****     "                            \n"
 397:../Generated_Code/port.c ****     " ldr r1, [r2]               \n"
 398:../Generated_Code/port.c ****     " ldr r0, [r1]               \n" /* The first item in pxCurrentTCB is the task top of stack. */
 399:../Generated_Code/port.c ****     " add r0, r0, #16            \n" /* Move to the high registers. */
 400:../Generated_Code/port.c ****     " ldmia r0!, {r4-r7}         \n" /* Pop the high registers. */
 401:../Generated_Code/port.c ****     " mov r8, r4                 \n"
 402:../Generated_Code/port.c ****     " mov r9, r5                 \n"
 403:../Generated_Code/port.c ****     " mov r10, r6                \n"
 404:../Generated_Code/port.c ****     " mov r11, r7                \n"
 405:../Generated_Code/port.c ****     "                            \n"
 406:../Generated_Code/port.c ****     " msr psp, r0                \n" /* Remember the new top of stack for the task. */
 407:../Generated_Code/port.c ****     "                            \n"
 408:../Generated_Code/port.c ****     " sub r0, r0, #32            \n" /* Go back for the low registers that are not automatically re
 409:../Generated_Code/port.c ****     " ldmia r0!, {r4-r7}         \n" /* Pop low registers.  */
 410:../Generated_Code/port.c ****     "                            \n"
 411:../Generated_Code/port.c ****     " bx r3	                     \n"
 412:../Generated_Code/port.c ****     "                            \n"
 413:../Generated_Code/port.c ****     ".align 2                    \n"
 414:../Generated_Code/port.c ****     "pxCurrentTCBConst: .word pxCurrentTCB"
 415:../Generated_Code/port.c ****   );
 416:../Generated_Code/port.c **** #endif
 417:../Generated_Code/port.c **** }
 429              		.loc 1 417 0
 430              		.code	16
 431              		.cfi_endproc
 432              	.LFE9:
 434              		.section	.bss.RTOS_TickDevice,"aw",%nobits
 435              		.align	2
 436              		.set	.LANCHOR1,. + 0
 439              	RTOS_TickDevice:
 440 0000 00000000 		.space	4
 441              		.section	.data.uxCriticalNesting,"aw",%progbits
 442              		.align	2
 443              		.set	.LANCHOR0,. + 0
 446              	uxCriticalNesting:
 447 0000 AAAAAAAA 		.word	-1431655766
 448              		.text
 449              	.Letext0:
 450              		.file 2 "../Generated_Code/PE_Types.h"
 451              		.file 3 "../Generated_Code/projdefs.h"
DEFINED SYMBOLS
                            *ABS*:00000000 port.c
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:18     .text.pxPortInitialiseStack:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:23     .text.pxPortInitialiseStack:00000000 pxPortInitialiseStack
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:67     .text.vPortEnterCritical:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:72     .text.vPortEnterCritical:00000000 vPortEnterCritical
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:96     .text.vPortEnterCritical:00000010 $d
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:101    .text.vPortExitCritical:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:106    .text.vPortExitCritical:00000000 vPortExitCritical
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:138    .text.vPortExitCritical:00000018 $d
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:143    .text.vPortYieldFromISR:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:148    .text.vPortYieldFromISR:00000000 vPortYieldFromISR
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:163    .text.vPortYieldFromISR:0000000c $d
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:168    .text.uxGetTickCounterValue:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:173    .text.uxGetTickCounterValue:00000000 uxGetTickCounterValue
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:195    .text.uxGetTickCounterValue:0000000c $d
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:200    .text.vOnCounterRestart:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:205    .text.vOnCounterRestart:00000000 vOnCounterRestart
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:240    .text.vOnCounterRestart:0000001c $d
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:245    .text.vPortStartFirstTask:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:250    .text.vPortStartFirstTask:00000000 vPortStartFirstTask
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:272    .text.xPortStartScheduler:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:277    .text.xPortStartScheduler:00000000 xPortStartScheduler
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:332    .text.xPortStartScheduler:00000034 $d
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:339    .text.vPortSVCHandler:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:344    .text.vPortSVCHandler:00000000 vPortSVCHandler
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:370    .text.vPortSVCHandler:00000024 pxCurrentTCBConst2
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:370    .text.vPortSVCHandler:00000024 $d
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:379    .text.vPortPendSVHandler:00000000 $t
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:384    .text.vPortPendSVHandler:00000000 vPortPendSVHandler
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:427    .text.vPortPendSVHandler:00000040 pxCurrentTCBConst
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:427    .text.vPortPendSVHandler:00000040 $d
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:435    .bss.RTOS_TickDevice:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:439    .bss.RTOS_TickDevice:00000000 RTOS_TickDevice
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:442    .data.uxCriticalNesting:00000000 $d
C:\Users\Franco\AppData\Local\Temp\cc7OeFAY.s:446    .data.uxCriticalNesting:00000000 uxCriticalNesting
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
RTOSTICKLDD1_GetCounterValue
vTaskIncrementTick
RTOSTICKLDD1_Init
RTOSTICKLDD1_Enable
pxCurrentTCB
vTaskSwitchContext
